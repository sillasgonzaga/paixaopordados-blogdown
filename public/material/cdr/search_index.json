[
["index.html", "Ciência de Dados com R - Introdução Prefácio", " Ciência de Dados com R - Introdução Saulo Guerra, Paulo Felipe de Oliveira, Robert McDonnell e Sillas Gonzaga 23/04/2020 Prefácio Este livro foi criado por Saulo Guerra, Paulo Felipe e Sillas Gonzaga para o curso Introdução à Ciência de Dados com R, oferecido pelo IBPAD. Para a construção deste livro, foi utilizado o Bookdown. Em alguns trechos, este livro foi baseado no material produzido por Robert McDonnell. "],
["introdução.html", "1 Introdução 1.1 O que é Ciência de Dados? 1.2 Workflow da Ciência de Dados 1.3 Linguagens para Ciência de dados 1.4 O que é R e por que devo aprendê-lo? 1.5 RStudio 1.6 Buscando Ajuda 1.7 Exercícios", " 1 Introdução 1.1 O que é Ciência de Dados? Trata-se de um termo cada vez mais utilizado para designar uma área de conhecimento voltada para o estudo e a análise de dados, onde busca-se extrair conhecimento e criar novas informações. É uma atividade interdisciplinar, que concilia principalmente duas grandes áreas: Ciência da Computação e Estatística. A Ciência de Dados vem sendo aplicada como apoio em diferentes outras áreas de conhecimento, tais como: Medicina, Biologia, Economia, Comunicação, Ciências Políticas etc. Apesar de não ser uma área nova, o tema vem se popularizando cada vez mais, graças à explosão na produção de dados e crescente dependência dos dados para a tomada de decisão. 1.2 Workflow da Ciência de Dados Não existe apenas uma forma de estruturar e aplicar os conhecimentos da Ciência de Dados. A forma de aplicação varia bastante conforme a necessidade do projeto ou do objetivo que se busca alcançar. Neste curso, usaremos um modelo de workflow bastante utilizado, apresentado no livro R for Data Science (Hadley Wickham 2017). Figura 1.1: Workflow básico para ciência de dados Esse workflow propõe basicamente os seguintes passos: Carregar os dados; Limpar os dados; Transformar, visualizar e modelar (fase exploratória); Comunicar o resultado. 1.3 Linguagens para Ciência de dados Para a aplicação dessas atividades comuns da Ciência de Dados, é necessário dominar-se as ferramentas corretas. Existem diversas linguagens/ferramentas: R, Python, SAS, SQL, Matlab, Stata, Aplicações de BI etc. Cabe ao cientista de dados avaliar qual é a ferramenta mais adequada para alcançar seus objetivos. 1.4 O que é R e por que devo aprendê-lo? R é uma linguagem de programação estatística que vem passando por diversas evoluções e se tornando cada vez mais uma linguagem de amplos objetivos. Podemos entender o R também como um conjunto de pacotes e ferramentas estatísticas, munido de funções que facilitam sua utilização, desde a criação de simples rotinas até análises de dados complexas, com visualizações bem acabadas. Segue alguns motivos para aprender-se R: É completamente gratuito e de livre distribuição; Curva de aprendizado bastante amigável, sendo muito fácil de se aprender; Enorme quantidade de tutoriais e ajuda disponíveis gratuitamente na internet; É excelente para criar rotinas e sistematizar tarefas repetitivas; Amplamente utilizado pela comunidade acadêmica e pelo mercado; Quantidade enorme de pacotes, para diversos tipos de necessidades; Ótima ferramenta para criar relatórios e gráficos. Apenas para exemplificar-se sua versatilidade, este eBook e os slides das aulas foram todos feitos em R. 1.5 RStudio O R puro se apresenta como uma simples “tela preta” com uma linha para inserir comandos. Isso é bastante assustador para quem está começando e bastante improdutivo para quem já faz uso intensivo da ferramenta. Felizmente existe o RStudio, ferramenta auxiliar que usaremos durante todo o curso. Entenda o RStudio como uma interface gráfica com diversas funcionalidades que melhoram ainda mais o uso e aprendizado do R. Na prática, o RStudio facilita muito o dia a dia de trabalho. Portanto, desde já, ao falarmos em R, falaremos automaticamente no RStudio. Essa é a “cara” do RStudio: Figura 1.2: RStudio se divide em 4 partes Repare que, além da barra de menu superior, o RStudio é divido em quatro partes principais: Editor de Código No editor de código, você poderá escrever e editar os scripts. Script nada mais é do que uma sequência de comandos/ordens que serão executados em sequência pelo R. O editor do RStudio oferece facilidades como organização dos comandos, “auto-complete” de comandos, destaque da sintaxe dos comandos etc. Provavelmente é a parte que mais utilizaremos. Console É no console que o R mostrará a maioria dos resultados dos comandos. Também é possível escrever os comandos diretamente no console, sem o uso do editor de código. É muito utilizado para testes e experimentos rápidos. Um uso rápido do console é, por exemplo, chamar a ajuda do R usando o comando ? (isso mesmo, a interrogação é um comando!). Voltaremos a falar deste comando ? em breve. Environment e History No Environment ficarão guardados todos os objetos que forem criados na sessão do R. Entenda sessão como o espaço de tempo entre o momento em que você inicia o R e o momento em que finaliza. Neste período, tudo que você faz usa memória RAM e o processador do computador. E na aba History, como você deve imaginar, o RStudio cria um histórico de comandos utilizados. Files, Plots, Packages, Help e Viewer. Nesta janela, estão várias funcionalidades do RStudio. Na aba Files, você terá uma navegação de arquivos do seu computador. Também será possível definir o diretório de trabalho (você também pode definir diretamente no código, mas isto será tratado posteriormente), ou seja, o R entende o seu diretório de trabalho como ponto de partida para localizar arquivos que sejam chamados no script. 4.1 Aba Plots A aba Plots trará os gráficos gerados, possibilitando a exportação para alguns formatos diferentes, como .png e .pdf. 4.2 Aba Packages Em Packages estão listados os pacotes instalados. Você pode verificar quais estão carregados e, caso necessário, poderá carregar algum pacote necessário para a sua análise. Também é possível instalar e atualizar pacotes. Novamente, tudo isto é possível fazer diretamente no código. 4.3 Aba Help O nome já diz tudo. Esta aba será bastante utilizada por você. Saber usar o help é fundamental para evitar desperdício de tempo. Os usuários de R, em geral, são bastante solícitos. Entretanto, uma olhadinha rápida no help pode evitar que você gaste “créditos” desnecessariamente. 4.4 Aba Viewer Por fim, o Viewer. Esta funcionalidade é utilizada para visualizar-se localmente conteúdo web. O gráfico da figura está na aba Viewer porque é uma visualização em javascript, que pode ser adicionada a documentos html gerados usando o RMarkdown ou em aplicações web com suporte do Shiny. 1.6 Buscando Ajuda Independentemente do seu nível de conhecimento, sempre haverá a necessidade de buscar ajuda. Ou seja, saber procurar ajuda é essencial para aprimorar seus conhecimentos em Ciência de Dados. Segue algumas dicas de como buscar ajuda para sanar dúvidas e resolver problemas em R: Sempre procure em inglês. Apesar da comunidade R em língua portuguesa ser bem grande, a de língua inglesa é maior ainda. É muito provável que seus problemas e dúvidas já tenham sido sanados; Explore bem o help do próprio R; Conheça e aprenda a usar o stack overflow, a maior comunidade de ajuda técnica da internet. Se mesmo explorando todas as dicas acima não conseguir resolver seu problema, procure por fóruns específicos. Se você for realizar uma pergunta em algum fórum ou site de perguntas e respostas, é importante atentar para alguns pontos que deverão ser informados para que fique mais fácil de alguém te ajudar: Versão do R que está usando; Sistema operacional; Forneça um exemplo replicável; Veja se a sua dúvida já não foi abordada em outro tópico. 1.7 Exercícios Digite o comando R.Version(). O que acontece? Encontre o item de menu Help e descubra como identificar a versão do seu RStudio. Encontre o item de menu Cheatsheets. O que este menu oferece? Entre no site https://stackoverflow.com e digite [r] na caixa de busca. O que acontece? References "],
["conceitos-básicos.html", "2 Conceitos Básicos 2.1 Console 2.2 Scripts 2.3 Objetos (Variáveis) 2.4 Funções 2.5 Pacotes 2.6 Boas práticas 2.7 Tidyverse 2.8 Exercícios", " 2 Conceitos Básicos ## ── Attaching packages ──────────────────────────────────────────────────────────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.0 ✓ purrr 0.3.4 ## ✓ tibble 3.0.1 ✓ dplyr 0.8.5 ## ✓ tidyr 1.0.2 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.4.0 ## ── Conflicts ─────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Entenda o R como uma grande calculadora científica cheia de botões, mas, ao invés de apertar os botões, você irá escrever os comandos. Ou seja, aprender R significa se familiarizar com os comandos e saber quando usá-los. Todos os comandos são baseados em inglês e seus nomes, normalmente, dão dicas a respeito do seu uso. 2.1 Console O console é uma das quatro partes principais do RStudio. Lá é onde você vai digitar suas ordens (comandos) e também é onde o R vai “responder”. Para que o R possa interpretar corretamente, será necessário que você conheça a sintaxe da linguagem e a escrita correta dos comandos. Olhando para o console, você verá o símbolo &gt;. Este símbolo indica a linha onde você deve inserir os comandos. Clique nesse símbolo para posicionar o cursor na linha de comandos e digite seu primeiro comando em R: 2 * 3. Digite e aperte enter. Você verá o seguinte resultado: ## [1] 6 Além de outras funcionalidades mais interessantes, o R é como uma grande calculadora científica, como apontado anteriormente. Para entender melhor esse conceito, vamos exercitar um pouco o console de comandos. Digite um por um os seguintes comandos e acompanhe os resultados: 7 * 9 + 2 * 6 2.5 * 4 (50 + 7)/(8 * (3 - 5/2)) 3 ^ 4 Repare que, na medida em que executa os comandos, o R vai respondendo. Esse é o comportamento básico do console, muito utilizado para obter-se resultados rápidos de comandos específicos. Uma funcionalidade importante é o fato de que o R guarda um histórico dos últimos comandos executados e para acessá-los basta apertar a seta para cima no teclado. 2.2 Scripts Enquanto no console seus comandos são executados na medida em que você os “envia” com a ordem enter, em um script você ordena a execução de uma sequência de comandos, escritos previamente, um seguido do outro. Esses scripts são escritos no editor de códigos do RStudio. Para entender melhor, localize o editor de códigos no RStudio e copie os mesmos comandos anteriores, executados no console. No editor de códigos, a ordem para a execução dos comandos não é o enter, para executá-los, clique em Source, no canto superior direito da área do editor de códigos. Repare bem, pois há uma setinha escura que revelará duas opções de Source (execução do script): Source, e Source With Echo. A diferença entre as duas opções é que a primeira executa mas não exibe as respostas no console, já a segunda executa mostrando as respostas no mesmo. A primeira opção será útil em outros casos de scripts muito grandes, ou em situações nas quais não convenha “poluir” o console com um monte de mensagens. Há um atalho de teclado para o Source: ctrl + shift + enter. Aprenda este atalho, pois você usará muito mais o editor de códigos do que o console para executar os passos da sua análise. Agora posicione o cursor do mouse com um clique em apenas um dos comandos do seu script. Em seguida, clique no ícone Run, também no canto superior na área do editor de códigos. Repare que, dessa vez, o R executou apenas um comando, aquele que estava na linha selecionada. Esse tipo de execução também é bastante útil, mas esteja atento, pois é muito comum que comandos em sequência dependam da execução de comandos anteriores para funcionarem corretamente. Há, também, um atalho de teclado para o Run: ctrl + enter. Este é outro comando importante de ser lembrado, pois é muito importante e será muito utilizado. 2.2.1 Salvando Scripts Ao digitar seus comandos no console, o máximo que você consegue recuperar são os comandos imediatamente anteriores, usando a seta para cima. Já no editor de códigos, existe a possibilidade de salvar os seus scripts para continuar em outro momento ou em outro computador, preservar trabalhos passados ou compartilhar seus códigos com a equipe. Um script em R tem a extensão (terminação) .R. Se você tiver o RStudio instalado e der dois clicks em um arquivo com extesão .R, o windows abrirá esse arquivo diretamente no RStudio. Ainda utilizando os comandos digitados no editor de códigos, vá em File &gt; Save, escolha um local e um nome para seu script e confirme no botão Save. Lembre-se sempre de ser organizado na hora de armazenar os seus arquivos. Utilize pastas para os diferentes projetos e dentro delas escolha nomes explicativos para os seus trabalhos. Para salvar mais rapidamente, utilize o atalho ctrl + S. 2.2.2 Comentários de Código Ao utilizar o símbolo # em uma linha, você está dizendo para o R ignorar aquela linha, pois trata-se de um comentário. Clique na primeira linha do seu script, aperte enter para adicionar uma linha a mais e digite # Meu primeiro comentário de código!. Repare que a cor do comentário é diferente. Execute novamente seu script com o Source (ctrl + shift + enter) e veja que nada mudou na execução. A título de experimento, retire o símbolo # e mantenha o texto do comentário. Execute novamente. O R tenta interpretar essa linha como comando e já que ele não consegue entendê-lo, exibe uma mensagem de erro no console. O símbolo de comentário também é muito útil para suprimir linhas de código que servem para testar determinados comportamentos. Para exemplificar, adicione o símbolo # em qualquer uma das linhas com as operações e veja que ela não será mais executada, será ignorada, pois foi entendida pelo R como um simples comentário de código. 2.3 Objetos (Variáveis) Para que o R deixe de ser uma simples calculadora, será necessário aprender, dentre outras coisas, o uso de variáveis. Se você tem alguma noção de estatística, provavelmente já tem a intuição do que é uma variável para uma linguagem de programação. No contexto do R, vamos entender variável como um objeto, ou seja, como uma estrutura predefinida que vai “receber” algum valor. Utilizando uma linguagem mais técnica, objeto (ou variável) é um pequeno espaço na memória do seu computador onde o R armazenará um valor ou o resultado de um comando, utilizando um nome que você mesmo definiu. Conhecer os tipos de objetos do R é fundamental. Para criar objetos, utiliza-se o símbolo &lt;-. Este provavelmente é o símbolo que você mais verá daqui para frente. Execute, no console ou no editor de códigos, o seguinte comando x &lt;- 15. Pronto, agora o nome x representa o valor 15. Para comprovar, execute apenas o nome do objeto x, o R mostrará o conteúdo dele. A partir de então, você poderá utilizar esse objeto como se fosse o valor 15. Experimente os seguintes resultados: x + 5 x * x / 2 2 ^ x y &lt;- x / 3 Dê uma boa lida em Dicas e boas práticas para um código organizado para aprender a organizar seus objetos e funções da melhor maneira possível. Todos os objetos que você criar estarão disponíveis na aba Environment. O RStudio possui a função auto complete. Digite as primeiras letras de um objeto (ou função) que você criou e, em seguida, use o atalho ctrl + barra de espaço. O RStudio listará tudo que começar com essas letras no arquivo. Selecione algum item e aperte enter para escrevê-lo no editor de códigos. 2.4 Funções Entenda função como uma sequência de comandos preparados para serem usados de forma simples e, assim, facilitar sua vida. Funções são usadas para tudo que você possa imaginar: cálculos mais complexos, estatística, análise de dados, manipulação de dados, gráficos, relatórios etc. Assim que você o instala, o R já vem configurado com várias funções prontas para uso. A partir de agora, chamaremos esse conjunto de funções que já vem por padrão com o R de R Base. Claro que as funções do R base não serão suficientes para resolver todos os problemas que você encontrará pela frente. Nesse sentido, o R também mostra outro ponto forte. Você pode instalar conjuntos extras de funções específicas de maneira muito simples: usando pacotes. Funcões do R base. raiz.quadrada &lt;- sqrt(16) # função para calcular raiz quadrada round(5.3499999, 2) # função para arredondamento Uma função tem dois elementos básicos: o nome e o(s) parâmetro(s) (também chamados de argumentos). Por exemplo, a função log(10) possui o nome log() e apenas um parâmetro, que é o número que você quer calcular o log. Já a função round() possui dois parâmetros, o número que você quer arredondar e a quantidade de dígitos para arredondamento. Quando você usa uma função, você pode informar os parâmetros de duas formas: sequencialmente, sem explicitar o nome dos parâmetros, ou na ordem que quiser, explicitando o nome dos parâmetros. Veja o exemplo a seguir: round(5.3499999, 2) # o mesmo que: round(digits = 2, x = 5.3499999) Para saber como informar os parâmetros corretamente, utilize o comando ? (ou coloque o cursor no nome da função e pressione F1) para ver a documentação de funções, ou seja, conhecer para que serve, entender cada um dos seus parâmetros e ver exemplos de uso. ?round ?rnorm ??inner_join # procurar ajuda de funções que não estão &quot;instaladas&quot; ainda Vale comentar que é possível informar objetos nos parâmetros das funções. x &lt;- 3.141593 round(x, 3) ## [1] 3.142 ceiling(x) ## [1] 4 floor(x) ## [1] 3 Observe algumas das principais funções para estatísticas básicas no R: Função R Estatística sum() Soma de valores mean() Média var() Variância median() Mediana summary() Resumo Estatístico quantile() Quantis 2.5 Pacotes Como dito antes, pacotes são conjuntos extras de funções que podem ser instalados além do R base. Existem pacotes para auxiliar as diversas linhas de estudo que você possa imaginar: estatística, econometria, ciências sociais, medicina, biologia, gráficos, machine learning etc. Caso você precise de algum pacote específico, procure no Google pelo tema que necessita. Você encontrará o nome do pacote e o instalará normalmente. Nesse link você pode ver uma lista de todos os pacotes disponíveis no repositório central. Além desses, ainda existe a possibilidade de instalar-se pacotes “não oficiais”, que ainda não fazem parte de um repositório central. Para instalar um pacote, execute o seguinte comando: install.packages(&quot;dplyr&quot;) # instala um famoso pacote de manipulação de dados Uma vez instalado, esse pacote estará disponível para uso sempre que quiser, sem a necessidade de instalá-lo novamente. Mas, sempre que iniciar um código novo, você precisará carregá-lo na memória. Para isso, use o seguinte comando: library(dplyr) Para instalar um pacote, você precisa informar o nome entre aspas install.packages(“readxl”), caso contrário o pacote não funcionará. Porém, para carregar o pacote em memória, você pode usar com ou sem aspas library(readxl) ou library(“readxl”), ambas as formas funcionam. 2.6 Boas práticas Rapidamente você perceberá que quanto mais organizado e padronizado mantiverem-se os seus códigos, melhor para você e para sua equipe. Existem dois guias de boas práticas bastante famosos na comunidade do R. Um sugerido pelo Hadley Wickham e outro por uma equipe do Google. Dentre as dicas de boa prática, algumas são mais importantes, como, por exemplo: não use acentos e caracteres especiais. Outro ponto importante: o R não aceita variáveis que comecem com números. Você pode até usar números no meio do nome, mas nunca começar com números. O principal de tudo é: seja qual for o padrão que você preferir, escolha apenas um padrão e seja consistente a ele. Guia sugerido Hadley Wickham: http://adv-r.had.co.nz/Style.html _ Guia sugerido pelo Google: https://google.github.io/styleguide/Rguide.xml 2.7 Tidyverse Como já dito, eventualmente as funções do R base não são suficientes ou simplesmente não fornecem a maneira mais fácil de resolver-se um problema. Neste curso utilizaremos o Tidyverse: uma coleção de pacotes R cuidadosamente desenhados para atuarem no workflow comum da ciência de dados: importação, manipulação, exploração e visualização de dados. Uma vez carregado, esse pacote disponibiliza todo o conjunto de ferramentas de outros pacotes importantes: ggplot2, tibble, tidyr, readr, purrr e dplyr. Oportunamente, detalharemos cada um deles. O Tidyverse foi idealizado, dentre outros responsáveis, por Hadley Wickham, um dos maiores colaboradores da comunidade R. Se você não o conhece e pretende seguir em frente com o R, certamente ouvirá falar muito dele. Recomendamos segui-lo nas redes sociais para ficar por dentro das novidades do Tidyverse. Para instalar os pacotes do Tidyverse, rode o comando abaixo: install.packages(&quot;tidyverse&quot;) 2.8 Exercícios Quais as principais diferenças entre um script e o console? Digite ?dplyr. O que acontece? E se digitar ??dplyr? Para que serve esse pacote? Para que serve a função rnorm()? Quais os seus parâmetros/atributos? Para que serve a função rm()? Quais os seus parâmetros/atributos? Rode o comando abaixo para instalar os pacotes usados neste livro: install.packages(c(&quot;broom&quot;, &quot;choroplethrMaps&quot;, &quot;DT&quot;, &quot;dygraphs&quot;, &quot;gapminder&quot;, &quot;ggrepel&quot;, &quot;ggthemes&quot;, &quot;gridExtra&quot;, &quot;hrbrthemes&quot;, &quot;htmltools&quot;, &quot;ISLR&quot;, &quot;jsonlite&quot;, &quot;knitr&quot;, &quot;leaflet&quot;, &quot;ModelMetrics&quot;, &quot;nycflights13&quot;, &quot;plotly&quot;, &quot;RColorBrewer&quot;, &quot;readxl&quot;, &quot;scales&quot;, &quot;titanic&quot;, &quot;viridis&quot;, &quot;WDI&quot;, &quot;xtable&quot;, &quot;xts&quot;, &quot;sf&quot;) "],
["lendo-os-dados.html", "3 Lendo os dados 3.1 Tipos de Estrutura dos Dados 3.2 Definindo o Local dos Dados 3.3 Pacote para leitura dos dados 3.4 Exercícios:", " 3 Lendo os dados Após o entendimento do problema/projeto que se resolverá com a ciência de dados, será necessário fazer com que o R leia os dados. Seja lá qual for o assunto do projeto, é muito importante garantir uma boa fonte de dados. Dados ruins, inconsistentes, não confiáveis ou mal formatados podem gerar muita dor de cabeça para o analista. 3.1 Tipos de Estrutura dos Dados Os dados podem ser apresentados de diversas maneiras, não existe um padrão único para a difusão ou divulgação. Sendo assim, é bom que você esteja preparado para lidar com qualquer tipo de estrutura de dados. Existem diversas classificações de estrutura de dados. Vamos utilizar uma classificação mais generalista, que diz respeito a como os dados são disponibilizados. Sendo assim, podemos classificar os dados em três grandes tipos quanto à sua estrutura ou forma: dados estruturados, semiestruturados e não estruturados. 3.1.1 Dados Estruturados Talvez seja o formato de dados mais fácil de se trabalhar no R. São conjuntos de informações organizadas em colunas (atributos, variáveis, features etc.) e linhas (registros, itens, observações etc.). São dados mais comumente encontrados diretamente em bancos de dados, arquivos com algum tipo de separação entre as colunas, Excel, arquivos com campos de tamanho fixo etc. 3.1.2 Dados Não Estruturados Como o nome diz, estes dados não têm uma estrutura previsível, ou seja, cada conjunto de informações possui uma forma única. Geralmente são arquivos com forte teor textual. Não podemos dizer que são dados “desorganizados”, e sim que são organizações particulares para cada conjunto de informações. Podemos citar, por exemplo, e-mails, twitters, PDF, imagens, vídeos etc. Analisar este tipo de dado é muito mais complexo e exige conhecimento avançado em mineração de dados. Apesar disso, é o tipo de dado mais abundante na realidade. 3.1.3 Dados Semiestruturados São dados que também possuem uma organização fixa, porém não seguem o padrão de estrutura linha/coluna, ou seja, seguem uma estrutura mais complexa e flexível, geralmente hierárquica, estruturada em tags ou marcadores de campos. São exemplos de arquivos semiestruturados: JSON, XML, HTML, YAML etc. É o formato mais usado em troca de dados pela internet e consumo de Application programming interface (API). Dados semiestruturados, algumas vezes, são facilmente transformados em dados estruturados. 3.2 Definindo o Local dos Dados O R sempre trabalha com o conceito de Working direcotry, ou seja, uma pasta de trabalho onde vai “ler” e “escrever” os dados. Para verificar qual o diretório que o R está “olhando”, utilize o seguinte comando: getwd() #Get Working Directory Para informar ao R em qual pasta ele deve ler os arquivos, utilizamos o comando set working directory, que muda o diretório padrão do R para leitura e escrita: setwd(&#39;D:/caminho/do/arquivo/arquivo.csv&#39;) 3.3 Pacote para leitura dos dados O R base possui funções para a leitura dos principais tipos de arquivos. Um outro pacote específico, e muito bom para isso, é o readr. O Tidyverse inclui o carregamento do pacote readr. Diversos tipos de arquivos são lidos pelo R: Comma-Separated Values (csv), Excel, arquivos separados por delimitadores, colunas de tamanho fixo etc. Talvez o tipo de arquivo (estruturado) mais comum hoje em dia, e mais simples de trabalhar, seja o csv. Começaremos a importar dados com arquivos csv. library(tidyverse) # já carrega o readr #ou library(readr) Vamos importar um csv chamado senado.csv. Caso o arquivo esteja em seu working directory (getwd()), basta passar apenas o nome do arquivo para a função, caso contrário será necessário informar todo o caminho até a pasta do arquivo. Usamos o read_csv() para fazer isso. senado &lt;- read_csv(&quot;senado.csv&quot;) Esse comando carrega o conteúdo do arquivo senado.csv para o objeto (variável) senado. Após o carregamento, começaremos a investigar o conteúdo desse objeto: os dados. O head e o tail são funções para ver a “cabeça” e o “rabo” dos seus dados, ou seja, o começo e o fim das amostras. É muito importante sempre observar a “aparência” dos dados após o carregamento. Essa observação ajuda a identificar erros básicos no carregamento, possibilitando ajustes o quanto antes, impedindo que esses erros se propaguem. Repare que na primeira linha temos os nomes das colunas e, em seguida, os registros. head(senado) ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content Round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2007001 PRS0002/07 FLEXA RIBEI… S PSDB FALSE PA 2 11 0 85.5 S 1 Create… 1 ## 2 2007001 PRS0002/07 ARTHUR VIRG… S PSDB FALSE AM 2 11 0 85.5 S 1 Create… 1 ## 3 2007001 PRS0002/07 FLAVIO ARNS N PT TRUE PR 2 11 0 85.5 S 1 Create… 1 ## 4 2007001 PRS0002/07 MARCELO CRI… S PRB TRUE RJ 2 11 0 85.5 S 1 Create… 1 ## 5 2007001 PRS0002/07 JOAO DURVAL N PDT FALSE BA 2 11 0 85.5 S 1 Create… 1 ## 6 2007001 PRS0002/07 PAULO PAIM S PT TRUE RS 2 11 0 85.5 S 1 Create… 1 tail(senado) ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content Round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2010027 PLC0010/10 EDISON LOBAO S PMDB TRUE MA 1 1 0 97.8 S 1 Rules … 1 ## 2 2010027 PLC0010/10 EDUARDO SUP… S PT TRUE SP 1 1 0 97.8 S 1 Rules … 1 ## 3 2010027 PLC0010/10 JARBAS VASC… N PMDB TRUE PE 1 1 0 97.8 S 1 Rules … 1 ## 4 2010027 PLC0010/10 MARISA SERR… S PSDB FALSE MS 1 1 0 97.8 S 1 Rules … 1 ## 5 2010027 PLC0010/10 EPITACIO CA… S PTB FALSE MA 1 1 0 97.8 S 1 Rules … 1 ## 6 2010027 PLC0010/10 INACIO ARRU… S PCdoB TRUE CE 1 1 0 97.8 S 1 Rules … 1 Outros comandos muito importantes para começar a investigar os dados são o str(), o class() e o summary(). Para verificar o tipo do objeto, ou seja, sua classe, utilize: class(senado) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Já para verificar a estrutura do objeto, ou seja, seus campos (quando aplicável), insira: str(senado) #STRucture ## tibble [9,262 × 15] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ VoteNumber : num [1:9262] 2007001 2007001 2007001 2007001 2007001 ... ## $ SenNumber : chr [1:9262] &quot;PRS0002/07&quot; &quot;PRS0002/07&quot; &quot;PRS0002/07&quot; &quot;PRS0002/07&quot; ... ## $ SenatorUpper: chr [1:9262] &quot;FLEXA RIBEIRO&quot; &quot;ARTHUR VIRGILIO&quot; &quot;FLAVIO ARNS&quot; &quot;MARCELO CRIVELLA&quot; ... ## $ Vote : chr [1:9262] &quot;S&quot; &quot;S&quot; &quot;N&quot; &quot;S&quot; ... ## $ Party : chr [1:9262] &quot;PSDB&quot; &quot;PSDB&quot; &quot;PT&quot; &quot;PRB&quot; ... ## $ GovCoalition: logi [1:9262] FALSE FALSE TRUE TRUE FALSE TRUE ... ## $ State : chr [1:9262] &quot;PA&quot; &quot;AM&quot; &quot;PR&quot; &quot;RJ&quot; ... ## $ FP : num [1:9262] 2 2 2 2 2 2 2 2 2 2 ... ## $ Origin : num [1:9262] 11 11 11 11 11 11 11 11 11 11 ... ## $ Contentious : num [1:9262] 0 0 0 0 0 0 0 0 0 0 ... ## $ PercentYes : num [1:9262] 85.5 85.5 85.5 85.5 85.5 ... ## $ IndGov : chr [1:9262] &quot;S&quot; &quot;S&quot; &quot;S&quot; &quot;S&quot; ... ## $ VoteType : num [1:9262] 1 1 1 1 1 1 1 1 1 1 ... ## $ Content : chr [1:9262] &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and Information Technology (CCT).&quot; &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and Information Technology (CCT).&quot; &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and Information Technology (CCT).&quot; &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and Information Technology (CCT).&quot; ... ## $ Round : num [1:9262] 1 1 1 1 1 1 1 1 1 1 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. VoteNumber = col_double(), ## .. SenNumber = col_character(), ## .. SenatorUpper = col_character(), ## .. Vote = col_character(), ## .. Party = col_character(), ## .. GovCoalition = col_logical(), ## .. State = col_character(), ## .. FP = col_double(), ## .. Origin = col_double(), ## .. Contentious = col_double(), ## .. PercentYes = col_double(), ## .. IndGov = col_character(), ## .. VoteType = col_double(), ## .. Content = col_character(), ## .. Round = col_double() ## .. ) Para verificar estatísticas básicas do objeto (média, mediana, quantis, mínimo, máximo etc.), quando aplicáveis: summary(senado) ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State ## Min. :2007001 Length:9262 Length:9262 Length:9262 Length:9262 Mode :logical Length:9262 ## 1st Qu.:2008006 Class :character Class :character Class :character Class :character FALSE:3480 Class :character ## Median :2009003 Mode :character Mode :character Mode :character Mode :character TRUE :5782 Mode :character ## Mean :2008483 ## 3rd Qu.:2009048 ## Max. :2010027 ## FP Origin Contentious PercentYes IndGov VoteType Content ## Min. :1.000 Min. : 1.000 Min. :0.00000 Min. : 2.174 Length:9262 Min. :1.000 Length:9262 ## 1st Qu.:2.000 1st Qu.: 1.000 1st Qu.:0.00000 1st Qu.: 66.667 Class :character 1st Qu.:1.000 Class :character ## Median :2.000 Median : 2.000 Median :0.00000 Median : 96.078 Mode :character Median :1.000 Mode :character ## Mean :1.878 Mean : 2.595 Mean :0.01781 Mean : 82.509 Mean :1.159 ## 3rd Qu.:2.000 3rd Qu.: 4.000 3rd Qu.:0.00000 3rd Qu.: 98.148 3rd Qu.:1.000 ## Max. :2.000 Max. :11.000 Max. :1.00000 Max. :100.000 Max. :2.000 ## Round ## Min. :1.000 ## 1st Qu.:1.000 ## Median :1.000 ## Mean :1.358 ## 3rd Qu.:2.000 ## Max. :4.000 Acontece que nem sempre o separador será o ;, típico do csv. Nesse caso será necessário usar o read_delim(), onde você pode informar qualquer tipo de separador. Outro tipo de arquivo bastante comum é o de colunas com tamanho fixo (fixed width), também conhecido como colunas posicionais. Nesse caso, será necessário usar o read_fwf() informando o tamanho de cada coluna. Exemplo: #lendo arquivo com delimitador # read_delim(&#39;caminho/do/arquivo/arquivo_separado_por#.txt&#39;, delim = &#39;#&#39;) #lendo arquivo de coluna fixa #coluna 1 de tamanho 5, coluna 2 de tamanho 2 e coluna 3 de tamanho 10 read_fwf(&#39;caminho/do/arquivo/arquivo_posicional.txt&#39;, col_positions = fwf_widths(c(5, 2, 10), c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;))) No capítulo a seguir exploraremos melhor os tipos de objetos mais comuns no R. Referências: Site do pacote readr com mais exemplos Site do pacote readxl, usado para ler arquivos Excel 3.4 Exercícios: Leia o arquivo TA_PRECOS_MEDICAMENTOS.csv, cujo separador é uma barra |. Leia o arquivo de colunas fixas fwf-sample.txt, cuja primeira coluna (nomes) tem tamanho vinte, a segunda (estado) tem tamanho dez e a terceira (código) tem tamanho doze. Investigue os parâmetros das funções de leitura do R base: read.csv(), read.delim() e read.fwf(). Notou as diferenças das funções do readr? "],
["manipulando-os-dados.html", "4 Manipulando os dados 4.1 Tipos de Variáveis e Colunas 4.2 If e Else 4.3 Loops 4.4 Manipulações com R base 4.5 Pacote dplyr 4.6 Exercícios", " 4 Manipulando os dados Neste capítulo, usaremos estes pacotes: library(nycflights13) library(tidyverse) Após obter uma boa fonte de dados, e carregá-los para poder trabalhá-los no R, você certamente precisará realizar algumas limpezas e manipulações para que os dados estejam no ponto ideal para as fases finais de uma análise: execução de modelos econométricos, visualizações de dados, tabelas agregadas, relatórios etc. A realidade é que, na prática, os dados nunca estarão do jeito que você de fato precisa. Portanto, é fundamental dominar técnicas de manipulação de dados. Entendamos a manipulação de dados como o ato de transformar, reestruturar, limpar, agregar e juntar os dados. Para se ter uma noção da importância dessa fase, alguns estudiosos da área de Ciência de Dados costumam afirmar que 80% do trabalho é encontrar uma boa fonte de dados, limpar e preparar os dados, sendo que os 20% restantes seriam o trabalho de aplicar modelos e realizar alguma análise propriamente dita. 80% of data analysis is spent on the process of cleaning and preparing the data (Dasu and Johnson, 2003). Data preparation is not just a first step, but must be repeated many over the course of analysis as new problems come to light or new data is collected (Hadley Wickham). 4.1 Tipos de Variáveis e Colunas Existem diversos tipos de objetos, e cada tipo “armazena” um conteúdo diferente, desde tabelas de dados recém-carregados a textos, números, ou simplesmente a afirmação de verdadeiro ou falso (Boleano). inteiro &lt;- 928 outro.inteiro &lt;- 5e2 decimal &lt;- 182.93 caracter &lt;- &#39;exportação&#39; logico &lt;- TRUE outro.logico &lt;- FALSE Repare nas atribuições acima. Usaremos a função class() para ver o tipo de cada uma: class(inteiro) ## [1] &quot;numeric&quot; class(outro.inteiro) ## [1] &quot;numeric&quot; class(decimal) ## [1] &quot;numeric&quot; class(caracter) ## [1] &quot;character&quot; class(logico) ## [1] &quot;logical&quot; class(outro.logico) ## [1] &quot;logical&quot; Esses são alguns dos tipos básicos de objetos/variáveis no R. Para valores inteiros ou decimais, numeric , character para valores textuais e logical para valores lógicos (verdadeiro ou falso). Existe também o tipo integer, que representa apenas números inteiros, sem decimais, porém, na maioria das vezes, o R interpreta o integer como numeric, pois o integer também é um numeric. Além dos tipos básicos, existem também os tipos “complexos”, que são vector, array, matrix, list, data.frame e factor. Data frame é, provavelmente, o tipo de dado complexo mais utilizado em R. É nele que você armazena conjuntos de dados estruturados em linhas e colunas. Um data frame possui colunas nomeadas, sendo que todas as colunas possuem a mesma quantidade de linhas. Imagine o dataframe como uma tabela. class(senado) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; dim(senado) ## [1] 9262 15 Percebeu o termo tbl no output acima? Significa tibble(), que, conforme o próprio pacote chamado tibble descreve, corresponde a uma moderna implementação da estrutura data.frame. A classe tibble não possui algumas deficiências da classe data.frame, por isso a usaremos sempre que possui. É muito simples transformar um data.frame em tibble. # carregando um dataset pronto do R data(iris) # verificando a classe class(iris) ## [1] &quot;data.frame&quot; # transformando para tibble iris_tbl &lt;- as_tibble(iris) # verificando a classe do novo objeto class(iris_tbl) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Imprima no seu console os dois objetos e note a diferença: print(iris) print(iris_tbl) Outro tipo que já utilizamos bastante até agora, mas que não foi detalhado, é o vector, ou vetor. Vetores são sequências unidimensionais de valores de um mesmo tipo: #faça as seguintes atribuições vetor.chr &lt;- c(&#39;tipo1&#39;, &#39;tipo2&#39;, &#39;tipo3&#39;, &#39;tipo4&#39;) vetor.num &lt;- c(1, 2, 5, 8, 1001) vetor.num.repetidos &lt;- c(rep(2, 50)) #usando funcão para repetir números vetor.num.sequencia &lt;- c(seq(from=0, to=100, by=5)) #usando função para criar sequências vetor.logical &lt;- c(TRUE, TRUE, TRUE, FALSE, FALSE) ##veja o conteúdo das variáveis vetor.chr ## [1] &quot;tipo1&quot; &quot;tipo2&quot; &quot;tipo3&quot; &quot;tipo4&quot; vetor.num ## [1] 1 2 5 8 1001 vetor.num.repetidos ## [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 vetor.num.sequencia ## [1] 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 vetor.logical ## [1] TRUE TRUE TRUE FALSE FALSE Para a criação de vetores, usamos a função de combinação de valores c() (combine). Esta função vai combinar todos os parâmetros em um único vetor. Lembre-se: vetores são sequências que contêm apenas um tipo de dado. Conhecendo o data.frame e o vector, você será capaz de entender como os dois se relacionam. Cada coluna de um data frame é um vetor. Um data frame pode ter colunas de diferentes tipos, mas cada coluna só pode ter registros de um único tipo. Ficará mais claro a seguir. Veja como se cria um data.frame: #cria-se diferentes vetores nome &lt;- c(&#39;João&#39;, &#39;José&#39;, &#39;Maria&#39;, &#39;Joana&#39;) idade &lt;- c(45, 12, 28, 31) adulto &lt;- c(TRUE, FALSE, TRUE, TRUE) uf &lt;- c(&#39;DF&#39;, &#39;SP&#39;, &#39;RJ&#39;, &#39;MG&#39;) #cada vetor é uma combinação de elementos de um MESMO tipo de dados #sendo assim, cada vetor pode ser uma coluna de um data.frame clientes &lt;- data.frame(nome, idade, adulto, uf) clientes ## nome idade adulto uf ## 1 João 45 TRUE DF ## 2 José 12 FALSE SP ## 3 Maria 28 TRUE RJ ## 4 Joana 31 TRUE MG str(clientes) ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ nome : Factor w/ 4 levels &quot;Joana&quot;,&quot;João&quot;,..: 2 3 4 1 ## $ idade : num 45 12 28 31 ## $ adulto: logi TRUE FALSE TRUE TRUE ## $ uf : Factor w/ 4 levels &quot;DF&quot;,&quot;MG&quot;,&quot;RJ&quot;,..: 1 4 3 2 4.1.1 Conversões de tipos de variáveis Quando é feito o carregamento de algum arquivo de dados no R, ele tenta “deduzir” os tipos de dados de cada coluna. Nem sempre essa dedução sai correta e, eventualmente, você precisará converter de um tipo para o outro. O R tem algumas funções para fazer essas conversões. class(&quot;2015&quot;) ## [1] &quot;character&quot; as.numeric(&quot;2015&quot;) ## [1] 2015 class(55) ## [1] &quot;numeric&quot; as.character(55) ## [1] &quot;55&quot; class(3.14) ## [1] &quot;numeric&quot; as.integer(3.14) ## [1] 3 as.numeric(TRUE) ## [1] 1 as.numeric(FALSE) ## [1] 0 as.logical(1) ## [1] TRUE as.logical(0) ## [1] FALSE O R também tenta “forçar a barra”, às vezes, para te ajudar. Quando você faz uma operação entre dois tipos diferentes, ele tenta fazer algo chamado coerção de tipos, ou seja, ele tenta converter os dados para que a operação faça sentido. Caso o R não consiga fazer a coerção, ele vai mostrar uma mensagem de erro. Experimente os comandos a seguir no console: 7 + TRUE 2015 &gt; &quot;2016&quot; &quot;2014&quot; &lt; 2017 # em alguns casos a coerção irá falhar ou dar resultado indesejado 6 &gt; &quot;100&quot; &quot;6&quot; &lt; 5 1 + &quot;1&quot; Recomendamos fortemente que sempre se realize as conversões explicitamente com as funções apropriadas ao invés de confiar na coerção do R, a não ser que se tenha certeza do resultado. 4.1.2 Outros tipos de variáveis Existem outros tipos de variáveis bastante utilizados. Citaremos alguns deles, pois nesse curso utilizaremos muito pouco os demais tipos. Tipo Descrição Dimensões Homogêneo vector Coleção de elementos simples. Todos os elementos precisam ser do mesmo tipo básico de dado 1 Sim array Coleção que se parece com o vector, mas é multidimensional n Sim matrix Tipo especial de array com duas dimensões 2 Sim list Objeto complexo com elementos que podem ser de diferentes tipos 1 Não data.frame Tipo especial de lista, onde cada coluna é um vetor de apenas um tipo e todas as colunas têm o mesmo número de registros. É o tipo mais utilizado para se trabalhar com dados 2 Não factor Tipo especial de vector, que só contém valores predefinidos (levels) e categóricos (characters). Não é possível adicionar novas categorias sem criação de novos levels 1 Não 4.1.3 Valores faltantes e o ‘NA’ Em casos onde não existe valor em uma coluna de uma linha, o R atribui NA. É muito comum lidar com conjuntos de dados que tenham ocorrências de NA em alguns campos. É importante saber o que se fazer em casos de NA, e nem sempre a solução será a mesma: varia de acordo com as suas necessidades. Em algumas bases de dados, quem gera o dado atribui valores genéricos como 999 ou até mesmo um “texto vazio”, ' '. Neste caso, você provavelmente terá que substituir esses valores “omissos” por NA. Imputar dados em casos de NA é uma das várias estratégias para lidar-se com ocorrência de missing no conjunto dos dados. Seguem algumas funções úteis para lidar-se com NA: A função summary() pode ser usada para averiguar a ocorrência de NA. A função is.na() realiza um teste para saber se a variável/coluna possui um valor NA. retorna TRUE se for NA e FALSE se não for. A função complete.cases() retorna TRUE para as linhas em que todas as colunas possuem valores válidos (preenchidos) e FALSE para as linhas em que, em alguma coluna, existe um NA. Ou seja, esta função diz quais são as linhas (amostras) completas em todas as suas características (campos). Algumas funções possuem o argumento na.rm, ou semelhantes, para desconsiderar NA no cálculo. É o caso da função mean() ou sum(). Por exemplo: data(&quot;airquality&quot;) # carrega uma base de dados pré-carregada no R summary(airquality) # verificando ocorrência de NA ## Ozone Solar.R Wind Temp Month Day ## Min. : 1.00 Min. : 7.0 Min. : 1.700 Min. :56.00 Min. :5.000 Min. : 1.0 ## 1st Qu.: 18.00 1st Qu.:115.8 1st Qu.: 7.400 1st Qu.:72.00 1st Qu.:6.000 1st Qu.: 8.0 ## Median : 31.50 Median :205.0 Median : 9.700 Median :79.00 Median :7.000 Median :16.0 ## Mean : 42.13 Mean :185.9 Mean : 9.958 Mean :77.88 Mean :6.993 Mean :15.8 ## 3rd Qu.: 63.25 3rd Qu.:258.8 3rd Qu.:11.500 3rd Qu.:85.00 3rd Qu.:8.000 3rd Qu.:23.0 ## Max. :168.00 Max. :334.0 Max. :20.700 Max. :97.00 Max. :9.000 Max. :31.0 ## NA&#39;s :37 NA&#39;s :7 is.na(airquality$Ozone) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [22] FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE FALSE FALSE TRUE ## [43] TRUE FALSE TRUE TRUE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE ## [64] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE ## [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE ## [106] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [127] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [148] FALSE FALSE TRUE FALSE FALSE FALSE 4.1.4 Estruturas de Controle de Fluxo Para auxiliar no processo de manipulação de dados, você eventualmente precisará de algumas técnicas e estruturas de controle de fluxo. Estruturas para controle de fluxo nada mais são do que loops e condições. São estruturas fundamentais para qualquer linguagem de programação. 4.2 If e Else A estrutura condicional é algo bastante intuitivo. A estrutura de if (se) e else (então) usa os operadores lógicos apresentados anteriormente. Se a condição do if() for verdadeira, executa-se uma tarefa específica, se for falsa, executa-se uma tarefa diferente. A estrutura parece algo do tipo: if( variavel &gt;= 500 ) { #executa uma tarefa se operação resultar TRUE } else { #executa outra tarefa se operação resultar FALSE } Da mesma forma, existe uma função que gera o mesmo resultado, o ifelse() (e uma do pacote dplyr, o if_else()). ifelse(variavel &gt;= 500, &#39;executa essa tarefa se TRUE&#39;, &#39;executa outra se FALSE&#39;) Existe uma diferença entre as duas formas de “if else”: a estrutura if() {} else {} só opera variáveis, uma por uma, já a estrutura ifelse() opera vetores, ou seja, consegue fazer a comparação para todos os elementos. Isso faz com que a forma if() {} else {} seja mais utilizada para comparações fora dos dados, com variáveis avulsas. Já a estrutura ifelse() é mais usada para comparações dentro dos dados, com colunas, vetores e linhas. Qualquer uma dessas estruturas pode ser “aninhada”, ou seja, encadeada. Por exemplo: a &lt;- 9823 if(a &gt;= 10000) { b &lt;- &#39;VALOR ALTO&#39; } else if(a &lt; 10000 &amp; a &gt;= 1000) { b &lt;- &#39;VALOR MEDIO&#39; } else if(a &lt; 1000) { b &lt;- &#39;VALOR BAIXO&#39; } b ## [1] &quot;VALOR MEDIO&quot; Ou ainda: a &lt;- 839 c &lt;- ifelse(a &gt;= 10000, &#39;VALOR ALTO&#39;, ifelse(a &lt; 10000 &amp; a &gt;= 1000, &#39;VALOR MEDIO&#39;, &#39;VALOR BAIXO&#39;)) c ## [1] &quot;VALOR BAIXO&quot; 4.3 Loops Trata-se de um dos conceitos mais importantes de qualquer linguagem de programação, em R não é diferente. Loops (ou laços) repetem uma sequência de comando quantas vezes você desejar, ou até que uma condição aconteça, variando-se alguns aspectos entre uma repetição e outra. Supondo que você tenha que ler 400 arquivos de dados que você obteve de um cliente. Você vai escrever 400 vezes a funcão de leitura? Nesse caso, basta fazer um loop para percorrer todos os arquivos da pasta e ler um por um com a função de leitura. 4.3.1 For O for() é usado para realizar uma série de ordens para uma determinada sequência ou índices (vetor). Sua sintaxe é bem simples: for(i in c(1, 2, 3, 4, 5)) { print(i^2) } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 ## [1] 25 Para cada valor (chamamos esse valor de i) dentro do vetor c(1, 2, 3, 4, 5), execute o comando print(i^2). Qualquer outro comando dentro das chaves { ... } seria executado para cada valor do vetor. Para entendermos melhor, vamos repensar o exemplo das séries usando o for(). lista.de.arquivos &lt;- list.files(&#39;dados/dados_loop&#39;) #lista todos os arquivos de uma pasta is.vector(lista.de.arquivos) ## [1] TRUE for(i in lista.de.arquivos) { print(paste(&#39;Leia o arquivo:&#39;, i)) #exemplo: read_delim(i, delim = &quot;|&quot;) } ## [1] &quot;Leia o arquivo: arquivo1.txt&quot; ## [1] &quot;Leia o arquivo: arquivo10.txt&quot; ## [1] &quot;Leia o arquivo: arquivo11.txt&quot; ## [1] &quot;Leia o arquivo: arquivo12.txt&quot; ## [1] &quot;Leia o arquivo: arquivo13.txt&quot; ## [1] &quot;Leia o arquivo: arquivo2.txt&quot; ## [1] &quot;Leia o arquivo: arquivo3.txt&quot; ## [1] &quot;Leia o arquivo: arquivo4.txt&quot; ## [1] &quot;Leia o arquivo: arquivo5.txt&quot; ## [1] &quot;Leia o arquivo: arquivo6.txt&quot; ## [1] &quot;Leia o arquivo: arquivo7.txt&quot; ## [1] &quot;Leia o arquivo: arquivo8.txt&quot; ## [1] &quot;Leia o arquivo: arquivo9.txt&quot; Também é possível utilizar loop com if. No exemplo a seguir, queremos ver todos os números de 1 a 1000 que são divisíveis por 29 e por 3 ao mesmo tempo. Para isso, utilizaremos o operador %%, que mostra o resto da divisão. Se o resto for zero, é divisível. for(i in 1:1000){ if((i %% 29 == 0) &amp; (i %% 3 == 0)){ print(i) } } ## [1] 87 ## [1] 174 ## [1] 261 ## [1] 348 ## [1] 435 ## [1] 522 ## [1] 609 ## [1] 696 ## [1] 783 ## [1] 870 ## [1] 957 4.3.2 While O while() também é uma estrutura de controle de fluxo do tipo loop, mas, diferentemente do for(), o while executa as tarefas repetidamente até que uma condição seja satisfeita, não percorrendo um vetor. i &lt;- 1 while(i &lt;= 5){ print(i) i &lt;- i + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 O uso do while é um pouco menos intuitivo, mas não menos importante. O while é mais apropriado para eventos de automação ou simulação, onde tarefas serão executadas quando um “gatilho” for acionado. Um simples exemplo para ajudar na intuição de seu uso é: automatico &lt;- list.files(&#39;dados/automatico/&#39;) length(automatico) == 0 Temos uma pasta vazia. O loop abaixo vai monitorar essa pasta. Enquanto essa pasta estiver vazia, ele estará em execução. Quando você colocar um arquivo dentro dessa pasta, vai mudar a condição length(automatico) == 0 de TRUE para FALSE e vai mudar a condição length(automatico) &gt; 0 de FALSE para TRUE, disparando todas as tarefas programadas. Usamos a função Sys.sleep(5) para que o código espere por mais cinco segundos antes de começar o loop novamente. while (length(automatico) == 0) { automatico &lt;- list.files(&#39;dados/automatico/&#39;) if(length(automatico) &gt; 0) { print(&#39;O arquivo chegou!&#39;) print(&#39;Inicia a leitura dos dados&#39;) print(&#39;Faz a manipulação&#39;) print(&#39;Envia email informando conclusão dos cálculos&#39;) } else { print(&#39;aguardando arquivo...&#39;) Sys.sleep(5) } } Faça o teste: execute o código acima, aguarde alguns segundos e perceba que nada aconteceu. Crie um arquivo qualquer dentro da pasta dados/automatico/. Imediatamente o loop será encerrado e as tarefas executadas. Observe o output em tela. 4.3.3 Funções Funções “encapsulam” uma sequência de comandos e instruções. É uma estrutura nomeada, que recebe parâmetros para iniciar sua execução e retorna um resultado ao final. Até o momento, você já usou diversas funções. Vejamos então como criar uma função: sua_funcao &lt;- function(parametro1, parametro2){ # sequência de tarefas return(valores_retornados) } # chamada da função sua_funcao Agora tente entender a seguinte função: montanha_russa &lt;- function(palavra) { retorno &lt;- NULL for(i in 1:nchar(palavra)) { if(i %% 2 == 0) { retorno &lt;- paste0(retorno, tolower(substr(palavra, i, i))) } else { retorno &lt;- paste0(retorno, toupper(substr(palavra, i, i))) } } return(retorno) } montanha_russa(&#39;teste de função: letras maiúsculas e minúsculas&#39;) ## [1] &quot;TeStE De fUnÇãO: lEtRaS MaIúScUlAs e mInÚsCuLaS&quot; montanha_russa(&#39;CONSEGUIU ENTENDER?&#39;) ## [1] &quot;CoNsEgUiU EnTeNdEr?&quot; montanha_russa(&#39;É Fácil Usar Funções!&#39;) ## [1] &quot;É FáCiL UsAr fUnÇõEs!&quot; 4.4 Manipulações com R base Dominar a manipulação de data frames e vetores é muito importante. Em geral, toda manipulação pode ser feita com o R base, mas acreditamos que utilizando técnicas do tidyverse a atividade fica bem mais fácil. Portanto, utilizaremos o dplyr, um dos principais pacotes do tidyverse. Porém, alguns conceitos do R base são clássicos e precisam ser dominados. 4.4.1 Trabalhando com colunas de um data.frame Para selecionar ou trabalhar separadamente com apenas um campo (coluna) do seu data.frame, deve-se utilizar o $. Repare nas funções abaixo e no uso do sifrão. head(airquality$Ozone) ## [1] 41 36 12 18 NA 28 tail(airquality$Ozone) ## [1] 14 30 NA 14 18 20 class(airquality$Ozone) # Informa o tipo da coluna ## [1] &quot;integer&quot; is.vector(airquality$Ozone) # Apenas para verificar que cada coluna de um data.frame é um vector ## [1] TRUE unique(senado$Party) # Função que retorna apenas os valores únicos, sem repetição, de um vetor ## [1] &quot;PSDB&quot; &quot;PT&quot; &quot;PRB&quot; &quot;PDT&quot; &quot;PR&quot; &quot;PFL/DEM&quot; &quot;PMDB&quot; &quot;PP&quot; &quot;PSB&quot; &quot;PTB&quot; &quot;PCdoB&quot; &quot;PSOL&quot; ## [13] &quot;S/PART&quot; &quot;PSC&quot; &quot;PV1&quot; Lembre-se sempre: cada coluna de um data.frame é um vetor, portanto todos os registros (linhas) daquela coluna devem ser do mesmo tipo. Um data.frame pode ser considerado um conjunto de vetores nomeados, todos do mesmo tamanho, ou seja, todos com a mesma quantidade de registros. Usando termos mais técnicos, um data frame é um conjunto de dados HETEROGÊNEOS, pois cada coluna pode ser de um tipo, e BIDIMENSIONAL, por possuir apenas linhas e colunas. Já o vetor é um conjunto de dados HOMOGÊNEO, pois só pode ter valores de um mesmo tipo, e UNIDIMENSIONAL. Com esses conceitos em mente fica mais fácil entender o que mostraremos a seguir: vetor &lt;- c(seq(from=0, to=100, by=15)) #vetor de 0 a 100, de 15 em 15. vetor #lista todos os elementos ## [1] 0 15 30 45 60 75 90 vetor[1] #mostra apenas o elemento na posição 1 ## [1] 0 vetor[2] #apenas o elemento na posição 2 ## [1] 15 vetor[7] #apenas o elemento na posição 7 ## [1] 90 vetor[8] #não existe nada na posição 8... ## [1] NA A notação [] é usada para selecionar o elemento em uma ou mais posições do vetor. vetor[c(2,7)] #selecionando mais de um elemento no vetor ## [1] 15 90 Uma notação parecida é usada para selecionar elementos no data.frame. Porém, como já comentamos, data frames são BIDIMENSIONAIS. Então usaremos a notação [,] com uma vírgula separando qual a linha (posição antes da vírgula) e a coluna (posição após a vírgula) que queremos selecionar. senado[10, ] #linha 10, todas as colunas ## # A tibble: 1 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content Round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2007001 PRS0002/07 MAO SANTA S PMDB TRUE PI 2 11 0 85.5 S 1 Create… 1 senado[72, 3] #linha 72, coluna 3 ## # A tibble: 1 x 1 ## SenatorUpper ## &lt;chr&gt; ## 1 WELLINGTON SALGADO senado[c(100, 200), c(2,3,4)] # selecionando mais de uma linha e coluna em um data.frame ## # A tibble: 2 x 3 ## SenNumber SenatorUpper Vote ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PLS0229/06 MARISA SERRANO S ## 2 PLS0134/06 EPITACIO CAFETEIRA S senado[c(10:20), ] ## # A tibble: 11 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content Round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2007001 PRS0002/… MAO SANTA S PMDB TRUE PI 2 11 0 85.5 S 1 Create… 1 ## 2 2007001 PRS0002/… MAGNO MALTA S PR TRUE ES 2 11 0 85.5 S 1 Create… 1 ## 3 2007001 PRS0002/… EDUARDO SUP… S PT TRUE SP 2 11 0 85.5 S 1 Create… 1 ## 4 2007001 PRS0002/… GILVAM BORG… S PMDB TRUE AP 2 11 0 85.5 S 1 Create… 1 ## 5 2007001 PRS0002/… RAIMUNDO CO… S PFL/… FALSE SC 2 11 0 85.5 S 1 Create… 1 ## 6 2007001 PRS0002/… CICERO LUCE… S PSDB FALSE PB 2 11 0 85.5 S 1 Create… 1 ## 7 2007001 PRS0002/… FRANCISCO D… S PP TRUE RJ 2 11 0 85.5 S 1 Create… 1 ## 8 2007001 PRS0002/… OSMAR DIAS N PDT FALSE PR 2 11 0 85.5 S 1 Create… 1 ## 9 2007001 PRS0002/… ALFREDO NAS… S PR TRUE AM 2 11 0 85.5 S 1 Create… 1 ## 10 2007001 PRS0002/… VALDIR RAUPP S PMDB TRUE RO 2 11 0 85.5 S 1 Create… 1 ## 11 2007001 PRS0002/… GARIBALDI A… S PMDB TRUE RN 2 11 0 85.5 S 1 Create… 1 Repare na notação c(10:20), você pode usar : para criar sequências. Experimente 1:1000 Também é possível selecionar o item desejado utilizando o próprio nome da coluna: senado[1:10, c(&#39;SenatorUpper&#39;, &#39;Party&#39;, &#39;State&#39;)] ## # A tibble: 10 x 3 ## SenatorUpper Party State ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 FLEXA RIBEIRO PSDB PA ## 2 ARTHUR VIRGILIO PSDB AM ## 3 FLAVIO ARNS PT PR ## 4 MARCELO CRIVELLA PRB RJ ## 5 JOAO DURVAL PDT BA ## 6 PAULO PAIM PT RS ## 7 EXPEDITO JUNIOR PR RO ## 8 EFRAIM MORAIS PFL/DEM PB ## 9 ALOIZIO MERCADANTE PT SP ## 10 MAO SANTA PMDB PI Existem diversas outras formas de seleção e manipulação de dados, como, por exemplo, seleção condicional: head(senado[senado$Party == &#39;PDT&#39;, ]) ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content Round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2007001 PRS0002/07 JOAO DURVAL N PDT FALSE BA 2 11 0 85.5 S 1 Create… 1 ## 2 2007001 PRS0002/07 OSMAR DIAS N PDT FALSE PR 2 11 0 85.5 S 1 Create… 1 ## 3 2007001 PRS0002/07 CRISTOVAM B… A PDT FALSE DF 2 11 0 85.5 S 1 Create… 1 ## 4 2007002 PLS0229/06 JOAO DURVAL S PDT FALSE BA 2 11 0 98.2 S 1 Bestow… 1 ## 5 2007002 PLS0229/06 OSMAR DIAS S PDT FALSE PR 2 11 0 98.2 S 1 Bestow… 1 ## 6 2007002 PLS0229/06 CRISTOVAM B… S PDT FALSE DF 2 11 0 98.2 S 1 Bestow… 1 Em todas as comparações do R usamos operadores lógicos. São operações matemáticas em que o resultado é TRUE ou FALSE (tipo logic). Para melhor entendimento, selecionamos alguns operadores lógicos e seus significados: == igual a: compara dois objetos e se forem iguais retorna TRUE, caso contrário, FALSE; != diferente: compara dois objetos e se forem diferentes retorna TRUE, caso contrário, FALSE; | ou (or): compara dois objetos, se um dos dois for TRUE, retorna TRUE, se os dois forem FALSE, retorna FALSE; &amp; e (and): compara dois objetos, se os dois forem TRUE, retorna TRUE, se um dos dois ou os dois forem FALSE, retorna FALSE; &gt;, &gt;=, &lt;, &lt;= maior, maior ou igual, menor, menor ou igual: compara grandeza de dois números e retorna TRUE ou FALSE conforme a condição; É possível fazer muita coisa com o R base, porém, vamos avançar com as manipulações, utilizando o pacote dplyr, por ser mais simples e, por isso, de mais rápido aprendizado. 4.5 Pacote dplyr O forte do pacote dplyr é a sintaxe simples e concisa, o que facilita o aprendizado e torna o pacote um dos preferidos para as tarefas do dia a dia. Também conta como ponto forte sua otimização de performance para manipulação de dados. Ao carregar o pacote tidyverse, você já carregará automaticamente o pacote dplyr, mas você também pode carregá-lo individualmente: install.packages(&quot;dplyr&quot;) library(dplyr) ?dplyr Referências: Site do pacote dplyr 4.5.1 Verbetes do dplyr e o operador %&gt;% O dplyr cobre praticamente todas as tarefas básicas da manipulação de dados: agregar, sumarizar, filtrar, ordenar, criar variáveis, joins, dentre outras. As funções do dplyr reproduzem as principais tarefas da manipulação, de forma bastante intuitiva. Veja só: select() filter() arrange() mutate() group_by() summarise() Esses são os principais verbetes, mas existem outros disponíveis, como por exemplo slice(), rename() e transmute(). Além de nomes de funções intuitivos, o dplyr também faz uso de um recurso disponível em boa parte dos pacotes do Hadley, o operador %&gt;% (originário do pacote magrittr). Este operador encadeia as chamadas de funções de forma que você não vai precisar ficar chamando uma função dentro da outra ou ficar fazendo atribuições usando diversas linhas para concluir suas manipulações. Aliás, podemos dizer que esse operador %&gt;%, literalmente, cria um fluxo sequencial bastante claro e legível para todas as atividades de manipulação. Os 6 principais verbetes listados acima possuem funções derivadas com os sufixos _at, _if e _all, que podem ser muito úteis em arquivos com muitas colunas. 4.5.2 Select O select() é a função mais simples de ser entendida. É usada para selecionar variáveis (colunas, campos, features…) do seu data frame. senadores.partido &lt;- senado %&gt;% select(SenatorUpper, Party) head(senadores.partido) ## # A tibble: 6 x 2 ## SenatorUpper Party ## &lt;chr&gt; &lt;chr&gt; ## 1 FLEXA RIBEIRO PSDB ## 2 ARTHUR VIRGILIO PSDB ## 3 FLAVIO ARNS PT ## 4 MARCELO CRIVELLA PRB ## 5 JOAO DURVAL PDT ## 6 PAULO PAIM PT Você pode, também, fazer uma “seleção negativa”, ou seja, escolher as colunas que não quer: senadores.partido &lt;- senado %&gt;% select(-SenatorUpper, -Party) head(senadores.partido) ## # A tibble: 6 x 13 ## VoteNumber SenNumber Vote GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content Round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2007001 PRS0002/07 S FALSE PA 2 11 0 85.5 S 1 Creates the Senate Commis… 1 ## 2 2007001 PRS0002/07 S FALSE AM 2 11 0 85.5 S 1 Creates the Senate Commis… 1 ## 3 2007001 PRS0002/07 N TRUE PR 2 11 0 85.5 S 1 Creates the Senate Commis… 1 ## 4 2007001 PRS0002/07 S TRUE RJ 2 11 0 85.5 S 1 Creates the Senate Commis… 1 ## 5 2007001 PRS0002/07 N FALSE BA 2 11 0 85.5 S 1 Creates the Senate Commis… 1 ## 6 2007001 PRS0002/07 S TRUE RS 2 11 0 85.5 S 1 Creates the Senate Commis… 1 select_at(): Selecionar um conjunto de variáveis, especificadas pelo nome ou pela posição numérica, podendo aplicar uma função ao nome delas: # manter apenas as colunas que começam com S e transformar o nome para maiusculo senado %&gt;% select_at(vars(starts_with(&quot;S&quot;)), toupper) %&gt;% head() ## # A tibble: 6 x 3 ## SENNUMBER SENATORUPPER STATE ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PRS0002/07 FLEXA RIBEIRO PA ## 2 PRS0002/07 ARTHUR VIRGILIO AM ## 3 PRS0002/07 FLAVIO ARNS PR ## 4 PRS0002/07 MARCELO CRIVELLA RJ ## 5 PRS0002/07 JOAO DURVAL BA ## 6 PRS0002/07 PAULO PAIM RS select_if(): Selecionar o conjunto de variáveis do dataframe que atende a um teste lógico: # selecionar apenas as colunas numericas do dataframe senado %&gt;% select_if(is.numeric) %&gt;% head() ## # A tibble: 6 x 7 ## VoteNumber FP Origin Contentious PercentYes VoteType Round ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2007001 2 11 0 85.5 1 1 ## 2 2007001 2 11 0 85.5 1 1 ## 3 2007001 2 11 0 85.5 1 1 ## 4 2007001 2 11 0 85.5 1 1 ## 5 2007001 2 11 0 85.5 1 1 ## 6 2007001 2 11 0 85.5 1 1 select_all(): seleciona todas as colunas, opcionalmente aplicando uma função ao nome delas. senado %&gt;% select_all(tolower) ## # A tibble: 9,262 x 15 ## votenumber sennumber senatorupper vote party govcoalition state fp origin contentious percentyes indgov votetype content round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2007001 PRS0002/… FLEXA RIBEI… S PSDB FALSE PA 2 11 0 85.5 S 1 Create… 1 ## 2 2007001 PRS0002/… ARTHUR VIRG… S PSDB FALSE AM 2 11 0 85.5 S 1 Create… 1 ## 3 2007001 PRS0002/… FLAVIO ARNS N PT TRUE PR 2 11 0 85.5 S 1 Create… 1 ## 4 2007001 PRS0002/… MARCELO CRI… S PRB TRUE RJ 2 11 0 85.5 S 1 Create… 1 ## 5 2007001 PRS0002/… JOAO DURVAL N PDT FALSE BA 2 11 0 85.5 S 1 Create… 1 ## 6 2007001 PRS0002/… PAULO PAIM S PT TRUE RS 2 11 0 85.5 S 1 Create… 1 ## 7 2007001 PRS0002/… EXPEDITO JU… S PR TRUE RO 2 11 0 85.5 S 1 Create… 1 ## 8 2007001 PRS0002/… EFRAIM MORA… S PFL/… FALSE PB 2 11 0 85.5 S 1 Create… 1 ## 9 2007001 PRS0002/… ALOIZIO MER… S PT TRUE SP 2 11 0 85.5 S 1 Create… 1 ## 10 2007001 PRS0002/… MAO SANTA S PMDB TRUE PI 2 11 0 85.5 S 1 Create… 1 ## # … with 9,252 more rows Referências: Documentação da função select() Documentação das funções derivadas de select() 4.5.3 Filter Além de escolher apenas alguns campos, você pode escolher apenas algumas linhas, utilizando alguma condição como filtragem. Para isso, basta utilizar a função filter. senadores.pdt.df &lt;- senado %&gt;% select(SenatorUpper, Party, State) %&gt;% filter(State == &#39;RJ&#39;, Party == &#39;PMDB&#39;) %&gt;% distinct() #semelhante ao unique(), traz registros únicos sem repetição head(senadores.pdt.df) ## # A tibble: 2 x 3 ## SenatorUpper Party State ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PAULO DUQUE PMDB RJ ## 2 REGIS FICHTNER PMDB RJ # filtrar votações com votos SIM acima de 90% senado %&gt;% filter(PercentYes &gt; 90) %&gt;% head() ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content Round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2007002 PLS0229/06 JOAO DURVAL S PDT FALSE BA 2 11 0 98.2 S 1 Bestow… 1 ## 2 2007002 PLS0229/06 EDUARDO SUP… S PT TRUE SP 2 11 0 98.2 S 1 Bestow… 1 ## 3 2007002 PLS0229/06 OSMAR DIAS S PDT FALSE PR 2 11 0 98.2 S 1 Bestow… 1 ## 4 2007002 PLS0229/06 PRESIDENT L… S PT TRUE &lt;NA&gt; 2 11 0 98.2 S 1 Bestow… 1 ## 5 2007002 PLS0229/06 GERALDO MES… S PMDB TRUE AC 2 11 0 98.2 S 1 Bestow… 1 ## 6 2007002 PLS0229/06 FLEXA RIBEI… S PSDB FALSE PA 2 11 0 98.2 S 1 Bestow… 1 Referências: Documentação da função filter() Documentação das funções derivadas de filter() 4.5.4 Mutate Para criar novos campos, podemos usar o mutate: glimpse(senado) ## Rows: 9,262 ## Columns: 15 ## $ VoteNumber &lt;dbl&gt; 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2… ## $ SenNumber &lt;chr&gt; &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07… ## $ SenatorUpper &lt;chr&gt; &quot;FLEXA RIBEIRO&quot;, &quot;ARTHUR VIRGILIO&quot;, &quot;FLAVIO ARNS&quot;, &quot;MARCELO CRIVELLA&quot;, &quot;JOAO DURVAL&quot;, &quot;PAULO PAIM&quot;, &quot;EXPEDITO… ## $ Vote &lt;chr&gt; &quot;S&quot;, &quot;S&quot;, &quot;N&quot;, &quot;S&quot;, &quot;N&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;N&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;,… ## $ Party &lt;chr&gt; &quot;PSDB&quot;, &quot;PSDB&quot;, &quot;PT&quot;, &quot;PRB&quot;, &quot;PDT&quot;, &quot;PT&quot;, &quot;PR&quot;, &quot;PFL/DEM&quot;, &quot;PT&quot;, &quot;PMDB&quot;, &quot;PR&quot;, &quot;PT&quot;, &quot;PMDB&quot;, &quot;PFL/DEM&quot;, &quot;PSDB… ## $ GovCoalition &lt;lgl&gt; FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, … ## $ State &lt;chr&gt; &quot;PA&quot;, &quot;AM&quot;, &quot;PR&quot;, &quot;RJ&quot;, &quot;BA&quot;, &quot;RS&quot;, &quot;RO&quot;, &quot;PB&quot;, &quot;SP&quot;, &quot;PI&quot;, &quot;ES&quot;, &quot;SP&quot;, &quot;AP&quot;, &quot;SC&quot;, &quot;PB&quot;, &quot;RJ&quot;, &quot;PR&quot;, &quot;AM&quot;, &quot;… ## $ FP &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2… ## $ Origin &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 1… ## $ Contentious &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ PercentYes &lt;dbl&gt; 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.45455,… ## $ IndGov &lt;chr&gt; &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;,… ## $ VoteType &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ Content &lt;chr&gt; &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and Information Technology … ## $ Round &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… # criar coluna com o nome do senador em minusculo senado %&gt;% select(SenatorUpper) %&gt;% mutate(SenatorLower = tolower(SenatorUpper)) %&gt;% head() ## # A tibble: 6 x 2 ## SenatorUpper SenatorLower ## &lt;chr&gt; &lt;chr&gt; ## 1 FLEXA RIBEIRO flexa ribeiro ## 2 ARTHUR VIRGILIO arthur virgilio ## 3 FLAVIO ARNS flavio arns ## 4 MARCELO CRIVELLA marcelo crivella ## 5 JOAO DURVAL joao durval ## 6 PAULO PAIM paulo paim Caso o argumento da esquerda em mutate() seja um nome de coluna que já existe no dataframe, esta será sobrescrita: senado %&gt;% mutate(Party = tolower(Party)) %&gt;% head() ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content Round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2007001 PRS0002/07 FLEXA RIBEI… S psdb FALSE PA 2 11 0 85.5 S 1 Create… 1 ## 2 2007001 PRS0002/07 ARTHUR VIRG… S psdb FALSE AM 2 11 0 85.5 S 1 Create… 1 ## 3 2007001 PRS0002/07 FLAVIO ARNS N pt TRUE PR 2 11 0 85.5 S 1 Create… 1 ## 4 2007001 PRS0002/07 MARCELO CRI… S prb TRUE RJ 2 11 0 85.5 S 1 Create… 1 ## 5 2007001 PRS0002/07 JOAO DURVAL N pdt FALSE BA 2 11 0 85.5 S 1 Create… 1 ## 6 2007001 PRS0002/07 PAULO PAIM S pt TRUE RS 2 11 0 85.5 S 1 Create… 1 Veja como é simples realizar a operação acima, de transformar uma coluna para minúsculo, para todas as colunas de texto do dataframe com o auxílio de mutate_if(), na qual o primeiro argumento é um teste lógico e o segundo é a função a ser aplicada para todas as colunas onde o teste lógico seja TRUE. senado %&gt;% # o primeiro argumento de mutate_if mutate_if(is.character, tolower) %&gt;% head() ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content Round ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2007001 prs0002/07 flexa ribei… s psdb FALSE pa 2 11 0 85.5 s 1 create… 1 ## 2 2007001 prs0002/07 arthur virg… s psdb FALSE am 2 11 0 85.5 s 1 create… 1 ## 3 2007001 prs0002/07 flavio arns n pt TRUE pr 2 11 0 85.5 s 1 create… 1 ## 4 2007001 prs0002/07 marcelo cri… s prb TRUE rj 2 11 0 85.5 s 1 create… 1 ## 5 2007001 prs0002/07 joao durval n pdt FALSE ba 2 11 0 85.5 s 1 create… 1 ## 6 2007001 prs0002/07 paulo paim s pt TRUE rs 2 11 0 85.5 s 1 create… 1 Referências: Documentação da função mutate() Documentação das funções derivadas de mutate() 4.5.5 Group By e Summarise O group_by() e o summarise() são operações que trabalham na agregação dos dados, ou seja, um dado mais detalhado passa a ser um dado mais agregado e agrupado, em consequência disso, menos detalhado. O agrupamento de dados geralmente é trabalhado em conjunção com sumarizações, que usam funções matemáticas do tipo soma, média, desvio padrão etc. Enquanto o group_by() “separa” seus dados nos grupos que você selecionar, o summarise() faz operações de agregação de linhas limitadas a esse grupo. Vale observar que operações de agrupamento e sumarização geralmente DIMINUEM a quantidade de linhas dos seus dados, pois está reduzindo o nível de detalhe. Ou seja, de alguma forma, você está “perdendo” detalhe para “ganhar” agregação. Como exemplo, utilizaremos os dados disponíveis no pacote nycflights13: install.packages(&quot;nycflights13&quot;) library(nycflights13) data(&quot;flights&quot;) str(flights) ## tibble [336,776 × 19] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ dep_time : int [1:336776] 517 533 542 544 554 554 555 557 557 558 ... ## $ sched_dep_time: int [1:336776] 515 529 540 545 600 558 600 600 600 600 ... ## $ dep_delay : num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_time : int [1:336776] 830 850 923 1004 812 740 913 709 838 753 ... ## $ sched_arr_time: int [1:336776] 819 830 850 1022 837 728 854 723 846 745 ... ## $ arr_delay : num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ carrier : chr [1:336776] &quot;UA&quot; &quot;UA&quot; &quot;AA&quot; &quot;B6&quot; ... ## $ flight : int [1:336776] 1545 1714 1141 725 461 1696 507 5708 79 301 ... ## $ tailnum : chr [1:336776] &quot;N14228&quot; &quot;N24211&quot; &quot;N619AA&quot; &quot;N804JB&quot; ... ## $ origin : chr [1:336776] &quot;EWR&quot; &quot;LGA&quot; &quot;JFK&quot; &quot;JFK&quot; ... ## $ dest : chr [1:336776] &quot;IAH&quot; &quot;IAH&quot; &quot;MIA&quot; &quot;BQN&quot; ... ## $ air_time : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... ## $ distance : num [1:336776] 1400 1416 1089 1576 762 ... ## $ hour : num [1:336776] 5 5 5 5 6 5 6 6 6 6 ... ## $ minute : num [1:336776] 15 29 40 45 0 58 0 0 0 0 ... ## $ time_hour : POSIXct[1:336776], format: &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; ... Gostaríamos de obter a média de atraso da chegada para cada mês. Para isso, primeiro agrupamos no nível necessário e depois sumarizamos. atraso_por_mes &lt;- flights %&gt;% group_by(month) %&gt;% summarise(arr_delay_media = mean(arr_delay, na.rm=TRUE), dep_delay_media = mean(dep_delay, na.rm=TRUE)) atraso_por_mes ## # A tibble: 12 x 3 ## month arr_delay_media dep_delay_media ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 6.13 10.0 ## 2 2 5.61 10.8 ## 3 3 5.81 13.2 ## 4 4 11.2 13.9 ## 5 5 3.52 13.0 ## 6 6 16.5 20.8 ## 7 7 16.7 21.7 ## 8 8 6.04 12.6 ## 9 9 -4.02 6.72 ## 10 10 -0.167 6.24 ## 11 11 0.461 5.44 ## 12 12 14.9 16.6 A função n() retorna a quantidade de observacões (linhas) por variável especificada em group_by(): # Quantidade de voos por hora do dia flights %&gt;% group_by(carrier) %&gt;% summarise(n_voos = n()) %&gt;% head() ## # A tibble: 6 x 2 ## carrier n_voos ## &lt;chr&gt; &lt;int&gt; ## 1 9E 18460 ## 2 AA 32729 ## 3 AS 714 ## 4 B6 54635 ## 5 DL 48110 ## 6 EV 54173 A função n_distinct() retorna a quantidade de casos únicos por grupo: # quantas companhias aéreas diferentes operam por aeroporto por mês nos EUA? flights %&gt;% group_by(origin, month) %&gt;% summarise(n_empresas = n_distinct(carrier)) %&gt;% head(6) ## # A tibble: 6 x 3 ## # Groups: origin [1] ## origin month n_empresas ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 EWR 1 10 ## 2 EWR 2 10 ## 3 EWR 3 10 ## 4 EWR 4 11 ## 5 EWR 5 11 ## 6 EWR 6 12 Referências: Documentação da função group_by() Documentação da função summarise() 4.5.6 Arrange A função arrange() serve para organizar os dados em sua ordenação. Costuma ser uma das últimas operações, normalmente usada para organizar os dados e facilitar visualizações ou criação de relatórios. Utilizando o exemplo anterior, gostaríamos de ordenar os meses pelas menores médias de decolagem (para ordens decrescentes basta usar o sinal de menos -) media &lt;- flights %&gt;% group_by(month) %&gt;% summarise(arr_delay_media = mean(arr_delay, na.rm=TRUE), dep_delay_media = mean(dep_delay, na.rm=TRUE)) %&gt;% arrange(dep_delay_media) media ## # A tibble: 12 x 3 ## month arr_delay_media dep_delay_media ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 0.461 5.44 ## 2 10 -0.167 6.24 ## 3 9 -4.02 6.72 ## 4 1 6.13 10.0 ## 5 2 5.61 10.8 ## 6 8 6.04 12.6 ## 7 5 3.52 13.0 ## 8 3 5.81 13.2 ## 9 4 11.2 13.9 ## 10 12 14.9 16.6 ## 11 6 16.5 20.8 ## 12 7 16.7 21.7 Referências: Documentação da função arrange() TESTEEEEEE 4.6 Exercícios Utilizando os dados em senado.csv, tente usar da manipulação de dados para responder às perguntas a seguir: Verifique a existência de registros NA em State. Caso existam, crie um novo data.frame senado2 sem esses registros e utilize-o para os próximos exercícios. Dica: is.na(State) Quais partidos foram parte da coalizão do governo? E quais não foram? Dica: filter() Quantos senadores tinha cada partido? Qual tinha mais? Quais tinham menos? Dica: group_by(), summarise() e n_distinct() Qual partido votou mais “sim”? E qual voltou menos “sim”? Dica: sum(Vote == 'S') Qual região do país teve mais votos “sim”? Primeiro será necessário criar uma coluna região para depois contabilizar o total de votos por região. #&gt;Dica: mutate(Regiao = ifelse(State %in% c(&quot;AM&quot;, &quot;AC&quot;, &quot;TO&quot;, &quot;PA&quot;, &quot;RO&quot;, &quot;RR&quot;), &quot;Norte&quot;, ifelse(State %in% c(&quot;SP&quot;, &quot;MG&quot;, &quot;RJ&quot;, &quot;ES&quot;), &quot;Sudeste&quot;, ifelse(State %in% c(&quot;MT&quot;, &quot;MS&quot;, &quot;GO&quot;, &quot;DF&quot;), &quot;Centro-Oeste&quot;, ifelse(State %in% c(&quot;PR&quot;, &quot;SC&quot;, &quot;RS&quot;), &quot;Sul&quot;, &quot;Nordeste&quot;))))) "],
["limpando-dados.html", "5 Limpando dados 5.1 O formato “ideal” dos dados 5.2 Pacote tidyr 5.3 Exercicios", " 5 Limpando dados No dia a dia de quem trabalha com dados, infelizmente, é muito comum se deparar com dados formatados de um jeito bastante complicado de se manipular. Isso acontece pois a forma de se trabalhar com dados é muito diferente da forma de se apresentar ou visualizar dados. Resumindo: “olhar” dados requer uma estrutura bem diferente de “mexer” com dados. Limpeza de dados também é considerada parte da manipulação de dados. 5.1 O formato “ideal” dos dados É importante entender um pouco mais sobre como os dados podem ser estruturados antes de entrarmos nas funções de limpeza. O formato ideal para analisar dados, visualmente, é diferente do formato ideal para analisá-los de forma sistemática. Observe as duas tabelas a seguir: Figura 5.1: Tabela wide Figura 5.2: Tabela long A primeira tabela é mais intuitiva para análise visual, pois faz uso de cores e propõe uma leitura natural, da esquerda para a direita. Utiliza, ainda, elementos e estruturas que guiam seus olhos por uma análise de forma simples. Já a segunda tabela é um pouco árida para se interpretar “no olho”. Há uma espécie de regra geral a qual diz que um dado bem estruturado deve conter uma única variável em uma coluna e uma única observação em uma linha. Observando-se a primeira tabela, com essa regra em mente, podemos perceber que as observações de ano estão organizadas em colunas. Apesar de estar num formato ideal para análise visual, esse formato dificulta bastante certas análises sistemáticas. O melhor a se fazer é converter a primeira tabela a um modelo mais próximo o possível da segunda tabela. Infelizmente, não temos como apresentar um passo a passo padrão para limpeza de dados, pois isso depende completamente do tipo de dado que você receber, da análise que você quer fazer e da sua criatividade em manipulação de dados. Mas conhecer os pacotes certos ajuda muito nessa tarefa. Lembre-se: é muito mais fácil trabalhar no R com dados “bem estruturados”, onde cada coluna deve ser uma única variável e cada linha deve ser uma única observação. Na contramão da limpeza de dados, você provavelmente terá o problema contrário ao final da sua análise. Supondo que você organizou seus dados perfeitamente, conseguiu executar os modelos que gostaria, gerou diversos gráficos interessantes e está satisfeito com o resultado, você ainda precisará entregar relatórios finais da sua análise em forma de tabelas sumarizadas e explicativas, de modo que os interessados possam entender facilmente, apenas com uma rápida análise visual. Neste caso, que tipo de tabela seria melhor produzir? Provavelmente, quem for ler seus relatórios entenderá mais rapidamente as tabelas mais próximas do primeiro exemplo mostrado. É importante aprender a estruturar e desestruturar tabelas de todas as formas possíveis. Para exemplificar, veja algumas tabelas disponíveis no pacote tidyverse, ilustrando os diferentes tipos de organização nos formatos wide e long. Todas as tabelas possuem os mesmos dados e informações: library(tidyverse) table1 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4b ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 table5 ## # A tibble: 6 x 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 5.2 Pacote tidyr Apesar de existirem diversas possibilidades de situações que necessitem de limpeza de dados, a conjugação de três pacotes consegue resolver a grande maioria dos casos: dplyr, tidyr, stringr. O pacote tidyr é mais um dos pacotes criados por Hadley Wickham. Este fato, por si só, já traz algumas vantagens: ele se integra perfeitamente com o dplyr, usando o conector %&gt;%, e tem a sintaxe de suas funções bastante intuitiva. install.packages(&quot;tidyr&quot;) library(tidyr) ?tidyr O tidyr também tem suas funções organizadas em pequenos verbetes, onde cada um representa uma tarefa para organizar os dados. Os verbetes básicos que abordaremos são os seguintes: gather() separate() spread() unite() separate_rows() Vale lembrar que tudo que for feito usando o tidyr é possível executar também usando o R base, mas de uma forma um pouco menos intuitiva. Caso queira entender como usar o R base pra isso, procure mais sobre as funções melt() e cast(). Figura 5.3: Tabela long Referências: Site do pacote tidyr 5.2.1 gather A função gather() serve para agrupar duas ou mais colunas e seus respectivos valores (conteúdos) em pares. Assim, o resultado após o agrupamento é sempre duas colunas. A primeira delas possui observações cujos valores chave eram as colunas antigas e a segunda possui os valores respectivos relacionados com as colunas antigas. Na prática, a função gather diminui o número de colunas e aumenta o número de linhas de nossa base de dados. Usaremos dados disponíveis no R base para exemplificar: data(&quot;USArrests&quot;) str(USArrests) ## &#39;data.frame&#39;: 50 obs. of 4 variables: ## $ Murder : num 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 ... ## $ Assault : int 236 263 294 190 276 204 110 238 335 211 ... ## $ UrbanPop: int 58 48 80 50 91 78 77 72 80 60 ... ## $ Rape : num 21.2 44.5 31 19.5 40.6 38.7 11.1 15.8 31.9 25.8 ... head(USArrests) ## Murder Assault UrbanPop Rape ## Alabama 13.2 236 58 21.2 ## Alaska 10.0 263 48 44.5 ## Arizona 8.1 294 80 31.0 ## Arkansas 8.8 190 50 19.5 ## California 9.0 276 91 40.6 ## Colorado 7.9 204 78 38.7 # Transformando o nome das linhas em colunas USArrests$State &lt;- rownames(USArrests) head(USArrests) ## Murder Assault UrbanPop Rape State ## Alabama 13.2 236 58 21.2 Alabama ## Alaska 10.0 263 48 44.5 Alaska ## Arizona 8.1 294 80 31.0 Arizona ## Arkansas 8.8 190 50 19.5 Arkansas ## California 9.0 276 91 40.6 California ## Colorado 7.9 204 78 38.7 Colorado usa.long &lt;- USArrests %&gt;% gather(key = &quot;tipo_crime&quot;, value = &quot;valor&quot;, -State) head(usa.long) ## State tipo_crime valor ## 1 Alabama Murder 13.2 ## 2 Alaska Murder 10.0 ## 3 Arizona Murder 8.1 ## 4 Arkansas Murder 8.8 ## 5 California Murder 9.0 ## 6 Colorado Murder 7.9 tail(usa.long) ## State tipo_crime valor ## 195 Vermont Rape 11.2 ## 196 Virginia Rape 20.7 ## 197 Washington Rape 26.2 ## 198 West Virginia Rape 9.3 ## 199 Wisconsin Rape 10.8 ## 200 Wyoming Rape 15.6 No primeiro parâmetro do gather(), nós informamos a “chave”, ou seja, a coluna que guardará o que antes era coluna. No segundo parâmetro, informamos o “value”, ou seja, a coluna que guardará os valores para cada uma das antigas colunas. Repare que agora você pode afirmar com certeza que cada linha é uma observação e que cada coluna é uma variável. Referências: Documentação da função gather 5.2.2 spread É a operação antagônica do gather(). Ela espalha os valores de duas colunas em diversos campos para cada registro: os valores de uma coluna viram o nome das novas colunas, e os valores de outra viram valores de cada registro nas novas colunas. Usaremos a table2 para exemplificar: head(table2) ## # A tibble: 6 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 table2.wide &lt;- table2 %&gt;% spread(key = type, value = count) head(table2.wide) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Referências: Documentação da função spread 5.2.3 separate O separate() é usado para separar duas variáveis que estão em uma mesma coluna. Lembre-se: cada coluna deve ser apenas uma única variável! É muito normal virem variáveis juntas em uma única coluna, mas nem sempre isso é prejudicial, cabe avaliar quando vale a pena separá-las. Usaremos o exemplo da table3 para investigar: table3.wide &lt;- table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep=&#39;/&#39;) head(table3.wide) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Referências: Documentação da função separate 5.2.4 unite A operação unite() é o oposto da separate(), ela pega duas colunas (variáveis) e transforma em uma só. É muito utilizada para montar relatórios finais ou tabelas para análise visual. Aproveitemos o exemplo em table2 para montarmos uma tabela final comparando a “case” e “population” de cada país, em cada ano. table2.relatorio &lt;- table2 %&gt;% unite(type_year, type, year) %&gt;% spread(key = type_year, value = count, sep = &#39;_&#39;) table2.relatorio ## # A tibble: 3 x 5 ## country type_year_cases_1999 type_year_cases_2000 type_year_population_1999 type_year_population_2000 ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 19987071 20595360 ## 2 Brazil 37737 80488 172006362 174504898 ## 3 China 212258 213766 1272915272 1280428583 Referências: Documentação da função unite O primeiro parâmetro é a coluna que desejamos criar, os próximos são as colunas que desejamos unir e, por fim, temos o sep, que representa algum símbolo opcional para ficar entre os dois valores na nova coluna. 5.2.5 separate_rows Do mesmo modo que separate() quebra uma coluna em várias, separate_rows() quebra uma linha em várias de acordo com um separador. Essa função é muito útil para lidar com dados sujos. Observe o exemplo: # criar dataframe de exemplo exemplo &lt;- tibble(grupo = c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;,&quot;b&quot;), y = c(&quot;1, 2&quot;, &quot;3;4&quot;, &quot;1,2,3&quot;, &quot;4&quot;)) exemplo %&gt;% separate_rows(y, sep = &quot;,&quot;) ## # A tibble: 7 x 2 ## grupo y ## &lt;chr&gt; &lt;chr&gt; ## 1 a &quot;1&quot; ## 2 a &quot; 2&quot; ## 3 a &quot;3;4&quot; ## 4 b &quot;1&quot; ## 5 b &quot;2&quot; ## 6 b &quot;3&quot; ## 7 b &quot;4&quot; Referências: Documentação da função separate_rows 5.3 Exercicios Utilizando senado.csv, monte uma tabela mostrando a quantidade de votos sim e não por coalisão, no formato wide (“sim” e “não” são linhas e “coalisão” ou “não coalisão” são colunas). Dica: mutate(tipo_coalisao = ifelse(GovCoalition, 'Coalisão', 'Não Coalisão')) ## # A tibble: 2 x 3 ## Tipo_voto Coalisão `Não Coalisão` ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Votos Não 702 657 ## 2 Votos Sim 5002 2739 "],
["juntando-dados.html", "6 Juntando dados 6.1 União de dados (Union) 6.2 Cruzamento de Dados (Join) 6.3 Exercícios 6.4 Exercícios gerais do Tidyverse", " 6 Juntando dados Existem duas grandes formas de junção de dados: UNIÃO e CRUZAMENTO. Para que uma união seja possível, os dois conjuntos de dados precisam ter os mesmos campos. Para que um cruzamento seja possível, os dois conjuntos precisam ter pelo menos um campo em comum. Figura 6.1: União de tabelas Figura 6.2: Cruzamento de tabelas 6.1 União de dados (Union) A união de dados é mais intuitiva. Basta ter a mesma quantidade de campos e que estes estejam “alinhados”. A função mais usada para isso é o famoso rbind() (Row Bind). Caso os campos tenham exatamente os mesmos nomes e tipo, o rbind() consegue fazer a união perfeitamente. dados2016 &lt;- data.frame(ano = c(2016, 2016, 2016), valor = c(938, 113, 1748), produto = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)) dados2017 &lt;- data.frame(valor = c(8400, 837, 10983), produto = c(&#39;H&#39;, &#39;Z&#39;, &#39;X&#39;), ano = c(2017, 2017, 2017)) dados.finais &lt;- rbind(dados2016, dados2017) dados.finais ## ano valor produto ## 1 2016 938 A ## 2 2016 113 B ## 3 2016 1748 C ## 4 2017 8400 H ## 5 2017 837 Z ## 6 2017 10983 X A união de dados é a forma mais simples de juntá-los. 6.2 Cruzamento de Dados (Join) O cruzamento de dados é um pouco mais complexo, mas nem por isso chega a ser algo difícil. Para entender-se como fazer “joins” (cruzamentos), é preciso compreender-se o conceito de chave. Entenda chave como uma coluna que está presente da mesma forma em dois conjuntos de dados distintos. O conceito completo de chave é bem mais complexo que isto, mas, para começarmos a entender e usar os joins, basta usar essa intuição. Tendo esse conceito simplificado de chave em mente, a primeira coisa que se deve fazer quando for preciso cruzar dois conjuntos de dados é tentar identificar quais os campos chaves, ou seja, quais campos estão presentes nos dois grupos. O que acontece quando nem todos os códigos de um grupo estão no outro? E quando um grupo tem códigos repetidos em várias linhas? Para responder a essas e outras perguntas precisamos conhecer os diferentes tipos de joins. Existe pelo menos uma dezena de tipos de joins, mas 90% das vezes você precisará apenas dos tipos básicos que explicaremos a seguir. Usaremos o pacote dplyr para aplicar os joins. O R base possui a função merge() para joins, se tiver curiosidade procure mais sobre ela depois. Referências: Documentação das funções *_join 6.2.1 Inner Join (ou apenas Join) Trata-se do join mais simples, mais básico e mais usado dentre todos os outros tipos. O seu comportamento mantém no resultado apenas as linhas presentes nos dois conjuntos de dados que estão sendo cruzados. O inner join funciona da seguinte forma: Figura 6.3: Cruzamento de tabelas A tabela final, após o cruzamento, conterá as linhas com as chaves que estiverem em AMBOS os conjuntos de dados. As linhas com chaves que não estão em ambos serão descartadas. Esta característica torna o inner join muito útil para fazer-se filtros. Vamos utilizar dados já disponíveis no dplyr para testar os joins: band_members ## # A tibble: 3 x 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones ## 2 John Beatles ## 3 Paul Beatles band_instruments ## # A tibble: 3 x 2 ## name plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar str(band_members) ## tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## $ name: chr [1:3] &quot;Mick&quot; &quot;John&quot; &quot;Paul&quot; ## $ band: chr [1:3] &quot;Stones&quot; &quot;Beatles&quot; &quot;Beatles&quot; str(band_instruments) ## tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## $ name : chr [1:3] &quot;John&quot; &quot;Paul&quot; &quot;Keith&quot; ## $ plays: chr [1:3] &quot;guitar&quot; &quot;bass&quot; &quot;guitar&quot; #vamos juntar os dois conjuntos com um join band_members %&gt;% inner_join(band_instruments) ## # A tibble: 2 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass #o dplyr &quot;adivinhou&quot; a coluna chave pelo nome Repare que, nesse caso, a chave é a coluna name. Repare também que os dois conjuntos têm três registros. Então, por que o resultado final só tem dois registros? A resposta é simples: porque o comportamento do join é justamente retornar apenas as linhas em que as chaves coincidiram (efeito de filtro). Vamos fazer o mesmo experimento com band_intruments2: band_instruments2 ## # A tibble: 3 x 2 ## artist plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar str(band_instruments2) #o nome da coluna é diferente ## tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## $ artist: chr [1:3] &quot;John&quot; &quot;Paul&quot; &quot;Keith&quot; ## $ plays : chr [1:3] &quot;guitar&quot; &quot;bass&quot; &quot;guitar&quot; band_members %&gt;% inner_join(band_instruments2, by = c(&#39;name&#39; = &#39;artist&#39;)) ## # A tibble: 2 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass Repare que, dessa vez, tivemos que especificar qual a coluna chave para que o join aconteça. Mais um exemplo: empregados &lt;- read_csv(&#39;dados/Employees.csv&#39;) departamentos &lt;- read_csv(&#39;dados/Departments.csv&#39;) str(empregados) ## tibble [6 × 4] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ Employee : num [1:6] 1 2 3 4 5 6 ## $ EmployeeName: chr [1:6] &quot;Alice&quot; &quot;Bob&quot; &quot;Carla&quot; &quot;Daniel&quot; ... ## $ Department : num [1:6] 11 11 12 12 13 21 ## $ Salary : num [1:6] 800 600 900 1000 800 700 ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. Employee = col_double(), ## .. EmployeeName = col_character(), ## .. Department = col_double(), ## .. Salary = col_double() ## .. ) str(departamentos) ## tibble [4 × 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ Department : num [1:4] 11 12 13 14 ## $ DepartmentName: chr [1:4] &quot;Production&quot; &quot;Sales&quot; &quot;Marketing&quot; &quot;Research&quot; ## $ Manager : num [1:4] 1 4 5 NA ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. Department = col_double(), ## .. DepartmentName = col_character(), ## .. Manager = col_double() ## .. ) empregados ## # A tibble: 6 x 4 ## Employee EmployeeName Department Salary ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Alice 11 800 ## 2 2 Bob 11 600 ## 3 3 Carla 12 900 ## 4 4 Daniel 12 1000 ## 5 5 Evelyn 13 800 ## 6 6 Ferdinand 21 700 departamentos ## # A tibble: 4 x 3 ## Department DepartmentName Manager ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 11 Production 1 ## 2 12 Sales 4 ## 3 13 Marketing 5 ## 4 14 Research NA final &lt;- empregados %&gt;% inner_join(departamentos, by = c(&#39;Employee&#39; = &#39;Manager&#39;)) final ## # A tibble: 3 x 6 ## Employee EmployeeName Department.x Salary Department.y DepartmentName ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Alice 11 800 11 Production ## 2 4 Daniel 12 1000 12 Sales ## 3 5 Evelyn 13 800 13 Marketing Novamente tivemos o mesmo efeito, listamos apenas os empregados que são gerentes de departamento. Acontece que existem situações em que esse descarte de registro do inner join não é interessante. Nesses casos usamos outros tipos de join: os Outer Joins. Existem três tipos básicos de outer join: left outer join (ou só left join), right outer join (ou só right join) e full outer join (ou apenas full join). 6.2.2 Left Outer Join Chama-se LEFT outer join pois todos os registros do “conjunto à esquerda” estarão presentes no resultado final, além dos registros à direita que coincidirem na chave. Podemos usar no caso a seguir: band_members %&gt;% left_join(band_instruments2, by = c(&#39;name&#39; = &#39;artist&#39;)) ## # A tibble: 3 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass band_instruments2 ## # A tibble: 3 x 2 ## artist plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar Reparem no efeito: mesmo Mick não tendo referência no conjunto de dados “à direita” (band_instruments2), ele apareceu no registro final com NA, no campo que diz respeito ao conjunto à direita. Da mesma forma, Keith não está presente no conjunto final, pois não tem referência no conjunto à esquerda. Figura 6.4: Cruzamento de tabelas Repare que a “posição” das tabelas faz diferença. No caso da nossa manipulação de exmeplo, aplicamos o left join pois a tabela que queríamos preservar estava “à esquerda” na manipulação. final2 &lt;- empregados %&gt;% left_join(departamentos, by = c(&#39;Employee&#39; = &#39;Manager&#39;)) final2 ## # A tibble: 6 x 6 ## Employee EmployeeName Department.x Salary Department.y DepartmentName ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Alice 11 800 11 Production ## 2 2 Bob 11 600 NA &lt;NA&gt; ## 3 3 Carla 12 900 NA &lt;NA&gt; ## 4 4 Daniel 12 1000 12 Sales ## 5 5 Evelyn 13 800 13 Marketing ## 6 6 Ferdinand 21 700 NA &lt;NA&gt; 6.2.3 Right Outer Join O princípio é EXATAMENTE o mesmo do left join. A única diferença é a permanência dos registros do conjunto à direita. Podemos chegar ao mesmo resultado anterior apenas mudando os data frames de posição na manipulação. final3 &lt;- departamentos %&gt;% right_join(empregados, by = c(&#39;Manager&#39;=&#39;Employee&#39;)) final3 ## # A tibble: 6 x 6 ## Department.x DepartmentName Manager EmployeeName Department.y Salary ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 Production 1 Alice 11 800 ## 2 NA &lt;NA&gt; 2 Bob 11 600 ## 3 NA &lt;NA&gt; 3 Carla 12 900 ## 4 12 Sales 4 Daniel 12 1000 ## 5 13 Marketing 5 Evelyn 13 800 ## 6 NA &lt;NA&gt; 6 Ferdinand 21 700 final2 ## # A tibble: 6 x 6 ## Employee EmployeeName Department.x Salary Department.y DepartmentName ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Alice 11 800 11 Production ## 2 2 Bob 11 600 NA &lt;NA&gt; ## 3 3 Carla 12 900 NA &lt;NA&gt; ## 4 4 Daniel 12 1000 12 Sales ## 5 5 Evelyn 13 800 13 Marketing ## 6 6 Ferdinand 21 700 NA &lt;NA&gt; A escolha entre right join e left join depende completamente da ordem em que você escolher realizar as operações. Via de regra, um pode ser substituído pelo outro, desde que a posição dos data frames se ajuste na sequência das manipulações. 6.2.4 Full Outer Join Existem, ainda, as situações em que é necessário preservar todos os registros de ambos os conjuntos de dados. O full join tem essa característica. Nenhum dos conjuntos de dados perderá registros no resultado final, isto é, quando as chaves forem iguais, todos os campos estarão preenchidos. Quando não houver ocorrência das chaves em ambos os lados, será informado NA em qualquer um deles. band_members %&gt;% full_join(band_instruments2, by = c(&#39;name&#39; = &#39;artist&#39;)) ## # A tibble: 4 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass ## 4 Keith &lt;NA&gt; guitar Reparem que, dessa vez, não perdemos nenhum registro, de nenhum conjunto de dados, apenas teremos NA quando a ocorrência da chave não acontecer em alguns dos conjuntos. O full join funciona da seguinte forma: Figura 6.5: Cruzamento de tabelas final4 &lt;- departamentos %&gt;% full_join(empregados, by = c(&#39;Manager&#39;=&#39;Employee&#39;)) final4 ## # A tibble: 7 x 6 ## Department.x DepartmentName Manager EmployeeName Department.y Salary ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 Production 1 Alice 11 800 ## 2 12 Sales 4 Daniel 12 1000 ## 3 13 Marketing 5 Evelyn 13 800 ## 4 14 Research NA &lt;NA&gt; NA NA ## 5 NA &lt;NA&gt; 2 Bob 11 600 ## 6 NA &lt;NA&gt; 3 Carla 12 900 ## 7 NA &lt;NA&gt; 6 Ferdinand 21 700 Do resultado desse full join, por exemplo, podemos concluir que não tem nenhum Manager no departamento Resarch, da mesma forma, os empregados Bob, Carla e Ferdinand não são managers de departamento nenhum. 6.3 Exercícios Utilizando as bases de dados do pacote nycflights13, encontre a tabela abaixo que mostra quais aeroportos (origem e destino) tiveram mais voos. Será necessário utilizar o dataframe flights e airports. Dica: primeiro descubra as chaves. ## # A tibble: 217 x 3 ## # Groups: Origem [3] ## Origem Destino qtd ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 John F Kennedy Intl Los Angeles Intl 11262 ## 2 La Guardia Hartsfield Jackson Atlanta Intl 10263 ## 3 La Guardia Chicago Ohare Intl 8857 ## 4 John F Kennedy Intl San Francisco Intl 8204 ## 5 La Guardia Charlotte Douglas Intl 6168 ## 6 Newark Liberty Intl Chicago Ohare Intl 6100 ## 7 John F Kennedy Intl General Edward Lawrence Logan Intl 5898 ## 8 La Guardia Miami Intl 5781 ## 9 John F Kennedy Intl Orlando Intl 5464 ## 10 Newark Liberty Intl General Edward Lawrence Logan Intl 5327 ## # … with 207 more rows Utilizando os dataframes abaixo, chegue no resultado a seguir: participantes &lt;- data.frame( Nome = c(&#39;Carlos&#39;, &#39;Maurício&#39;, &#39;Ana Maria&#39;, &#39;Rebeca&#39;, &#39;Patrícia&#39;), Estado = c(&#39;Brasília&#39;, &#39;Minas Gerais&#39;, &#39;Goiás&#39;, &#39;São Paulo&#39;, &#39;Ceará&#39;), Idade = c(23, 24, 22, 29, 28) ) aprovados &lt;- data.frame( Nome = c(&#39;Carlos&#39;, &#39;Patrícia&#39;), Pontuacao = c(61, 62) ) eliminados &lt;- data.frame( Nome = c(&#39;Maurício&#39;, &#39;Ana Maria&#39;, &#39;Rebeca&#39;), Pontuacao = c(49, 48, 48) ) participantes ## Nome Estado Idade ## 1 Carlos Brasília 23 ## 2 Maurício Minas Gerais 24 ## 3 Ana Maria Goiás 22 ## 4 Rebeca São Paulo 29 ## 5 Patrícia Ceará 28 aprovados ## Nome Pontuacao ## 1 Carlos 61 ## 2 Patrícia 62 eliminados ## Nome Pontuacao ## 1 Maurício 49 ## 2 Ana Maria 48 ## 3 Rebeca 48 ## Warning: Column `Nome` joining factors with different levels, coercing to character vector ## Warning: Column `Nome` joining character vector and factor, coercing into character vector ## Nome Estado Idade Pontuacao Resultado ## 1 Carlos Brasília 23 61 Aprovado ## 2 Maurício Minas Gerais 24 49 Eliminado ## 3 Ana Maria Goiás 22 48 Eliminado ## 4 Rebeca São Paulo 29 48 Eliminado ## 5 Patrícia Ceará 28 62 Aprovado 6.4 Exercícios gerais do Tidyverse Para fazer as questões abaixo será necessário usar funções também dos capítulos anteriores. Carregue os pacotes tidyverse e janitor. Baixe o dataset de Super Heróis do Kaggle. Descompacte o arquivo e importe os dois arquivos para o R: salve o arquivo super_hero_powers.csv no objeto hero_powers e o arquivo heroes_information.csv no objeto hero_info. Use também na função read_csv o argumento na = c(&quot;&quot;, &quot;-&quot;, &quot;NA&quot;)) para que linhas com traço ou vazias sejam convertidas para NA. Observe as colunas presentes nos datasets usando a função glimpse. Use a função janitor::clean_names() para limpar os nomes das colunas. No caso de hero_info, remova a primeira coluna. Em hero_powers, converta todas as colunas com exceção da primeira para o tipo logical. Em hero_info, na coluna publisher, observe quantas editoras diferentes existem no dataset. Substitua Marvel Comics por Marvel, DC Comics por DC e todas as outras editoras pelo termo “Outros”. Dica: uma das possíveis maneiras de fazer isso é usando uma combinação das funções dplyr::mutate() e dplyr::case_when(). Em hero_info, quais raças (coluna race) são exclusivas de cada editora? Em hero_info, quais cores de olhos (coluna eye_color) são mais comuns para cada sexo (coluna gender)? Filtre o top 3 para cadda sexo. Em hero_powers, calcule o percentual de heróis que possui cada habilidade descrita nas colunas (Dica: é possível calcular a soma ou percentual de um vetor lógico, pois TRUE equivale a 1 e FALSE a 0). Use a função dplyr::summarise_if para aplicar a função em todas as colunas cuja classe é logical. Repita o item anterior, usando uma abordagem mais tidy: converta o formato do dataframe hero_powers para o formato long. Ele passará a possuir apenas 3 colunas: hero_names, poder e possui_poder usando a função tidyr::gather(). Então, calcule a média da coluna possui_poder agrupado pela coluna poder. Junte os dois dataframes em um só, chamado hero. A função a ser usada é inner_join(). Pense bem em qual será a ordem dos dataframes nos argumentos da função e qual será a chave usada no argumento by para unir as duas tabelas. No dataframe hero, calcule o percentual de herois de cada editora que são telepatas. No dataframe hero, selecione as colunas name, publisher, flight e weight, filtre os heróis que podem voar e retorne os 10 de maior peso. Salve o dataframe chamado hero no arquivo herois_completo.csv usando a função readr::write_csv(). "],
["dados-em-strings-texto.html", "7 Dados em strings (texto) 7.1 Pacote stringr 7.2 Regex 7.3 Exercícios", " 7 Dados em strings (texto) Neste capítulo, usaremos estes pacotes: library(stringr) library(literaturaBR) # remotes::install_github(&quot;sillasgonzaga/literaturaBR&quot;) Manipulação de texto também é algo importante em ciência de dados, pois nem tudo são números, existem variáveis categóricas que são baseadas em texto. Mais uma vez, esse tipo de manipulação depende do tipo de arquivo que você receber. a &lt;- &#39;texto 1&#39; b &lt;- &#39;texto 2&#39; c &lt;- &#39;texto 3&#39; paste(a, b, c) ## [1] &quot;texto 1 texto 2 texto 3&quot; O paste() é a função mais básica para manipulação de textos usando o R base. Ela concatena todas as variáveis textuais que você informar. Existe um parâmetro extra (sep) cujo valor padrão é espaço . paste(a, b, c, sep = &#39;-&#39;) ## [1] &quot;texto 1-texto 2-texto 3&quot; paste(a, b, c, sep = &#39;;&#39;) ## [1] &quot;texto 1;texto 2;texto 3&quot; paste(a, b, c, sep = &#39;---%---&#39;) ## [1] &quot;texto 1---%---texto 2---%---texto 3&quot; 7.1 Pacote stringr Texto no R é sempre do tipo character. No universo da computação, também se referem a texto como string. E é daí que vem o nome desse pacote, também criado por Hadley Wickham. Por acaso, este pacote não está incluído no tidyverse. library(stringr) ?stringr Referências: Site do pacote stringr 7.1.1 Extrair parte de uma string Começaremos pela função str_sub(), que extrai apenas parte de um texto. cnae.texto &lt;- c(&#39;10 Fabricação de produtos alimentícios&#39;, &#39;11 Fabricação de bebidas&#39;, &#39;12 Fabricação de produtos do fumo&#39;, &#39;13 Fabricação de produtos têxteis&#39;, &#39;14 Confecção de artigos do vestuário e acessórios&#39;, &#39;15 Preparação de couros e fabricação de artefatos de couro, artigos para viagem e calçados&#39;, &#39;16 Fabricação de produtos de madeira&#39;, &#39;17 Fabricação de celulose, papel e produtos de papel&#39;) cnae &lt;- str_sub(cnae.texto, 0, 2) texto &lt;- str_sub(cnae.texto, 4) cnae ## [1] &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; texto ## [1] &quot;Fabricação de produtos alimentícios&quot; ## [2] &quot;Fabricação de bebidas&quot; ## [3] &quot;Fabricação de produtos do fumo&quot; ## [4] &quot;Fabricação de produtos têxteis&quot; ## [5] &quot;Confecção de artigos do vestuário e acessórios&quot; ## [6] &quot;Preparação de couros e fabricação de artefatos de couro, artigos para viagem e calçados&quot; ## [7] &quot;Fabricação de produtos de madeira&quot; ## [8] &quot;Fabricação de celulose, papel e produtos de papel&quot; Referências: Documentação da função str_sub() 7.1.2 Substituir caracteres em um string Temos também a função str_replace() e str_replace_all(), que substituem determinados caracteres por outros. Tal como no exemplo a seguir: telefones &lt;- c(&#39;9931-9572&#39;, &#39;8591-5772&#39;, &#39;8562-1923&#39;) str_replace(telefones, &#39;-&#39;, &#39;&#39;) ## [1] &quot;99319572&quot; &quot;85915772&quot; &quot;85621923&quot; cnpj &lt;- c(&#39;19.702.231/9999-98&#39;, &#39;19.498.482/9999-05&#39;, &#39;19.499.583/9999-50&#39;, &#39;19.500.999/9999-46&#39;, &#39;19.501.139/9999-90&#39;) str_replace_all(cnpj, &#39;\\\\.|/|-&#39;, &#39;&#39;) ## [1] &quot;19702231999998&quot; &quot;19498482999905&quot; &quot;19499583999950&quot; &quot;19500999999946&quot; &quot;19501139999990&quot; O que são esses símbolos no segundo exemplo? São símbolos especiais utilizados em funções textuais para reconhecimento de padrão. Esses símbolos são conhecidos como Expressões Regulares ou o famoso Regex, que veremos logo a seguir. Uma função mais generalizada que str_replace() é a str_glue(): meu_nome &lt;- &quot;Fulano&quot; x &lt;- c(&quot;Prazer, sou o {meu_nome}&quot;) print(x) ## [1] &quot;Prazer, sou o {meu_nome}&quot; str_glue(x) ## Prazer, sou o Fulano Referências: Documentação da função str_replace() Documentação da função str_glue() 7.1.3 Buscar correspondências em um string A função str_count() pode ser usada para esse objetivo: str_count(telefones, &quot;7&quot;) ## [1] 1 2 0 Para saber se um string contem um determinado padrão, basta usar str_detect(): str_detect(telefones, &quot;7&quot;) ## [1] TRUE TRUE FALSE # isso é equivalente a str_count(telefones, &quot;7&quot;) &gt; 0 ## [1] TRUE TRUE FALSE Para correspondências mais específicas, como no início ou no final, pode-se usar as funções str_starts() e str_ends(): telefones ## [1] &quot;9931-9572&quot; &quot;8591-5772&quot; &quot;8562-1923&quot; str_starts(telefones, &quot;9&quot;) ## [1] TRUE FALSE FALSE str_ends(telefones, &quot;0&quot;) ## [1] FALSE FALSE FALSE Referências: Documentação da função str_count() Documentação da função str_detect() 7.1.4 Complementar uma string Isso é essencialmente útil para transformar números em string sem perder a ordem alfabética. str_pad() adicionar um determinado character no início (ou no final, isso pode ser especificado pelo usuário) até que um string atinja uma determinada quantidade de caracteres. Por exemplo, sabe-se que um CPF, contando apenas os algarismos, contem 11 caracteres. Contudo, o que fazer quando você recebe um dado numérico, sem zeros a esquerda? Veja o exemplo abaixo: cpfs &lt;- c(1234, 01833827570, 45614814570, 4, 4000001111) Basta usar a função str_pad() para complementar a string acrescentando zeros a esquerda até cada string conter 11 caracteres: str_pad(cpfs, width = 11, pad = &quot;0&quot;) ## [1] &quot;00000001234&quot; &quot;01833827570&quot; &quot;45614814570&quot; &quot;00000000004&quot; &quot;04000001111&quot; Veja que o terceiro elemento do vetor, que já continha 11 caracteres, não foi alterado. Referências: Documentação da função str_pad() 7.1.5 Remover espaços em branco desnecessários Quando se lida com texto, é comum recebermos dados com excesso de espaço em branco, como nestes exemplos: x &lt;- c(&quot; inicio&quot;, &quot;final &quot;, &quot; ambos &quot;, &quot; no meio &quot;) x ## [1] &quot; inicio&quot; &quot;final &quot; &quot; ambos &quot; &quot; no meio &quot; # conferindo o tamanho dos strings str_length(x) ## [1] 12 11 17 25 Para isso, existe a função str_trim(), que remove espaços em branco seguidos no início e no final do string: x2 &lt;-str_trim(x) x2 ## [1] &quot;inicio&quot; &quot;final&quot; &quot;ambos&quot; &quot;no meio&quot; # conferindo o tamanho do vetor limp str_length(x2) ## [1] 6 5 5 13 A função não limpou os espaços em branco seguidos no último elemento. Para isso, você pode usar uma função mais generalizada, chamada str_squish(): x2b &lt;- str_squish(x) x2b ## [1] &quot;inicio&quot; &quot;final&quot; &quot;ambos&quot; &quot;no meio&quot; str_length(x2b) ## [1] 6 5 5 7 7.2 Regex Trata-se de um assunto bastante complexo e avançado. Não é fácil dominar regex e provavelmente você vai precisar sempre consultar e experimentar a montagem dos padrões de regex. Infelizmente não é possível aprender regex rápido e de um jeito fácil, só existe o jeito difícil: errando muito, com muita prática e experiências reais. A seguir, uma lista dos principais mecanismos de regex: regex correspondência ^ começa do string (ou uma negação) . qualquer caractere $ fim da linha [maça] procura os caracteres m, a, ç maça maça [0-9] números [A-Z] qualquer letra maiúscula \\\\w uma palavra \\\\W não é palavra (pontuação, espaço etc.) \\\\s um espaço (tab, newline, space) Vamos então aplicar as regex acima em um conjunto de strings: textos &lt;- c(&quot;Fulano&quot;, &quot;fulano&quot;, &quot;abcdeF&quot;, &quot;01584&quot;, &quot;abc456&quot;, &quot;123def&quot;, &quot;OI&quot;, &quot;meuemail@gmail.com&quot;, &quot;www.google.com&quot;, &quot;Meu nome é Fulano&quot;) # detectar strings que contem F maiusculo str_detect(textos, &quot;F&quot;) ## [1] TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE # detectar strings que começam com F maiúsculo str_detect(textos, &quot;^F&quot;) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE # detectar strings que começam com F, independente se maiúsculo ou minúsculo str_detect(textos, regex(&quot;^F&quot;, ignore_case = TRUE)) ## [1] TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE str_subset() é uma generalização de str_detect() que filtra os elementos em que str_detect() retorna TRUE: # filtrar strings que terminam com o str_subset(textos, &quot;o$&quot;) ## [1] &quot;Fulano&quot; &quot;fulano&quot; &quot;Meu nome é Fulano&quot; # strings que contem um algarismo str_subset(textos, &quot;\\\\d&quot;) ## [1] &quot;01584&quot; &quot;abc456&quot; &quot;123def&quot; str_subset(textos, &quot;[0-9]&quot;) ## [1] &quot;01584&quot; &quot;abc456&quot; &quot;123def&quot; # strings que terminam com um algarismo str_subset(textos, &quot;\\\\d$&quot;) ## [1] &quot;01584&quot; &quot;abc456&quot; # strings que nao contem algarismo str_subset(textos, &quot;\\\\d&quot;, negate = TRUE) ## [1] &quot;Fulano&quot; &quot;fulano&quot; &quot;abcdeF&quot; &quot;OI&quot; &quot;meuemail@gmail.com&quot; &quot;www.google.com&quot; ## [7] &quot;Meu nome é Fulano&quot; # strings que contem um ponto str_subset(textos, &quot;\\\\.&quot;) ## [1] &quot;meuemail@gmail.com&quot; &quot;www.google.com&quot; # strings que contem um espaço str_subset(textos, &quot;\\\\s&quot;) ## [1] &quot;Meu nome é Fulano&quot; A seguir, alguns bons sites para aprender mais sobre regex. É um assunto interessante e bastante utilizado para tratamento textual. http://turing.com.br/material/regex/introducao.html https://regexone.com/ 7.3 Exercícios Utilizando o dataframe abaixo, obtenha o resultado a seguir: Dica: separate(), str_replace_all(), str_trim(), str_sub() cadastros &lt;- data.frame( email = c(&#39;joaodasilva@gmail.com&#39;, &#39;rafael@hotmail.com&#39;, &#39;maria@uol.com.br&#39;, &#39;juliana.morais@outlook.com&#39;), telefone = c(&#39;(61)99831-9482&#39;, &#39;32 8976 2913&#39;, &#39;62-9661-1234&#39;, &#39;15-40192.5812&#39;) ) cadastros ## email telefone ## 1 joaodasilva@gmail.com (61)99831-9482 ## 2 rafael@hotmail.com 32 8976 2913 ## 3 maria@uol.com.br 62-9661-1234 ## 4 juliana.morais@outlook.com 15-40192.5812 ## login dominio telefone dd ## 1 joaodasilva gmail 99831-9482 61 ## 2 rafael hotmail 8976-2913 32 ## 3 maria uol 9661-1234 62 ## 4 juliana.morais outlook 40192-5812 15 Baixe o pacote literaturaBR. Como ele não está no CRAN, é necessário usar outra função: remotes::install_github(&quot;sillasgonzaga/literaturaBR&quot;) Importe o dataframe com os livros: library(literaturaBR) df_livros &lt;- literaturaBR::load_all_books() head(df_livros) ## book_name chapter_name url paragraph_number ## alienista.1 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 1 ## alienista.2 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 2 ## alienista.3 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 3 ## alienista.4 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 4 ## alienista.5 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 5 ## alienista.6 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 6 ## text ## alienista.1 As crônicas da vila de Itaguaí dizem que em tempos remotos vivera ali um certo médico, o Dr. Simão Bacamarte, filho da nobreza da terra e o maior dos médicos do Brasil, de Portugal e das Espanhas. Estudara em Coimbra e Pádua. Aos trinta e quatro anos regressou ao Brasil, não podendo el-rei alcançar dele que ficasse em Coimbra, regendo a universidade, ou em Lisboa, expedindo os negócios da monarquia. ## alienista.2 —A ciência, disse ele a Sua Majestade, é o meu emprego único; Itaguaí é o meu universo. ## alienista.3 Dito isso, meteu-se em Itaguaí, e entregou-se de corpo e alma ao estudo da ciência, alternando as curas com as leituras, e demonstrando os teoremas com cataplasmas. Aos quarenta anos casou com D. Evarista da Costa e Mascarenhas, senhora de vinte e cinco anos, viúva de um juiz de fora, e não bonita nem simpática. Um dos tios dele, caçador de pacas perante o Eterno, e não menos franco, admirou-se de semelhante escolha e disse-lho. Simão Bacamarte explicou-lhe que D. Evarista reunia condições fisiológicas e anatômicas de primeira ordem, digeria com facilidade, dormia regularmente, tinha bom pulso e excelente vista; estava assim apta para dar-lhe filhos robustos, sãos e inteligentes. Se além dessas prendas,—únicas dignas da preocupação de um sábio, —D. Evarista era mal composta de feições, longe de lastimá-lo, agradecia-o a Deus, porquanto não corria o risco de preterir os interesses da ciência na contemplação exclusiva, miúda e vulgar da consorte. ## alienista.4 D. Evarista mentiu às esperanças do Dr. Bacamarte, não lhe deu filhos robustos nem mofinos. A índole natural da ciência é a longanimidade; o nosso médico esperou três anos, depois quatro, depois cinco. Ao cabo desse tempo fez um estudo profundo da matéria, releu todos os escritores árabes e outros, que trouxera para Itaguaí, enviou consultas às universidades italianas e alemãs, e acabou por aconselhar à mulher um regímen alimentício especial. A ilustre dama, nutrida exclusivamente com a bela carne de porco de Itaguaí, não atendeu às admoestações do esposo; e à sua resistência,—explicável, mas inqualificável,— devemos a total extinção da dinastia dos Bacamartes. ## alienista.5 Mas a ciência tem o inefável dom de curar todas as mágoas; o nosso médico mergulhou inteiramente no estudo e na prática da medicina. Foi então que um dos recantos desta lhe chamou especialmente a atenção,—o recanto psíquico, o exame de patologia cerebral. Não havia na colônia, e ainda no reino, uma só autoridade em semelhante matéria, mal explorada, ou quase inexplorada. Simão Bacamarte compreendeu que a ciência lusitana, e particularmente a brasileira, podia cobrir-se de &quot;louros imarcescíveis&quot;, — expressão usada por ele mesmo, mas em um arroubo de intimidade doméstica; exteriormente era modesto, segundo convém aos sabedores. ## alienista.6 —A saúde da alma, bradou ele, é a ocupação mais digna do médico. Quebre cada linha da coluna text em varias, tendo uma palavra por linha, usando separate_rows(), e filtre as linhas da nova coluna que contem apenas letras. Salve em um novo dataframe chamado df_livros_sep. Calcule o numero de palavras distintas em proporção à quantidade total de palavras por livro Calcule a proporção de palavras que contem a letra a por livro. "],
["trabalhando-com-datas.html", "8 Trabalhando com datas 8.1 Gerar um vetor sequencial de datas 8.2 ‘Parsear’ datas e horários 8.3 Extrair componentes de uma data 8.4 Operações matemáticas com datas", " 8 Trabalhando com datas Datas são um caso a parte no R. Existe uma própria classe para objetos desse tipo, chamada Date, com D maiúsculo. O R lida com datas no formato AAAA-MM-DD (Ano, Mês e Dia). Abaixo, definimos um vetor com datas x &lt;- c(&quot;2014-07-15&quot;, &quot;2018/03/20&quot;, &quot;2019-12-31&quot;, &quot;20170511&quot;) as.Date(x) ## [1] &quot;2014-07-15&quot; NA &quot;2019-12-31&quot; NA class(as.Date(x)) ## [1] &quot;Date&quot; Perceba que o R nativamente não aceita qualquer separador entre o ano, o mês e o dia, apenas o traço. O pacote lubridate, que faz parte da família tidyverse, possui uma versão mais generalizável para isso: library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following object is masked from &#39;package:base&#39;: ## ## date lubridate::as_date(x) ## [1] &quot;2014-07-15&quot; &quot;2018-03-20&quot; &quot;2019-12-31&quot; &quot;2017-05-11&quot; A propósito, dominar o pacote lubridate, que possui funções muito simples de usar, é a única coisa necessária para saber lidar com datas no R. Por isso, este capítulo se dedica a mostrar as principais funções do pacote. 8.1 Gerar um vetor sequencial de datas Essa tarefa é feita usando uma função nativa do R chamada seq.Date(), que possui quatro argumentos principais, sendo que três deles precisam ser especificados. args(seq.Date) ## function (from, to, by, length.out = NULL, along.with = NULL, ## ...) ## NULL # gerar vetor de datas separadas por mes seq.Date(from = as_date(&quot;2020-01-01&quot;), to = as_date(&quot;2020-12-01&quot;), by = &quot;1 month&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-02-01&quot; &quot;2020-03-01&quot; &quot;2020-04-01&quot; &quot;2020-05-01&quot; &quot;2020-06-01&quot; &quot;2020-07-01&quot; &quot;2020-08-01&quot; &quot;2020-09-01&quot; ## [10] &quot;2020-10-01&quot; &quot;2020-11-01&quot; &quot;2020-12-01&quot; # gerar vetor de datas separadas por dia seq.Date(from = as_date(&quot;2020-01-01&quot;), to = as_date(&quot;2020-01-20&quot;), by = &quot;1 day&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-01-02&quot; &quot;2020-01-03&quot; &quot;2020-01-04&quot; &quot;2020-01-05&quot; &quot;2020-01-06&quot; &quot;2020-01-07&quot; &quot;2020-01-08&quot; &quot;2020-01-09&quot; ## [10] &quot;2020-01-10&quot; &quot;2020-01-11&quot; &quot;2020-01-12&quot; &quot;2020-01-13&quot; &quot;2020-01-14&quot; &quot;2020-01-15&quot; &quot;2020-01-16&quot; &quot;2020-01-17&quot; &quot;2020-01-18&quot; ## [19] &quot;2020-01-19&quot; &quot;2020-01-20&quot; # gerar vetor de datas separadas por 3 dias seq.Date(from = as_date(&quot;2020-01-01&quot;), to = as_date(&quot;2020-01-20&quot;), by = &quot;3 day&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-01-04&quot; &quot;2020-01-07&quot; &quot;2020-01-10&quot; &quot;2020-01-13&quot; &quot;2020-01-16&quot; &quot;2020-01-19&quot; # gerar um vetor de 7 semanas separados por 1 semana seq.Date(from = as_date(&quot;2020-01-01&quot;), length.out = 7, by = &quot;1 week&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-01-08&quot; &quot;2020-01-15&quot; &quot;2020-01-22&quot; &quot;2020-01-29&quot; &quot;2020-02-05&quot; &quot;2020-02-12&quot; 8.2 ‘Parsear’ datas e horários Para fazer o R converter (ou parsear na linguagem de programação) um string em data, basta usar as funções correspondentes do lubridate. Por exemplo, no vetor de exemplo x, definido acima, as datas já estavam definidas no formato correto: AAAA-MM-DD. Aqui no Brasil usamos outro formato: DD/MM/AAAA. O lubridate possui uma função pronta para essa situação: # observer como usamos diferentes separadores datas_brasil &lt;- c(&quot;01/12/2019&quot;, &quot;20/11/2018&quot;, &quot;30011990&quot;, &quot;17-03-2000&quot;) # parseando o vetor acima para Data dmy(datas_brasil) ## [1] &quot;2019-12-01&quot; &quot;2018-11-20&quot; &quot;1990-01-30&quot; &quot;2000-03-17&quot; Caso o vetor também contenha dados de horário, basta incluir o sufixo referente a hora, minuto e segundo: dmy_hms(&quot;30-09-2019 14:51:39&quot;) ## [1] &quot;2019-09-30 14:51:39 UTC&quot; # sem o segundo dmy_hm(&quot;30-09-2019 14:15&quot;) ## [1] &quot;2019-09-30 14:15:00 UTC&quot; # apenas a hora dmy_h(&quot;30-09-2019 15&quot;) ## [1] &quot;2019-09-30 15:00:00 UTC&quot; 8.3 Extrair componentes de uma data É possível extrair qualquer tipo de componente de uma data ou de um vetor de datas com o lubridate. Veja alguns exemplos: datas_brasil &lt;- dmy_hms(c(&quot;01/12/2019 13:51:15&quot;, &quot;20/11/2018 00:00:00&quot;, &quot;30011990 080000&quot;, &quot;17-03-2000 203000&quot;)) datas_brasil ## [1] &quot;2019-12-01 13:51:15 UTC&quot; &quot;2018-11-20 00:00:00 UTC&quot; &quot;1990-01-30 08:00:00 UTC&quot; &quot;2000-03-17 20:30:00 UTC&quot; # extrair componentes da data: # ano year(datas_brasil) ## [1] 2019 2018 1990 2000 # mes month(datas_brasil) ## [1] 12 11 1 3 # dia day(datas_brasil) ## [1] 1 20 30 17 # semana do ano week(datas_brasil) ## [1] 48 47 5 11 # dia da semana wday(datas_brasil, label = TRUE) ## [1] dom ter ter sex ## Levels: dom &lt; seg &lt; ter &lt; qua &lt; qui &lt; sex &lt; sáb # trimestre quarter(datas_brasil) ## [1] 4 4 1 1 # hora hour(datas_brasil) ## [1] 13 0 8 20 8.4 Operações matemáticas com datas Geralmente se está interessado em fazer três tipos de operações matemáticas com datas: Adicionar uma quantidade N de dias/meses/anos/etc em uma data: # adicionar 1 semana nas datas datas_brasil + ddays(7) ## [1] &quot;2019-12-08 13:51:15 UTC&quot; &quot;2018-11-27 00:00:00 UTC&quot; &quot;1990-02-06 08:00:00 UTC&quot; &quot;2000-03-24 20:30:00 UTC&quot; # adicionar 3 meses datas_brasil + ddays(90) ## [1] &quot;2020-02-29 13:51:15 UTC&quot; &quot;2019-02-18 00:00:00 UTC&quot; &quot;1990-04-30 08:00:00 UTC&quot; &quot;2000-06-15 20:30:00 UTC&quot; # adicionar 1 ano datas_brasil + dyears(1) ## [1] &quot;2020-11-30 13:51:15 UTC&quot; &quot;2019-11-20 00:00:00 UTC&quot; &quot;1991-01-30 08:00:00 UTC&quot; &quot;2001-03-17 20:30:00 UTC&quot; Calcular a diferença de tempo entre duas datas: No R, subtrair datas segue a mesma sintaxe de subtrair números: data1 &lt;- dmy_hms(&quot;01/09/1993 20:00:00&quot;) data2 &lt;- dmy_hms(&quot;24-06-2018 17:00:00&quot;) dif &lt;- data2 - data1 dif ## Time difference of 9061.875 days Por padrão, o R retorna a diferença em dias, mas em um objeto de classe difftime. class(dif) ## [1] &quot;difftime&quot; Recomenda-se então converter o output para a classe numeric: as.numeric(dif) ## [1] 9061.875 Caso se deseje calcular essa diferença em outras unidades de tempo, como meses ou semanas, basta fazer a divisão correspondente: # conveter para semanas as.numeric(dif) / 7 ## [1] 1294.554 # converter para meses as.numeric(dif) / 30 ## [1] 302.0625 # converter para anos as.numeric(dif) / 365 ## [1] 24.82705 Arredondar datas: Para arredondar uma data, por exemplo, retornar o primeiro ou último dia da semana/mês/trimestre/etc de uma data de referência, usa-se as funções ceiling_date() (arredondar para cima) e floor_date() (para baixo): # retornar a primeira data da semana: floor_date(datas_brasil, &quot;week&quot;) ## [1] &quot;2019-12-01 UTC&quot; &quot;2018-11-18 UTC&quot; &quot;1990-01-28 UTC&quot; &quot;2000-03-12 UTC&quot; # retornar a ultima data do mês # por padrao, ceiling_date retorna a primeira data do próximo mês, # por isso é necessario subtrair o resultado por 1 ceiling_date(datas_brasil, &quot;month&quot;) - 1 ## [1] &quot;2019-12-31 23:59:59 UTC&quot; &quot;2018-11-30 23:59:59 UTC&quot; &quot;1990-01-31 23:59:59 UTC&quot; &quot;2000-03-31 23:59:59 UTC&quot; # arredondar usando a hora como referencia floor_date(datas_brasil, &quot;hour&quot;) ## [1] &quot;2019-12-01 13:00:00 UTC&quot; &quot;2018-11-20 00:00:00 UTC&quot; &quot;1990-01-30 08:00:00 UTC&quot; &quot;2000-03-17 20:00:00 UTC&quot; "],
["escrevendo-dados.html", "9 Escrevendo dados 9.1 Escrevendo csv 9.2 Rds 9.3 Escrevendo outros tipos de arquivos 9.4 Exercícios", " 9 Escrevendo dados Já na fase final da sua análise, pode ser que apareça a necessidade de gerar-se arquivos: gráficos, relatórios, planilhas, pdf, arquivos de dados etc. Da mesma forma que você consome dados e relatórios, talvez você precise produzir e divulgar dados e relatórios para outras pessoas analisarem, ou mesmo para publicação. 9.1 Escrevendo csv O formato mais básico e mais utilizado, mundialmente, para envio e recebimento de dados entre instituições é o csv. Escrever um arquivo de dados em csv é muito simples. Dentre as opções, recomenda-se usar as funções de escrever dados do pacote readr. A diferença as funções read_csv() ou write_csv() e read_csv2() e write_csv2() é que as primeiras usam vírgula como delimitador de colunas e ponto como separador de decimais, já as duas últimas usam ponto e vírgula e vírgula, respectivamente. data(iris) readr::write_csv(iris, &quot;iris.csv&quot;) readr::write_csv2(iris, &quot;iris2.csv&quot;) 9.2 Rds Objetos rds são arquivos próprios do R e servem para salvar em arquivo local qualquer tipo de estrutura de dados, mantendo sempre todas as propriedades do objeto original. Arquivos rds podem ser salvos com a função write_rds(), do pacote readr. Para importar um arquivo rds, basta usar readr::read_rds(). participantes &lt;- tibble( Nome = c(&#39;Carlos&#39;, &#39;Maurício&#39;, &#39;Ana Maria&#39;, &#39;Rebeca&#39;, &#39;Patrícia&#39;), Estado = c(&#39;Brasília&#39;, &#39;Minas Gerais&#39;, &#39;Goiás&#39;, &#39;São Paulo&#39;, &#39;Ceará&#39;), Idade = c(23, 24, 22, 29, 28) ) readr::write_rds(participantes, &quot;participantes.rds&quot;) # salvando um vetor meu_vetor &lt;- c(1, 3, 5) write_rds(meu_vetor, &quot;vetor.rds&quot;) 9.3 Escrevendo outros tipos de arquivos Outra forma bastante importante de escrever dados é em planilhas: o famoso Excel. Recomendamos o conhecimento do pacote openxlsx. É um pacote que lê e escreve arquivos Excel sem nenhuma dependência de Java, que pode acabar dando muita dor de cabeça para manter e normalmente consome bastante memória. Para Windows, o openxlsx precisa do Rtools: https://cran.r-project.org/bin/windows/Rtools/. Recomendamos a experiência com este pacote, pois com ele é possível a criação de planilhas bem acabadas, com cores e formatações complexas. Um outro pacote para escrever arquivos em Excel, mais simples que o openxlsx, é o writexl: writexl::write_xlsx(iris, &quot;iris.xlsx&quot;) Outra forma de escrita de dados é utilizando o RMarkdown, mas este formato merece um capítulo específico para detalhar seu uso. 9.4 Exercícios Escolha qualquer dataframe já trabalhado até agora e escreva-o em csv. "],
["obtendo-dados.html", "10 Obtendo dados 10.1 API 10.2 Web Scrapping", " 10 Obtendo dados A base da ciência de dados é, obviamente, o DADO. Portanto, é fundamental sempre ter boas fontes de dados. Se você der sorte, conseguirá dados estruturados para iniciar sua análise. Porém, eventualmente precisará recorrer a fontes de dados não estruturados ou semiestruturados. Muito provavelmente você algum dia precisará recorrer a uma Application Programming Interface (API) de dados, ou até mesmo precisará utilizar técnicas de Web Scrapping para obter dados diretamente em um próprio site. 10.1 API API é uma forma de comunicação de dados mais apropriada para as trocas de informações entre softwares. Normalmente APIs trocam dados em formato hierárquico. Os dois formatos hierárquicos mais comuns são Javascript Object Notation (JSON) e eXtensible Markup Language (XML). Para obter-se e utilizar-se dados de API em R recomendamos a utilização do pacote jsonlite. library(jsonlite) A seguir apresentaremos alguns exemplos de APIs e seu uso. Existem diversas APIs e formas de consumi-las, portanto não iremos exaurir nesse texto todas as possibilidades de uso de APIs. O principal aqui é entender-se APIs como uma fonte rica de dados que pode ser explorada em suas análises. No exemplo a seguir utilizamos a API do github (portal para repositórios) e veremos quais os repositórios do Hadley Wickham: hadley.rep &lt;- jsonlite::fromJSON(&quot;https://api.github.com/users/hadley/repos&quot;) dim(hadley.rep) ## [1] 30 73 head(hadley.rep[,c(&#39;name&#39;, &#39;description&#39;)], 15) ## name ## 1 15-state-of-the-union ## 2 15-student-papers ## 3 500lines ## 4 adv-r ## 5 appdirs ## 6 arrow ## 7 assertthat ## 8 babynames ## 9 beautiful-data ## 10 bench ## 11 bigvis ## 12 bigvis-infovis ## 13 BiocStickers ## 14 bizarro ## 15 Book-Twitter-for-R ## description ## 1 &lt;NA&gt; ## 2 Graphics &amp; computing student paper winners @ JSM 2015 ## 3 500 Lines or Less ## 4 Advanced R: a book ## 5 A small Python module for determining appropriate platform-specific dirs, e.g. a &quot;user data dir&quot;. ## 6 Apache Arrow is a cross-language development platform for in-memory data. It specifies a standardized language-independent columnar memory format for flat and hierarchical data, organized for efficient analytic operations on modern hardware. It also provides computational libraries and zero-copy streaming messaging and interprocess communication. Languages currently supported include C, C++, Java, JavaScript, Python, and Ruby. ## 7 User friendly assertions for R ## 8 An R package containing US baby names from the SSA ## 9 Book chapter for beautiful data ## 10 Bechmarking tools for R ## 11 Exploratory data analysis for large datasets (10-100 million observations) ## 12 Paper describing the bigvis package and framework submitted to Infovis 2013 ## 13 Stickers for some Bioconductor packages - feel free to contribute and/or modify. ## 14 Bizarro world ## 15 Guide to Twitter for R programmers Outro exemplo de API muito interessante é o portal de dados abertos da Câmara dos Deputados. Eles possuem diversas APIs para consultar os dados do processo legislativo. Veja o exemplo a seguir, que resgata as proposições utilizando API: proposicoes &lt;- jsonlite::fromJSON(&quot;https://dadosabertos.camara.leg.br/api/v2/proposicoes&quot;) head(proposicoes$dados %&gt;% select(siglaTipo, numero, ano, ementa)) ## siglaTipo numero ano ## 1 PL 2295 2000 ## 2 PL 6222 2002 ## 3 PL 6588 2006 ## 4 PL 7220 2006 ## 5 PL 478 2007 ## 6 REP 7 2007 ## ementa ## 1 Dispõe sobre a jornada de trabalho dos Enfermeiros, Técnicos e Auxiliares de Enfermagem. ## 2 Dispõe sobre a vigilância e o controle da qualidade da água para consumo humano e dá outras providências. ## 3 Altera o art. 41 da Lei nº 7.210, de 11 de julho de 1984 - Lei de Execução Penal, para prever a interceptação de correspondência de presos condenados ou provisórios para fins de investigação criminal ou de instrução processual penal. ## 4 Altera o art. 109 do Decreto-Lei nº 2.848, de 7 de dezembro de 1940, Código Penal, para aumentar os prazos prescricionais. ## 5 Dispõe sobre o Estatuto do Nascituro e dá outras providências. ## 6 Solicita a instauração de procedimento de fiscalização na Prefeitura Municipal da Caxias - MA. Hoje em dia, todas as redes sociais possuem APIs para consumir os dados dos usuários e postagens. Normalmente essas APIs pedem um cadastro anterior (apesar de gratuitas, em sua maior parte). O R possui diversos pacotes para consumir APIs interessantes: Quandl: pacote que fornece diversos dados econômicos de diversos países; Rfacebook: pacote que facilita o uso da API do facebook (requer cadastro prévio); twitterR: pacote que facilita o uso da API do twitter (requer cadastro prévio); ggmap: pacote que facilita o uso da API do google maps. Sempre procure por APIs para obter dados que possam enriquecer suas análises. 10.2 Web Scrapping Eventualmente você não terá dados estruturados de forma fácil e nem terá uma API com os dados que procura. Nesses casos pode ser que um próprio site da internet seja sua fonte de dados. Para isso utiliza-se técnicas chamadas de Web Scrapping. Sites da internet são construídos utilizando-se uma linguagem que é interpretada pelos browsers: HyperText Markup Language (HTML). Esta é uma linguagem que trabalha com tags de forma hierárquica. Nesse site você pode aprender um pouco mais sobre o que é HTML: http://www.w3schools.com/html/tryit.asp?filename=tryhtml_basic_document Existe um pacote em R que facilita muito o cosumo de dados em HTML: rvest, criado também por Hadley Wickham. O rvest mapeia os elementos HTML (tags) de uma página web e facilita a “navegação” do R por esses nós da árvore do HTML. O pacote funciona da seguinte forma: Um string que contem o link é usado como input da função read_html(). A partir daí as funções do pacote rvest podem ser usadas para extrair dados da página. html_table(), por exemplo, extrai dados tabulares da página. Algo que torna o Web Scraping muito complexo é que essa tarefa é muito dependente do código-fonte da página. Caso ela sofra mudanças, o código provavelmente não irá mais funcionar. Um exemplo é o que se vê neste post sobre Web Scraping do OLX, que não funciona mais. Devido a isso, este material opta por não entrar a fundo no assunto além de mostrar um exemplo superficial abaixo de scraping de uma tabela da Wikipedia: library(rvest) url &lt;- &quot;https://pt.wikipedia.org/wiki/Campeonato_Brasileiro_de_Futebol_de_2018_-_Série_A&quot; %&gt;% read_html() tb &lt;- html_table(url, fill = TRUE) tb &lt;- tb[[6]] tb %&gt;% as_tibble() %&gt;% mutate(SG = ifelse(str_detect(SG,&quot;\\\\+&quot;), readr::parse_number(SG), -1 * readr::parse_number(SG))) "],
["estruturas-complexas-de-dados.html", "11 Estruturas complexas de dados 11.1 Introdução a listas 11.2 Introdução ao pacote purrr 11.3 Ideia de projeto: Aplicando uma série de funções a uma lista de arquivos 11.4 Referências", " 11 Estruturas complexas de dados 11.1 Introdução a listas Nós já falamos sobre vetores, que são as principais estruturas unidimensionais de dados e que só aceitam elementos da mesma classe: a &lt;- c(1, 2, &quot;c&quot;, 4) class(a) ## [1] &quot;character&quot; O R também possui uma estrutura de dados que pode armazenar, literalmente, qualquer tipo de objeto: as listas, criadas com a função list(). No exemplo abaixo uma série de objetos de classes diferentes são armazenadas: data_frame &lt;- head(iris) elemento_unico_inteiro &lt;- 1 um_na &lt;- NA vetor_string &lt;- letters[1:5] modelo_regressao &lt;- lm(mpg ~ wt, data = mtcars) minha_lista &lt;- list(data_frame = data_frame, elemento_unico_inteiro = elemento_unico_inteiro, # este elemento abaixo não vai possuir um nome um_na, vetor_string = vetor_string, modelo_regressao = modelo_regressao) # Conferindo o output: minha_lista ## $data_frame ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## ## $elemento_unico_inteiro ## [1] 1 ## ## [[3]] ## [1] NA ## ## $vetor_string ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## ## $modelo_regressao ## ## Call: ## lm(formula = mpg ~ wt, data = mtcars) ## ## Coefficients: ## (Intercept) wt ## 37.285 -5.344 Pelo output já percebemos que a maneira como extraímos um elemento de um vetor é diferente da de uma lista. No primeiro, usamos um par de colchetes ([]), no segundo usamos dois pares ([[]]) ou também cifrão ($), que só funciona caso o elemento da lista possua um nome. minha_lista[[2]] ## [1] 1 minha_lista$vetor_string ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; # o comando abaixo retorna NULL pq &quot;um_na&quot; não é um nome de # nenhum elemento da lista minha_lista$um_na ## NULL Vetores podem ser transformandos em listas usando a função de coerção as.list(): as.list(vetor_string) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; ## ## [[3]] ## [1] &quot;c&quot; ## ## [[4]] ## [1] &quot;d&quot; ## ## [[5]] ## [1] &quot;e&quot; Inserir um nome em uma lista é simples com o uso da função names(), que pode alterar os nomes da lista inteira ou de apenas um elemento, como no exemplo abaixo: names(minha_lista)[3] &lt;- &quot;meu_na&quot; names(minha_lista) ## [1] &quot;data_frame&quot; &quot;elemento_unico_inteiro&quot; &quot;meu_na&quot; &quot;vetor_string&quot; &quot;modelo_regressao&quot; A função str() pode user usada para inspecionar a estrutura da lista: str(minha_lista) ## List of 5 ## $ data_frame :&#39;data.frame&#39;: 6 obs. of 5 variables: ## ..$ Sepal.Length: num [1:6] 5.1 4.9 4.7 4.6 5 5.4 ## ..$ Sepal.Width : num [1:6] 3.5 3 3.2 3.1 3.6 3.9 ## ..$ Petal.Length: num [1:6] 1.4 1.4 1.3 1.5 1.4 1.7 ## ..$ Petal.Width : num [1:6] 0.2 0.2 0.2 0.2 0.2 0.4 ## ..$ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 ## $ elemento_unico_inteiro: num 1 ## $ meu_na : logi NA ## $ vetor_string : chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ modelo_regressao :List of 12 ## ..$ coefficients : Named num [1:2] 37.29 -5.34 ## .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;wt&quot; ## ..$ residuals : Named num [1:32] -2.28 -0.92 -2.09 1.3 -0.2 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ... ## ..$ effects : Named num [1:32] -113.65 -29.116 -1.661 1.631 0.111 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:32] &quot;(Intercept)&quot; &quot;wt&quot; &quot;&quot; &quot;&quot; ... ## ..$ rank : int 2 ## ..$ fitted.values: Named num [1:32] 23.3 21.9 24.9 20.1 18.9 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ... ## ..$ assign : int [1:2] 0 1 ## ..$ qr :List of 5 ## .. ..$ qr : num [1:32, 1:2] -5.657 0.177 0.177 0.177 0.177 ... ## .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. ..$ : chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ... ## .. .. .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;wt&quot; ## .. .. ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1 ## .. ..$ qraux: num [1:2] 1.18 1.05 ## .. ..$ pivot: int [1:2] 1 2 ## .. ..$ tol : num 1e-07 ## .. ..$ rank : int 2 ## .. ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; ## ..$ df.residual : int 30 ## ..$ xlevels : Named list() ## ..$ call : language lm(formula = mpg ~ wt, data = mtcars) ## ..$ terms :Classes &#39;terms&#39;, &#39;formula&#39; language mpg ~ wt ## .. .. ..- attr(*, &quot;variables&quot;)= language list(mpg, wt) ## .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. ..$ : chr [1:2] &quot;mpg&quot; &quot;wt&quot; ## .. .. .. .. ..$ : chr &quot;wt&quot; ## .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;wt&quot; ## .. .. ..- attr(*, &quot;order&quot;)= int 1 ## .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. .. ..- attr(*, &quot;predvars&quot;)= language list(mpg, wt) ## .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;mpg&quot; &quot;wt&quot; ## ..$ model :&#39;data.frame&#39;: 32 obs. of 2 variables: ## .. ..$ mpg: num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## .. ..$ wt : num [1:32] 2.62 2.88 2.32 3.21 3.44 ... ## .. ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language mpg ~ wt ## .. .. .. ..- attr(*, &quot;variables&quot;)= language list(mpg, wt) ## .. .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. .. ..$ : chr [1:2] &quot;mpg&quot; &quot;wt&quot; ## .. .. .. .. .. ..$ : chr &quot;wt&quot; ## .. .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;wt&quot; ## .. .. .. ..- attr(*, &quot;order&quot;)= int 1 ## .. .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. .. .. ..- attr(*, &quot;predvars&quot;)= language list(mpg, wt) ## .. .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;mpg&quot; &quot;wt&quot; ## ..- attr(*, &quot;class&quot;)= chr &quot;lm&quot; A maneira mais produtiva de se usar listas em seus projetos é para automatizar a aplicação de uma determinada função (ou funções) para todos os elementos de uma lista. Suponha, por exemplo, que você precise importar dezenas de arquivos csv, fazer algumas limpezas e manipulações de dados, construir modelos de Machine Learning e depois salvar os resultados no computador. Seria muito tedioso fazer isso manualmente, mas é para esse tipo de operação que listas se tornam muito úteis. O pacote purrr possui uma série de comandos para aplicar funções a elementos de uma lista. O R base até possui as funções da família apply (apply(), tapply(), lapply(), etc), mas estas estão entrando em desuso devido à adoção do purrr. 11.2 Introdução ao pacote purrr 11.2.1 map() Nós já vimos que o R aplica uma função a cada elemento de um vetor de uma forma muito simples: meu_vetor &lt;- c(1, -3, 5, -10) # extrair o modulo de cada elemento do vetor acima abs(meu_vetor) ## [1] 1 3 5 10 No caso de listas, não é bem assim que funciona: minha_lista &lt;- list(1, 3, 5, 10) abs(minha_lista) ## Error in abs(minha_lista): non-numeric argument to mathematical function É necessário usar uma outra função para aplicar uma função a cada elemento da lista. É aqui que introduzimos a função map(), do pacote purrr. O primeiro argumento é a estrutura de dados sobre a qual se deseja iterar e o segundo é a função que será aplicada a cada elemento. O pacote purrr faz parte do tidyverse. library(tidyverse) library(purrr) map(minha_lista, abs) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 3 ## ## [[3]] ## [1] 5 ## ## [[4]] ## [1] 10 Veja a diferença no output: class(minha_lista) ## [1] &quot;list&quot; map(minha_lista, class) ## [[1]] ## [1] &quot;numeric&quot; ## ## [[2]] ## [1] &quot;numeric&quot; ## ## [[3]] ## [1] &quot;numeric&quot; ## ## [[4]] ## [1] &quot;numeric&quot; De maneira genérica, é assim que são usados os parâmetros de map(): map(.x, .f, ...) # ou map(VETOR_OU_LISTA, FUNCAO_PARA_APLICAR, ARGUMENTOS_OPCIONAIS) # que é equivalente a VETOR_OU_LISTA %&gt;% map(FUNCAO_PARA_APLICAR, ARGUMENTOS_OPCIONAIS) Existem três maneiras de especificar a função para usar no map(): Uma função existente # definir uma lista composta por vetores v &lt;- list(v1 = c(1, 3, 5), v2 = c(2, 4, 6), v3 = c(7, 8, 9)) # aplicar a raiz quadrada a todos os vetores map(v, sqrt) ## $v1 ## [1] 1.000000 1.732051 2.236068 ## ## $v2 ## [1] 1.414214 2.000000 2.449490 ## ## $v3 ## [1] 2.645751 2.828427 3.000000 # calcular a soma dos elementos de cada vetor map(v, sum) ## $v1 ## [1] 9 ## ## $v2 ## [1] 12 ## ## $v3 ## [1] 24 Uma função “anônima”, definida dentro da própria map(). Veja que, em function(x) abaixo, x é como se fosse uma representação genérica de cada elemento da lista v. Em inglês isso se chama placeholder. # elevar cada elemento de cada vetor ao quadrado map(v, function(x) x^2) ## $v1 ## [1] 1 9 25 ## ## $v2 ## [1] 4 16 36 ## ## $v3 ## [1] 49 64 81 # elevar a soma dos elementos do vetor ao quadrado map(v, function(x) sum(x)^2) ## $v1 ## [1] 81 ## ## $v2 ## [1] 144 ## ## $v3 ## [1] 576 Uma fórmula. Deve-se começar com o símbolo ~ para iniciar uma função e .x para se referir ao seu input, que corresponde a cada elemento da lista especificada no primeiro argumento de map(). Traduzindo os dois comandos anteriores para esta sintaxe, ficaria assim: map(v, ~ .x^2) ## $v1 ## [1] 1 9 25 ## ## $v2 ## [1] 4 16 36 ## ## $v3 ## [1] 49 64 81 map(v, ~ sum(.x)^2) ## $v1 ## [1] 81 ## ## $v2 ## [1] 144 ## ## $v3 ## [1] 576 11.2.2 Funções derivadas de map() A função map() retorna uma lista. Contudo, se você sabe que sua função deve retornar um resultado em que todos os elementos pertencem a uma mesma classe, é possível usar as funções derivadas de map, como map_chr() (character) e map_dbl() (numérico): map_chr(v, class) ## v1 v2 v3 ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; map_dbl(v, ~ sum(.x)^2) ## v1 v2 v3 ## 81 144 576 Dá até para garantir que o resultado de map() seja um dataframe com map_dfr() ou map_dfc(): map_dfc(v, function(x) x * 2) ## # A tibble: 3 x 3 ## v1 v2 v3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 4 14 ## 2 6 8 16 ## 3 10 12 18 É possível e simples encadear uma sequência de comandos map() com o pipe: v %&gt;% map(~ .x * 2) %&gt;% map_dbl(sum) ## v1 v2 v3 ## 18 24 48 11.3 Ideia de projeto: Aplicando uma série de funções a uma lista de arquivos Este dataset no Kaggle traz o consumo médio de energia elétrica por região nos Estados Unidos. A página disponibiliza 13 arquivos csv, um para cada região. Suponha que, para cada região, desejamos ler o arquivo, padronizar os nomes das duas colunas, acrescentar uma coluna identificando a região do arquivo, calcular o consumo médio por mês do ano e juntar os dataframes. Seria tortuoso fazer isso para cada arquivo manualmente, por isso nos valemos do pacote purrr para sistematizar esse processo. Baixe o dataset e salve em uma pasta chamada “dados”. Descompacte o arquivo zip e uma nova pasta será criada. # listar os arquivos contidos na pasta baixada arquivos &lt;- dir(&quot;dados/hourly-energy-consumption/&quot;, # listar apenas arquivos que contem o padrao abaixo pattern = &quot;_hourly.csv&quot;, full.names = TRUE) Para fins de demonstração, o código abaixo mostra como seria executar o processo descrito acima para apenas um dos arquivos: df1 &lt;-read_csv(arquivos[1]) head(df1) ## # A tibble: 6 x 2 ## Datetime AEP_MW ## &lt;dttm&gt; &lt;dbl&gt; ## 1 2004-12-31 01:00:00 13478 ## 2 2004-12-31 02:00:00 12865 ## 3 2004-12-31 03:00:00 12577 ## 4 2004-12-31 04:00:00 12517 ## 5 2004-12-31 05:00:00 12670 ## 6 2004-12-31 06:00:00 13038 Para extrair o nome do arquivo, note que o padrão é NOMEREGIAO_hourly. Por isso, podemos usar str_split() para “quebrar” o string em dois e pegar apenas o primeiro elemento. # basename() retorna apenas o nome do arquivo, sem o diretorio basename(arquivos[1]) ## [1] &quot;AEP_hourly.csv&quot; # str_split() quebra um string em mais de um baseado no separador especificado nome_regiao &lt;- str_split(basename(arquivos[1]), &quot;_&quot;)[[1]][1] df1_mes &lt;- df1 %&gt;% # mudar nome das colunas purrr::set_names(c(&quot;horario&quot;, &quot;consumo&quot;)) %&gt;% # criar uma coluna contendo o mes da data mutate(mes = lubridate::month(horario)) %&gt;% # criar uma coluna contendo o nome da regiao do arquivo mutate(regiao = nome_regiao) %&gt;% # agrupar os dados e calcular a media group_by(regiao, mes) %&gt;% summarise(consumo_medio = mean(consumo)) df1_mes ## # A tibble: 12 x 3 ## # Groups: regiao [1] ## regiao mes consumo_medio ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AEP 1 17431. ## 2 AEP 2 17023. ## 3 AEP 3 15377. ## 4 AEP 4 13824. ## 5 AEP 5 14006. ## 6 AEP 6 15630. ## 7 AEP 7 16350. ## 8 AEP 8 16425. ## 9 AEP 9 14657. ## 10 AEP 10 13939. ## 11 AEP 11 14930. ## 12 AEP 12 16446. A solução para aplicar o código acima para todos os arquivos csv diferentes de maneira elegante no R é o sistematizar, transformando-o em uma função: agregar_dados &lt;- function(arquivo_csv){ # str_split() quebra um string em mais de um baseado no separador especificado nome_regiao &lt;- str_split(basename(arquivo_csv), &quot;_&quot;)[[1]][1] # ler arquivo para um dataframe dframe &lt;- read_csv(arquivo_csv) # criar novo dataframe dframe_mes &lt;- dframe %&gt;% # mudar nome das colunas purrr::set_names(c(&quot;horario&quot;, &quot;consumo&quot;)) %&gt;% # criar uma coluna contendo o mes da data mutate(mes = lubridate::month(horario)) %&gt;% # criar uma coluna contendo o nome da regiao do arquivo mutate(regiao = nome_regiao) %&gt;% # agrupar os dados e calcular a media group_by(regiao, mes) %&gt;% summarise(consumo_medio = mean(consumo)) # retornar novo dataframe dframe_mes } Como sabemos que a função agregar_dados() deve retornar um dataframe, usamos map_dfr() para, além de gerar um dataframe por arquivo, juntá-los em um dataframe só: df_mes_geral &lt;- arquivos %&gt;% map_dfr(agregar_dados) head(df_mes_geral) ## # A tibble: 6 x 3 ## # Groups: regiao [1] ## regiao mes consumo_medio ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AEP 1 17431. ## 2 AEP 2 17023. ## 3 AEP 3 15377. ## 4 AEP 4 13824. ## 5 AEP 5 14006. ## 6 AEP 6 15630. 11.4 Referências Tutorial da Jenny Brian sobre purrr Tutorial completo do Caio Lente sobre purrr em português "],
["ggplot2.html", "12 Visualizações de dados (ggplot2) 12.1 Mapeamento Estético 12.2 Objetos geométricos 12.3 Escalas 12.4 Subplots (facet) 12.5 Temas 12.6 Legendas 12.7 Escolhendo o tipo de gráfico 12.8 Gráfico de Dispersão (geom_point()) 12.9 Gráficos de Bolhas 12.10 Gráficos de Barras 12.11 Gráficos de linhas 12.12 Histogramas e freqpoly 12.13 Boxplots, jitterplots e violinplots 12.14 Anotações 12.15 Cleveland Dot Plot 12.16 Textos/Rótulos 12.17 Plotando funções 12.18 Mapas: plotando polígonos 12.19 Salvando Gráficos 12.20 Extensões do ggplot2 12.21 Exercícios", " 12 Visualizações de dados (ggplot2) Pacotes deste capítulo: library(ggplot2) library(ISLR) library(RColorBrewer) library(ggthemes) library(hrbrthemes) ## NOTE: Either Arial Narrow or Roboto Condensed fonts are required to use these themes. ## Please use hrbrthemes::import_roboto_condensed() to install Roboto Condensed and ## if Arial Narrow is not on your system, please see https://bit.ly/arialnarrow library(treemapify) library(gapminder) library(sf) ## Linking to GEOS 3.6.2, GDAL 2.2.3, PROJ 4.9.3 library(geobr) library(readxl) library(janitor) ## ## Attaching package: &#39;janitor&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## chisq.test, fisher.test O ggplot2 é mais um pacote desenvolvido por Hadley Wickham, o criador, por exemplo, do tidyr e do dplyr. A ideia do pacote, ainda que com algumas modificações, vem de uma obra chamada The Grammar of Graphics, que é uma maneira de descrever um gráfico a partir dos seus componentes. Dessa forma, teoricamente, ficaria mais fácil entender a construção de gráficos mais complexos. Esse pacote é estruturado de forma que a “gramática” seja utilizada para um gráfico a partir de múltiplas camadas. As camadas serão formadas por dados, mapeamentos estéticos, transformações estatísticas dos dados, objetos geométricos (pontos, linhas, barras etc.) e ajuste de posicionamento. Além disso, existem outros componentes, como os sistemas de coordenadas (cartesiano, polar, mapa etc.) e, se for o caso, divisões do gráfico em subplots (facet). Um simples exemplo de múltiplas camadas seria um gráfico de pontos adicionado de uma curva de ajustamento. Uma forma geral (template) para entender-se a estrutura do ggplot2, segundo o próprio Hadley Wickhan, no livro R for Data Science, é a seguinte: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; # dividir o gráfico em subplots A ideia é que todo gráfico pode ser representado por essa forma. No entanto, na criação de um gráfico, não é necessário especificar-se todas as partes acima. O ggplot2 já oferece um padrão para o sistema de coordenadas, para o stat e position. O facet (subplot) só será utilizado quando necessário. Além disso, existem as escalas que são utilizadas para controlar o mapeamento dos dados em relação aos atributos estéticos do gráfico. Por exemplo: suponha que no seu gráfico exista uma coluna que é uma variável categórica com três classes possíveis e as cores do objeto geométrico estejam associadas a essa variável. Automaticamente, o ggplot2 definirá uma cor pra cada classe. No entanto, você pode alterar a escala de cores para ter controle sobre elas. O mesmo vale para os valores apresentados nos eixos x e y. Uma observação importante é que apesar dos dados estarem na função ggplot() (&lt;DATA&gt;), eles também podem ser incluídos diretamente em cada objeto geométrico. Isto será útil quando for necessário criar-se uma nova camada a partir de dados diferentes daqueles que estão inicialmente nos gráficos. Dessa forma, incorporando essas observações, um template estendido seria o abaixo: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt;, data = &lt;DATA&gt; # pode receber os dados diretamente ) + &lt;SCALE_FUNCTION&gt; + # uma para cada elemento estético &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; # dividir o gráfico em subplots Também é importante ressaltar-se que, como todo sistema de gráficos, é possível alterar-se todos os títulos e rótulos do gráfico, além do controle sobre as características do tema do gráfico (cor do fundo, estilo da fonte, tamanho da fonte etc). Para quebrar-se a barreira inicial, vamos criar um exemplo por partes: library(ggplot2) data(&quot;mtcars&quot;) # Inicia o plot g &lt;- ggplot(mtcars) # Adicionar pontos (geom_point) e # vamos mapear variáveis a elementos estéticos dos pontos # Size = 3 define o tamanho de todos os pontos g &lt;- g + geom_point(aes(x = hp, y = mpg, color = factor(am)), size = 3) # Altera a escala de cores g &lt;- g + scale_color_manual(&quot;Automatic&quot;, values = c(&quot;red&quot;, &quot;blue&quot;), labels = c(&quot;No&quot;, &quot;Yes&quot;)) # Rótulos (títulos) g &lt;- g + labs(title = &#39;Relação entre consumo, potência e tipo de câmbio&#39;, y = &#39;Consumo&#39;, x = &#39;Potência&#39;) g Note que o gráfico poderia ser criado com um bloco único de código: ggplot(mtcars) + geom_point(aes(x = hp, y = mpg, color = factor(am)), size = 3) + scale_color_manual(&quot;Automatic&quot;, values = c(&quot;red&quot;, &quot;blue&quot;), labels = c(&quot;No&quot;, &quot;Yes&quot;)) + labs(title = &#39;Relação entre consumo, potência e tipo de câmbio&#39;, y = &#39;Consumo&#39;, x = &#39;Potência&#39;) Detalharemos cada parte do gráfico, mas vale falar-se rapidamente sobre o código acima. Primeiramente, passamos um conjunto de dados para o ggplot. Depois, adicionamos uma camada de pontos, mapeando as variáveis hp e mpg para as posições de cada ponto nos eixos x e y, respectivamente, e a variável am para a cor de cada ponto. Em seguida, alteramos a escala de cor, definindo seu título, os rótulos (labels) e os valores (values) para as cores. Por fim, definimos os títulos/rótulos do gráfico. Nas próximas seções, falaremos com mais detalhes sobre cada componente, começando pelo mapeamento estético. 12.1 Mapeamento Estético O mapeamento estético é o mapeamento das variáveis dos dados para as características visuais dos objetos geométricos (pontos, barras, linhas etc.). Isto é feito a partir da função aes(). E quais são as características visuais de um objeto geométrico? Abaixo segue uma lista não exaustiva: Posição (x e y); Cor (color); Tamanho (size); Preenchimento (fill); Transparência (alpha); Texto (label). Como vimos no exemplo acima, mapeamos três variáveis para três características visuais de cada ponto: posição x, posição y e cor. Nos próximos exemplos, outros elementos estéticos serão utilizados, conforme o objeto geométrico selecionado. 12.2 Objetos geométricos Os objetos geométricos começam com a expressão geom_ e são seguidos pelo tipo de objeto. Por exemplo, geom_point() para pontos e geom_bar() para barras. A tabela abaixo apresenta os tipos de objetos geométricos utilizados para criar-se alguns tipos de gráficos populares. Tipo Objeto Geométrico Dispersão (scatterplot) geom_point() Gráfico de bolhas geom_point() Gráfico de barras geom_bar() e geom_col() Histograma geom_histogram() Boxplot geom_boxplot() Densidade geom_density() Gráfico de linhas geom_line() Nesse material, os principais tipos de objetos geométricos serão demonstrados a partir de exemplos. A lista completa de objetos geométricos e as descrições dos argumentos estão na documentação do ggplot2. É importante saber-se que um gráfico do ggplot2 pode ter mais de um objeto geométrico, cada um formando uma camada. Por exemplo, uma camada de pontos e outra de linhas que conectam os pontos. Vamos, primeiramente, criar um gráfico com pontos a partir dos dados mtcars. Use ?mtcars para mais detalhes. g1 &lt;- ggplot(mtcars, aes(y = mpg, x = disp)) + geom_point() g1 &gt; Note que o aes() está sendo usado diretamente na função ggplot() e não no objeto geométrico. O que isto significa? Que o mapeamento estético definido na função ggplot() é global. Ou seja, é aplicado para todos os objetos geométricos daquele gráfico, a menos que seja explicitado novamente em alguma camada. Para finalizarmos essa breve introdução a objetos geométricos, adicionemos mais uma camada ao gráfico: library(dplyr) mtcars &lt;- mtcars %&gt;% mutate(name = rownames(mtcars)) ggplot(mtcars, aes(y = mpg, x = disp)) + geom_point() + geom_smooth() No caso, adicionamos uma curva de ajustamento aos dados, que tem o objetivo de evidenciar um padrão nos mesmos. 12.3 Escalas O controle sobre as escalas do gráfico é fundamental no ajuste de um gráfico. Em geral, o ggplot2, como outros pacotes gráficos, fornece as escalas automaticamente, não sendo necessário o entendimento de como se controlar este componente. No entanto, se o interesse é ter controle sobre todos os aspectos de um gráfico, esse componente é fundamental. Veja o gráfico abaixo: ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point() Note que a cor está mapeada para a variável Species. O ggplot2, automaticamente, criou a seguinte escala: Species Cor setosa vermelho versicolor verde virginica azul Todavia, é comum haver interesse em alterar-se essas cores, ou seja, alterar-se a escala de cor. Como fazer isso no ggplot2? Podemos usar, por exemplo, a função scale_color_manual(): ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point() + scale_color_manual(values = c(&quot;orange&quot;, &quot;black&quot;, &quot;red&quot;)) Utilizamos a função scale_color_manual() em razão da variável Species ser categórica. Para o ggplot2, dados categóricos são discretos, e a função citada permite criar-se uma escala discreta customizada. No entanto, essa não é a única função para controlar escala de cor. Existem outras como scale_color_discrete(), scale_color_continuous(), scale_color_gradient() etc. A utilização de cada função depende do tipo de dado que se está associando ao elemento estético color. Adiante, entraremos em mais detalhes sobre os tipos de dados. As funções utilizadas para controlar-se as escalas dos elementos de um gráfico do ggplot2 seguem um padrão. Todas iniciam-se com scale_, depois o nome do elemento estético (color, fill, x etc.) e, por fim, o tipo/nome da escala que será aplicada. Abaixo, continuaremos o exemplo anterior, alterando as escalas dos eixos x e y. Note que as variáveis Petal.Length e Petal.Width são variáveis numéricas/contínuas. Dessa forma, utilizaremos as funções scale_x_continuous() e scale_y_continuous(): ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point() + scale_color_manual(values = c(&quot;orange&quot;, &quot;black&quot;, &quot;red&quot;)) + scale_x_continuous(name = &quot;Petal Length&quot;, breaks = 1:7) + scale_y_continuous(name = &quot;Petal Width&quot;, breaks = 0:3, limits = c(0, 3)) No gráfico acima, definimos quais seriam os pontos em que rótulos deveriam ser exibidos em cada eixo. Além disso, no eixo y, definimos que os limites seriam 0 e 3. 12.3.1 Tipos de Variáveis Para melhor uso das escalas, é preciso saber o tipo de variável que foi mapeado para cada elemento estético. Vamos rapidamente montar essa relação: Classe Exemplo Tipo no ggplot2 numeric seq(0, 1, length.out = 10) continuous integer 1L:10L continuous ou discrete character c(“Sim”, “Não”) discrete factor factor(c(“Sim”, “Não”)) discrete date seq(as.Date(“2000/1/1”), by = “month”, length.out = 12) date Lembre-se que o padrão do ggplot é scale_, depois o nome do elemento estético (color, fill, x etc.) e, por fim, o tipo/nome da escala que será aplicada. É importante que o usuário saiba o tipo de dado, pois assim saberá com mais facilidade qual é o tipo de escala que deve ser escolhido. Vamos, em sequência, entrar em mais detalhes para escalas dos eixos (x e y) e de cores. Espera-se que a intuição desenvolvida a partir dos exemplos das escalas para esses elementos estéticos seja útil para os demais elementos estéticos. 12.3.2 Eixos 12.3.2.1 Variáveis Contínuas scale_x_continuous(name = waiver(), breaks = waiver(), minor_breaks = waiver(), labels = waiver(), limits = NULL, expand = waiver(), oob = censor, na.value = NA_real_, trans = &quot;identity&quot;) scale_y_continuous(name = waiver(), breaks = waiver(), minor_breaks = waiver(), labels = waiver(), limits = NULL, expand = waiver(), oob = censor, na.value = NA_real_, trans = &quot;identity&quot;) Vamos começar editando os valores dos eixos x e y. Anteriormente, já demos uma pequena amostra sobre a edição dos eixos x e y. Abaixo, será apresentado mais um exemplo: library(ISLR) ggplot(Wage, aes(x = age, y = wage, color = education)) + geom_point() + scale_x_continuous(&quot;Idade&quot;, breaks = seq(0, 80, 5), expand = c(0, 5)) + scale_y_continuous(&quot;Salário&quot;, labels = function(x) paste0(&quot;US$ &quot;, x), limits = c(0, 400)) Para o eixo x, determinamos que as quebras (breaks) acontecem a cada 5 anos. O expand(0,0) é um argumento que controla os espaços adicionais no final do gráfico. É preciso fornecer-se um vetor de tamanho 2, com uma constante multiplicativa e outra aditiva. No exemplo acima, eliminamos a expansão. Para o eixo y, informamos que o nome do eixo é Salário, que os limites inferior e superior são 0 e 400 e alteramos os rótulos. No caso, passamos uma função que concatena US$ com o valor que já seria exibido. Note que, sabendo de antemão todos os breaks, é possível definir-se manualmente os labels. Veremos isso no exemplo com variáveis categóricas, no entanto, para variáveis contínuas, o uso de funções parece mais apropriado. 12.3.2.2 Variáveis discretas Apesar do help não apresentar todos os argumentos para as escalas discretas, podemos usar quase todos que foram listados para escala contínua. scale_x_discrete(..., expand = waiver(), position = &quot;bottom&quot;) scale_y_discrete(..., expand = waiver(), position = &quot;left&quot;) No exemplo abaixo, alteraremos os rótulos para uma escala discreta, que originalmente contém os valores Yes e No. ggplot(Default, aes(x = default, y = balance)) + geom_boxplot() + scale_x_discrete(&quot;Calote&quot;, labels = c(&quot;Não&quot;, &quot;Sim&quot;)) + labs(y = &quot;Valor devido médio após o pagamento mensal&quot;) Pode-se utilizar o argumento limits para alterar-se a ordem das categorias. ggplot(Default, aes(x = default, y = balance)) + geom_boxplot() + scale_x_discrete(&quot;Calote&quot;, limits = c(&quot;Yes&quot;, &quot;No&quot;), labels = c(&quot;Sim&quot;, &quot;Não&quot;)) + labs(y = &quot;Valor devido médio após o pagamento mensal&quot;) Também pode-se alterar a ordem de variáveis categóricas alterando-se a ordem dos níveis (levels) da variável no data.frame original, ou utilizando-se as funções ylim() e xlim(). Experimente. 12.3.2.3 Variáveis de Datas Quando estamos trabalhando com séries temporais, é comum que datas sejam associadas a algum eixo do gŕafico, geralmente ao eixo x. As funções padrão para controle de escalas dos eixos, para variáveis de datas, são as seguintes: scale_x_date(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver()) scale_y_date(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver()) scale_x_datetime(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver()) scale_y_datetime(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver()) O scale_*_date é utilizado para variáveis do tipo Date e scale_*_datetime para variáveis do tipo POSIXct. A classe POSIXct aceita informações relacionadas a tempo/horário e a classe Date aceita apenas dia, mês e ano. O mais importante é a possibilidade de alterar-se o modo como as datas são apresentadas a partir do argumento date_labels. Para isso, utilizaremos um exemplo a partir dos dados economics. Primeiro, observa-se o resultado padrão do ggplot2: ggplot(economics, aes(x = date, y = unemploy)) + geom_line() Agora, suponha que queremos alterar o gráfico para o formato “Jan/1970”: ggplot(economics, aes(x = date, y = unemploy)) + geom_line() + scale_x_date(date_labels = &quot;%b/%Y&quot;) O %b/%Y é usado para definir-se o formato de data desejado. Para ver a lista de formatos, use help(strptime). Para os breaks, temos duas opções: utilizar-se o argumento breaks, informando um vetor de datas, ou usar-se o argumento date_breaks, em que se informa a frequência dos breaks (por exemplo, “1 month” e “5 years”). Veja os exemplos abaixos: ggplot(economics, aes(x = date, y = unemploy)) + geom_line() + scale_x_date(date_breaks = &quot;5 years&quot;, date_labels = &quot;%Y&quot;) seq_datas &lt;- seq.Date(as.Date(&#39;1970-01-01&#39;), as.Date(&#39;2015-04-01&#39;), by = &#39;5 years&#39;) ggplot(economics, aes(x = date, y = unemploy)) + geom_line() + scale_x_date(breaks = seq_datas, date_labels = &quot;%Y&quot;) 12.3.3 Escalas de Cores (color) e Preenchimento (fill) Como nos casos dos eixos x e y, o tipo da variável utilizada define qual o tipo de escala. Tipo da Variável Escala Descrição Discreta hue escolhe n cores igualmente espaçadas em um disco de cores. É possível editar a luminosidade e a saturação. grey escala de cinza brewer ver pacote RColorBrewer identity usa as cores inseridas na própria variável manual escolhe as cores manualmente Contínua gradient cria um gradiente de duas cores (low-high) gradient2 cria um gradiente de cores divergentes (low-mid-high) gradientn cria um gradiente com n cores A opção hue usa a seguinte roda de cores: Figura 12.1: Roda de Cores - hue A opção brewer pode usar as paletas de cores disponíveis no pacote RColorBrewer. library(RColorBrewer) display.brewer.all(n=NULL, type=&quot;all&quot;, select=NULL, exact.n=TRUE, colorblindFriendly=FALSE) No exemplo abaixo, vamos utilizar a função brewer.pal, que retorna um vetor de cores de alguma paleta do pacote RColorBrewer. O objeto paleta.gradientn recebe nove cores da paleta Reds. Essas cores são utilizadas na função scale_fill_gradientn(). paleta.gradientn &lt;- brewer.pal(n = 9, name = &#39;Reds&#39;) Credit %&gt;% group_by(Cards, Student) %&gt;% summarise(Balance = mean(Balance), n = n()) %&gt;% ggplot(aes(x = Cards, y = Student, fill = Balance)) + geom_tile() + scale_fill_gradientn(colors = rev(paleta.gradientn)) + scale_x_continuous(breaks = 1:9) Alguns pacotes também fornecem escalas de cores próprias, como é o caso do pacote viridis. Credit %&gt;% group_by(Cards, Student) %&gt;% summarise(Balance = mean(Balance), n = n()) %&gt;% ggplot(aes(x = Cards, y = Student, fill = Balance)) + geom_tile() + viridis::scale_fill_viridis() + scale_x_continuous(breaks = 1:9) Agora, vamos a um exemplo utilizando o scale_color_manual(): ggplot(Wage, aes(y = wage, x = age, color = education)) + geom_point() + scale_color_manual(values = c(&quot;#66C2A5&quot;, &quot;#FC8D62&quot;, &quot;#8DA0CB&quot;, &quot;#E78AC3&quot;, &quot;#A6D854&quot;)) Aqui fizemos uma introdução ao componente de escalas. Não tratamos de todas as funções de escalas. A ideia é passar-se a lógica geral para se utilizar escalas e não que o usuário decore todas as funções, o que seria contraproducente. 12.4 Subplots (facet) O ggplot2 facilita a criação de subplots nos casos em que se deseja replicar o mesmo gráfico para um conjunto de valores de outra variável. Por exemplo, criar um gráfico da série temporal de desemprego para cada unidade da federação. As duas principais funções são facet_wrap() e facet_grid(). Painéis em formato de grid: facet_grid(facets, margins = FALSE, scales = &quot;fixed&quot;, space = &quot;fixed&quot;, shrink = TRUE, labeller = &quot;label_value&quot;, as.table = TRUE, switch = NULL, drop = TRUE) Converte painéis de uma dimensão para duas dimensões: facet_wrap(facets, nrow = NULL, ncol = NULL, scales = &quot;fixed&quot;, shrink = TRUE, labeller = &quot;label_value&quot;, as.table = TRUE, switch = NULL, drop = TRUE, dir = &quot;h&quot;) Antes de mais nada, vamos criar um exemplo para o facet_wrap(): ggplot(diamonds, aes(x = carat, y = price)) + geom_point() E se o objetivo for comparar essas relações para diferentes grupos de lapidação? ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + facet_wrap(vars(cut)) Usamos a sintaxe vars(coluna). Ou seja, indicamos que queremos quebrar os gráficos pela variável cut. O ggplot2 determinou automaticamente o número de colunas e linhas e fixou as escalas dos eixos. No entanto, podemos definir o número de linhas ou colunas a partir dos argumentos nrow e ncol. Também é possível definir-se que cada gráfico tenha sua escala. No exemplo abaixo, deixaremos a escala do eixo y livre. ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + facet_wrap(vars(cut), scales = &quot;free_y&quot;) Já o uso do facet_grid() é indicado para o cruzamento de variáveis. No exemplo abaixo, a relação entre as variáveis price e carat será “quebrada” para grupos formados pelas variáveis cut e clarity: ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + # sintaxe antiga: # facet_grid(clarity ~ cut) # sintaxe nova: facet_grid(cols = vars(cut), rows = vars(clarity)) Note que para cada categoria existe um rótulo. Para alterar-se esse relatório, pode-se alterar diretamente o data.frame ou usar a função labeller(). nomes_cut &lt;- c( Fair = &quot;FAIR&quot;, Good = &quot;GOOD&quot;, `Very Good` = &quot;VERY GOOD&quot;, Premium = &quot;PREMIUM&quot;, Ideal = &quot;IDEAL&quot; ) ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + facet_wrap(vars(cut), scales = &quot;free_y&quot;, labeller = labeller(cut = nomes_cut)) 12.5 Temas O ggplot2 fornece alguns temas prontos. Todavia, o usuário pode alterar manualmente cada detalhe de um gráfico ou criar um tema que será utilizado em outras visualizações. Para editar o tema, será usada a função theme(). Nesta função, poderão ser alterados os elementos do tema, como a cor de fundo do painel, o tamanho da fonte do eixo x, a posição da legenda etc. A lista de elementos está disponível neste link. Para cada elemento do tema, um tipo de objeto é esperado para realizar alterações. Por exemplo, para alterar-se o estilo do título do eixo x (axis.title.x) é preciso passar-se a função element_text(), que possui diversos parâmetros (família da fonte, tipo da fonte, cor, tamanho, alinhamento etc.). Além do element_text(), as principais funções para alterar-se elementos do tema são element_line(), element_rect() e element_blank(). O element_blank() é usado a fim de que nada seja desenhado para o elemento que recebe esta função. Em um primeiro momento, pode parecer complicado alterar o tema via código, porém, conforme o usuário for praticando, essas alterações ficarão mais intuitivas. De toda forma, existe um addin para o RStudio que ajuda a customizar-se um gráfico do ggplot2 a partir de uma interface de point and click. Para instalá-lo, faça o seguinte: install.packages(&#39;ggThemeAssist&#39;) Para exemplificar a alteração do tema manualmente: ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + labs(title = &quot;Carat vs Price&quot;) + theme(text = element_text(face = &quot;bold&quot;), panel.grid.major = element_line(colour = &quot;gray80&quot;), axis.title = element_text(size = 14), panel.background = element_rect(fill = &quot;gray100&quot;)) 12.5.1 Temas disponíveis no ggplot2 p &lt;- ggplot(diamonds, aes(x = carat, y = price)) + geom_point() p + theme_gray() + labs(title = &quot;theme_gray()&quot;) p + theme_bw() + labs(title = &quot;theme_bw()&quot;) p + theme_linedraw() + labs(title = &quot;theme_linedraw()&quot;) p + theme_light() + labs(title = &quot;theme_light()&quot;) p + theme_minimal() + labs(title = &quot;theme_minimal()&quot;) p + theme_classic() + labs(title = &quot;theme_classic()&quot;) p + theme_dark() + labs(title = &quot;theme_dark()&quot;) p + theme_void() + labs(title = &quot;theme_void()&quot;) 12.5.2 Temas no pacote ggthemes O pacote ggthemes disponibiliza um conjunto de temas e escalas de cores. Vamos apresentar alguns temas disponíveis: 12.5.3 hrbrthemes Alguns pacotes fornecem seus próprios temas. É o caso do hrbrthemes. Este pacote fornece um tema bastante interessante e será usado no resto deste capítulo. Como qualquer outro tema, se for necessário, você pode editá-lo com a função theme(): install.packages(&quot;hrbrthemes&quot;) library(hrbrthemes) ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + labs(title = &quot;theme_ipsum()&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) 12.5.4 Setando o tema globalmente Com o comando abaixo, todos os gráficos do seu script terão o mesmo tema: theme_set(theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(text = element_text(angle = 0))) 12.6 Legendas Parte das alterações das legendas pode ser feita via theme(). Essas alterações são gerais para todas as legendas. Se o interesse for em mudanças pontuais na legenda de algum elemento estético, serão utilizadas as funções guides(), guide_legend() e guide_colorbar(). guide_legend(title = waiver(), title.position = NULL, title.theme = NULL, title.hjust = NULL, title.vjust = NULL, label = TRUE, label.position = NULL, label.theme = NULL, label.hjust = NULL, label.vjust = NULL, keywidth = NULL, keyheight = NULL, direction = NULL, default.unit = &quot;line&quot;, override.aes = list(), nrow = NULL, ncol = NULL, byrow = FALSE, reverse = FALSE, order = 0, ...) guide_colourbar(title = waiver(), title.position = NULL, title.theme = NULL, title.hjust = NULL, title.vjust = NULL, label = TRUE, label.position = NULL, label.theme = NULL, label.hjust = NULL, label.vjust = NULL, barwidth = NULL, barheight = NULL, nbin = 20, raster = TRUE, ticks = TRUE, draw.ulim = TRUE, draw.llim = TRUE, direction = NULL, default.unit = &quot;line&quot;, reverse = FALSE, order = 0, ...) O código abaixo exemplifica o uso do guide_legend(): ggplot(diamonds, aes(x = carat, y = price, color = cut, shape = cut)) + geom_point() + guides(color = guide_legend(title = &quot;Cor&quot;, title.position = &quot;left&quot;, keywidth = 5), shape = guide_legend(title = &quot;Forma&quot;, title.position = &quot;right&quot;, override.aes = aes(size = 5))) ## Warning: Using shapes for an ordinal variable is not advised Pode-se fazer uso do “none” para omitir-se a legenda de um elemento estético: ggplot(diamonds, aes(x = carat, y = price, color = cut, shape = cut)) + geom_point() + guides(color = guide_legend(title = &quot;Cor&quot;, title.position = &quot;left&quot;, keywidth = 5), shape = &quot;none&quot;) ## Warning: Using shapes for an ordinal variable is not advised 12.7 Escolhendo o tipo de gráfico Antes de decidir qual gráfico você utilizará, é preciso saber o que se deseja representar. O objetivo guiará o tipo de gráfico mais adequado. A imagem abaixo apresenta uma lista bastante completa de possibilidades de gráficos, dos mais simples aos mais complexos: Entre neste link para visualizar a imagem com zoom. Os gráficos mais tradicionais podem ser facilmente criados a partir da lógica de camadas do ggplot2 e dos objetos geométricos disponíveis no pacote. Para gráficos mais complexos, alguns pacotes estão disponíveis. Por exemplo, para a criação de treemaps, existe o pacote treemapify. library(treemapify) ggplot(G20, aes(area = gdp_mil_usd, fill = hdi, label = country)) + geom_treemap() + geom_treemap_text(fontface = &quot;italic&quot;, colour = &quot;white&quot;, place = &quot;centre&quot;, grow = TRUE) + theme(legend.position = &#39;bottom&#39;) 12.8 Gráfico de Dispersão (geom_point()) geom_point(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) O gráfico de dispersão é bastante usado para verificar-se relações entre duas variáveis quantitativas. Para exemplificar, utilizaremos a base disponível no pacote gapminder. Nesta base, existe uma variável de expectativa de vida e outra de renda per capita. Como queremos um gráfico de pontos, o objeto geométrico natural é o geom_point(). Esse objeto geométrico tem os seguintes elementos estéticos: Os parâmetros estéticos (aes) são: x y alpha colour fill shape size stroke Vamos verificar qual é a relação entre essas duas variáveis: library(hrbrthemes) library(gapminder) gapminder %&gt;% filter(year == max(year)) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() + labs(title = &quot;Relação entre Renda per Capita e Expectativa de Vida - 2007&quot;, x = &quot;Renda per Capita&quot;, y = &quot;Expectativa de Vida&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Note que a expectativa de vida cresce muito rápido para níveis de renda baixos, mas o incremento decresce conforme o nível de renda aumenta. Esse fato pode ser melhor representado utilizando-se uma escala logarítmica para a variável renda per capita. É assim que, usualmente, essa relação é apresentada. Para isso, poderíamos aplicar a função log10() na variável de renda per capita, ou utilizarmos a função scale_x_log10(): gapminder %&gt;% filter(year == max(year)) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() + scale_x_log10() + labs(title = &quot;Relação entre Renda per Capita e Expectativa de Vida - 2007&quot;, x = &quot;Renda per Capita (escala log 10)&quot;, y = &quot;Expectativa de Vida&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Com essa escala, valores incrementados na ordem de dez vezes serão igualmente espaçados. Nesse caso, a relação parece ser mais linear, ou seja, ao aumentarmos a renda dez vezes, espera-se que a expectativa de vida cresça a uma taxa constante. Vamos mapear a variável continent ao elemento estético color e shape: gapminder %&gt;% filter(year == max(year)) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent, shape = continent)) + geom_point() + scale_x_log10() + scale_color_discrete(&quot;Continente&quot;) + scale_shape_discrete(&quot;Continente&quot;) + labs(title = &quot;Relação entre Renda per Capita e Expectativa de Vida - 2007&quot;, x = &quot;Renda per Capita (escala log 10)&quot;, y = &quot;Expectativa de Vida&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Automaticamente o ggplot2 criou uma escala para as cores e formatos dos pontos. O usuário pode alterar este mapeamento utilizando as funções scale_*_*. Por fim, fica aqui a lista com os tipos de shapes: Perceba que os formatos de 21 a 24 possuem preenchimento (fill). Assim, no código abaixo definiremos o preenchimento, o tamanho do ponto e a espessura para aqueles formatos que possuem contornos. gapminder %&gt;% filter(year == max(year)) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent, shape = continent)) + geom_point(fill = &quot;black&quot;, size = 3, stroke = 1) + scale_x_log10() + scale_color_discrete(&quot;Continente&quot;) + scale_shape_manual(&quot;Continente&quot;, values = c(19, 21, 22, 23, 24)) + labs(title = &quot;Relação entre Renda per Capita e Expectativa de Vida - 2007&quot;, x = &quot;Renda per Capita (escala log 10)&quot;, y = &quot;Expectativa de Vida&quot;) 12.9 Gráficos de Bolhas O gráfico de bolha é uma extensão natural do gráfico de pontos. Ele permite observar-se possíveis relações entre as três variáveis. Para este tipo de gráfico, são necessárias três variáveis: duas para indicarem as posições x e y e uma terceira para definir o tamanho do ponto (size). Vamos utilizar a variável pop (população): gapminder %&gt;% filter(year == max(year)) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop)) + geom_point() + scale_size_continuous(&quot;População (milhões)&quot;, labels = function(x) round(x/1e6)) + scale_x_log10() + labs(title = &quot;Relação entre Renda per Capita e Expectativa de Vida - 2007&quot;, x = &quot;Renda per Capita (escala log 10)&quot;, y = &quot;Expectativa de Vida&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) 12.10 Gráficos de Barras Os gráficos de barras/colunas são geralmente utilizados para comparações entre categorias (variáveis qualitativas). No ggplot2 podemos usar dois objetos geométricos distintos: geom_bar(mapping = NULL, data = NULL, stat = &quot;count&quot;, position = &quot;stack&quot;, ..., width = NULL, binwidth = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) geom_col(mapping = NULL, data = NULL, position = &quot;stack&quot;, ..., width = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) Os parâmetros estéticos (aes) são: x y (somente com stat=identity) alpha colour fill linetype size Há um detalhe importante para o geom_bar(): o argumento stat. Por padrão, para este objeto geométrico, o valor de stat é count, o que significa que ele fará uma contagem dos elementos do eixo x. Essa contagem será usada no eixo y. Por exemplo: ggplot(diamonds, aes(x = cut)) + geom_bar() + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Para cada valor da variável cut, o ggplot2 calculou o número de observações no data.frame diamonds. Para que o y seja mapeado para uma variável do data.frame, é necessário definir stat = identity. gapminder %&gt;% filter(year == max(year), continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = country, y = lifeExp)) + geom_bar(stat = &quot;identity&quot;, fill = &quot;dodgerblue&quot;) + labs(title = &quot;Expectativa de vida por país&quot;, subtitle = &quot;2007&quot;, x = &quot;País&quot;, y = &quot;Expectativa de Vida&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) Usando o geom_col(): gapminder %&gt;% filter(year == max(year), continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = country, y = lifeExp)) + geom_col(fill = &quot;dodgerblue&quot;) + labs(title = &quot;Expectativa de vida por país&quot;, subtitle = &quot;2007&quot;, x = &quot;País&quot;, y = &quot;Anos&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) Uma pergunta recorrente é: Como ordenar as barras em ordem crescente/decrescente? Para isso, pode-se utilizar a função reorder() no momento do mapeamento. Fica mais claro com um exemplo: gapminder %&gt;% filter(year == max(year), continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = reorder(country, -lifeExp), y = lifeExp)) + geom_col(fill = &quot;dodgerblue&quot;) + labs(title = &quot;Expectativa de vida por país&quot;, subtitle = &quot;2007&quot;, x = &quot;País&quot;, y = &quot;Anos&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) Vamos, agora, criar um gráfico em que se compara a expectativa de vida média por continente em 1957 e 2007: gapminder %&gt;% filter(year %in% c(1957, 2007)) %&gt;% # Converte o ano para factor - será categoria no gráfico mutate(year = factor(year)) %&gt;% group_by(continent, year) %&gt;% summarise(lifeExp = mean(lifeExp)) %&gt;% ggplot(aes(x = continent, y = lifeExp, fill = year)) + geom_col() + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Para continente, o gráfico empilhou as barras. Isto se deve ao argumento position = stack. Para colocar as barras lado a lado, utilizamos o valor “dodge”: gapminder %&gt;% filter(year %in% c(1957, 2007)) %&gt;% # Converte o ano para factor - será categoria no gráfico mutate(year = factor(year)) %&gt;% group_by(continent, year) %&gt;% summarise(lifeExp = mean(lifeExp)) %&gt;% ggplot(aes(x = continent, y = lifeExp, fill = year)) + geom_col(position = &quot;dodge&quot;) + labs(title = &quot;Expectativa de vida por continente&quot;, x = &quot;Continente&quot;, y = &quot;Anos&quot;, fill = &quot;Ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Também é comum representar-se as barras de forma horizontal. Para isto basta usar a função coord_flip(): gapminder %&gt;% filter(year %in% c(1957, 2007)) %&gt;% # Converte o ano para factor - será categoria no gráfico mutate(year = factor(year)) %&gt;% group_by(continent, year) %&gt;% summarise(lifeExp = mean(lifeExp)) %&gt;% ggplot(aes(x = continent, y = lifeExp, fill = year)) + geom_col(position = &quot;dodge&quot;) + coord_flip() + labs(title = &quot;Expectativa de vida por continente&quot;, x = &quot;Continente&quot;, y = &quot;Anos&quot;, fill = &quot;Ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) 12.11 Gráficos de linhas Os gráficos de linhas são, geralmente, utilizados para apresentar-se a evolução de uma variável quantitativa em um intervalo de tempo. geom_line(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, ...) Os parâmetros estéticos (aes) são: x y alpha colour linetype size gapminder %&gt;% group_by(continent, year) %&gt;% summarise(lifeExp = mean(lifeExp)) %&gt;% ggplot(aes(x = year, y = lifeExp, color = continent)) + geom_line() + labs(title = &quot;Evolução da expectativa de vida por continente&quot;, x = &quot;Ano&quot;, y = &quot;Anos de vida&quot;, color = &quot;Continente&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) É bastante comum que gráficos de linhas apresentem marcações para os períodos em que realmente existem os dados. Para isso, podemos adicionar uma camada de pontos: gapminder %&gt;% group_by(continent, year) %&gt;% summarise(lifeExp = mean(lifeExp)) %&gt;% ggplot(aes(x = year, y = lifeExp, color = continent)) + geom_line() + geom_point(aes(shape = continent)) + labs(title = &quot;Evolução da expectativa de vida por continente&quot;, x = &quot;Ano&quot;, y = &quot;Anos de vida&quot;, color = &quot;Continente&quot;, shape = &quot;Continente&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) 12.12 Histogramas e freqpoly geom_freqpoly(mapping = NULL, data = NULL, stat = &quot;bin&quot;, position = &quot;identity&quot;, ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) geom_histogram(mapping = NULL, data = NULL, stat = &quot;bin&quot;, position = &quot;stack&quot;, ..., binwidth = NULL, bins = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) Os histogramas são utilizados para representar-se a distribuição de dados de uma variável quantitativa em intervalos contínuos. Esses intervalos são chamados de bins. Para cada bin, será apresentada a quantidade de valores que estão naquele intervalo. A diferença para o geom_freqpoly é que este utiliza linhas para construir polígonos, enquanto o geom_histogram utiliza barras. Conforme a documentação do ggplot2, o geom_histogram() utiliza os mesmos elementos estéticos do geom_bar(). Já o geom_freqpoly() utiliza os mesmo do geom_line(). gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = lifeExp)) + geom_histogram(binwidth = 5, fill = &#39;dodgerblue&#39;, color = &#39;black&#39;) + labs(title = &quot;Distribuição da expectativa vida&quot;, x = &quot;Anos&quot;, y = &quot;Contagem&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = lifeExp)) + geom_freqpoly(binwidth = 5) + labs(title = &quot;Distribuição da expectativa vida&quot;, x = &quot;Anos&quot;, y = &quot;Contagem&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Transformando em proporção: gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = lifeExp)) + geom_histogram(aes(y = ..count../sum(..count..)),binwidth = 5, fill = &#39;dodgerblue&#39;, color = &#39;black&#39;) + labs(title = &quot;Distribuição da expectativa vida&quot;, x = &quot;Anos&quot;, y = &quot;Proporção&quot;) + scale_y_continuous(labels = scales::percent_format()) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) O ggplot2, internamente, criou a variável ..count... Dessa forma, podemos utilizá-la para criar as proporções. 12.13 Boxplots, jitterplots e violinplots O boxplot é uma representação comum para apresentar-se a distribuição de uma variável a partir de seus quantis. A imagem abaixo detalha como um boxplot é formado. Detalhes sobre o bloxplot O boxplot também pode ser usado para verificar-se a distribuição de variável para um conjunto de valores de uma segunda variável. Por exemplo: qual é a distribuição da expectativa de vida por ano? ggplot(gapminder, aes(x = factor(year), y = lifeExp)) + geom_boxplot(fill = &quot;dodgerblue&quot;) + labs(y = &quot;Anos de vida&quot;, x = &quot;Ano&quot;, title = &quot;Distribuição da expectativa de vida por ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Vemos que existe um possível outlier em 1992. Quando falarmos sobre anotações, voltaremos a este gráfico. Para termos uma visão da distribuição geral dos valores por ano, podemos utilizar o geom_violin(). O violinplot baseia-se na densidade de probabilidade de uma variável contínua. Assim, é possível verificar-se em quais intervalos existe uma maior chance de ocorrência. Isto é representado pela parte mais larga do objeto. ggplot(gapminder, aes(x = factor(year), y = lifeExp)) + geom_violin(fill = &quot;dodgerblue&quot;) + labs(y = &quot;Anos de vida&quot;, x = &quot;Ano&quot;, title = &quot;Distribuição da expectativa de vida por ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) O jitterplot é utilizado para evitar-se o problema do overplotting em um gráfico. Note, no gráfico abaixo, que não sabemos se a marcação de um ponto representa uma única observação ou várias. ggplot(gapminder, aes(x = factor(year), y = lifeExp)) + geom_point() + labs(y = &quot;Anos de vida&quot;, x = &quot;Ano&quot;, title = &quot;Distribuição da expectativa de vida por ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Para observarmos a real distribuição, é necessário adicionar-se um pouco de ruído, a fim de que os pontos se afastem um pouco: ggplot(gapminder, aes(x = factor(year), y = lifeExp)) + geom_jitter() + labs(y = &quot;Anos de vida&quot;, x = &quot;Ano&quot;, title = &quot;Distribuição da expectativa de vida por ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) 12.14 Anotações Para criarmos anotações no ggplot2, podemos utilizar a função annotate(). Primeiro, vamos manipular os dados para saber qual é aquele ponto: gapminder %&gt;% filter(year == 1992, lifeExp == min(lifeExp)) ## # A tibble: 1 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Rwanda Africa 1992 23.6 7290203 737. Com essas informações, podemos adicionar uma anotação ao gráfico: ggplot(gapminder, aes(x = factor(year), y = lifeExp)) + geom_boxplot(fill = &quot;dodgerblue&quot;) + annotate(&quot;text&quot;, x = &quot;1992&quot;, y = 27, label = &quot;Ruanda&quot;) + labs(y = &quot;Anos de vida&quot;, x = &quot;Ano&quot;, title = &quot;Distribuição da expectativa de vida por ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) Também podemos adicionar segmentos e retângulos com o annotate(). Vamos marcar o período de 1982 a 2002 com um retângulo: ggplot(gapminder, aes(x = factor(year), y = lifeExp)) + annotate(&quot;text&quot;, x = &quot;1992&quot;, y = 27, label = &quot;Ruanda&quot;) + annotate(&quot;rect&quot;, xmin = &quot;1982&quot;, ymin = 20, xmax = &quot;2002&quot;, ymax = 95, alpha = 0.2) + geom_boxplot(fill = &quot;dodgerblue&quot;) + labs(y = &quot;Anos de vida&quot;, x = &quot;Ano&quot;, title = &quot;Distribuição da expectativa de vida por ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) 12.15 Cleveland Dot Plot O cleveland dot plot é uma visualização que pode substituir os gráficos de barras. A ideia é que o gráfico fica menos poluído com os pontos, fazendo com que o leitor foque no que é importante. Vamos criar um gráfico para comparar as expectativas de vida no ano de 2007 para os países das Américas: gapminder %&gt;% filter(year == 2007, continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = lifeExp, y = reorder(country, lifeExp))) + geom_point(size = 3, color = &quot;dodgerblue&quot;) + labs(title = &quot;Expectativa de vida por país - 2007&quot;, y = &quot;País&quot;, x = &quot;Anos&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(panel.grid.major.y = element_line(linetype = &quot;dashed&quot;)) Esse tipo de gráfico também pode apresentar mais de um ponto para cada valor da variável categórica (país): gapminder %&gt;% filter(year %in% c(1987, 2007), continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = lifeExp, y = country, color = factor(year))) + geom_point(aes(color = factor(year))) + labs(title = &quot;Expectativa de vida por país - 1987 e 2007&quot;, y = &quot;País&quot;, x = &quot;Anos&quot;, color = &quot;Ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(panel.grid.major.y = element_line(linetype = &quot;dashed&quot;)) No gráfico acima, vemos dois pontos para cada país, um para representar 1987 e outro para 2007. Para completarmos o gráfico, precisamos adicionar uma linha conectando esses dois pontos. Esse gráfico é chamado de connected dot plot. Um detalhe importante é que queremos criar uma linha por país, assim, usaremos o elemento estético group para obter o resultado esperado: gapminder %&gt;% filter(year %in% c(1987, 2007), continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = lifeExp, y = country)) + geom_line(aes(group = country)) + geom_point(aes(color = factor(year))) + labs(title = &quot;Expectativa de vida por país - 1987 e 2007&quot;, y = &quot;País&quot;, x = &quot;Anos&quot;, color = &quot;Ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(panel.grid.major.y = element_line(linetype = &quot;dashed&quot;)) Para finalizar, vamos ordenar o eixo y pela expectativa de vida: gapminder %&gt;% filter(year %in% c(1987, 2007), continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = lifeExp, y = reorder(country, lifeExp, max))) + geom_line(aes(group = country), color = &quot;grey50&quot;) + geom_point(aes(color = factor(year))) + labs(title = &quot;Expectativa de vida por país - 1987 e 2007&quot;, y = &quot;País&quot;, x = &quot;Anos&quot;, color = &quot;Ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(panel.grid.major.y = element_line(linetype = &quot;dashed&quot;)) 12.16 Textos/Rótulos geom_label(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, ..., parse = FALSE, nudge_x = 0, nudge_y = 0, label.padding = unit(0.25, &quot;lines&quot;), label.r = unit(0.15, &quot;lines&quot;), label.size = 0.25, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) geom_text(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, ..., parse = FALSE, nudge_x = 0, nudge_y = 0, check_overlap = FALSE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) Os parâmetros estéticos (aes) são: label x y alpha angle colour family fontface hjust lineheight size vjust Para adicionar textos ou rótulos, utilizamos, respectivamente, o geom_text() e o geom_label(), que se diferenciam na formatação. Isto ficará mais claro nos exemplos a seguir: gapminder %&gt;% filter(year == 2007, continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = lifeExp, y = reorder(country, lifeExp))) + geom_segment(x = 0, aes(xend = lifeExp, yend = country), color = &quot;grey50&quot;) + geom_point(size = 3, color = &quot;dodgerblue&quot;) + geom_text(aes(label = round(lifeExp))) + labs(title = &quot;Expectativa de vida por país - 2007&quot;, y = &quot;País&quot;, x = &quot;Anos&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) O resultado ficou bem ruim. O texto foi inserido exatamente na posição (x, y). Para alterar a posição, podemos usar os argumentos hjust, vjust, nudge_x e nudge_y. O hjust e vjust podem assumir valor entre 0 (direita/embaixo) e 1(esquerda/em cima) ou “left”, “middle”, “right”, “bottom”, “center” e “top”, além de “inward” e “outward”. gapminder %&gt;% filter(year == 2007, continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = lifeExp, y = reorder(country, lifeExp))) + geom_point(size = 3, color = &quot;dodgerblue&quot;) + geom_text(aes(label = round(lifeExp)), nudge_x = 1) + labs(title = &quot;Expectativa de vida por país - 2007&quot;, y = &quot;País&quot;, x = &quot;Anos&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(panel.grid.major.y = element_line(linetype = &quot;dashed&quot;)) gapminder %&gt;% filter(year == 2007, continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = lifeExp, y = reorder(country, lifeExp))) + geom_point(size = 3, color = &quot;dodgerblue&quot;) + geom_label(aes(label = round(lifeExp)), nudge_x = 1, size = 3) + labs(title = &quot;Expectativa de vida por país - 2007&quot;, y = &quot;País&quot;, x = &quot;Anos&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(panel.grid.major.y = element_line(linetype = &quot;dashed&quot;)) 12.17 Plotando funções reta &lt;- function(a, b, x){ a + b * x } data &lt;- data.frame(x = seq(0, 10, by = 0.1)) ggplot(data, aes(x = x)) + stat_function(fun = reta, args = list(a = 1, b = 2)) + stat_function(fun = reta, args = list(a = 1, b = 3), col = &#39;red&#39;) sigmoid &lt;- function(a = 1,z){ 1/(1 + exp(-a * z)) } data &lt;- data.frame(x = -6:6) ggplot(data, aes(x = x)) + stat_function(fun = sigmoid, args = list(a = 1)) + stat_function(fun = sigmoid, args = list(a = 0.5), color = &quot;blue&quot;) + stat_function(fun = sigmoid, args = list(a = 2), color = &quot;red&quot;) logit &lt;- function(a, z){ log(sigmoid(a, z)/(1 - sigmoid(a, z))) } data &lt;- data.frame(x = -6:6) ggplot(data, aes(x = x)) + stat_function(fun = logit, args = list(a = 1), aes(color = &quot;a = 1&quot;)) + stat_function(fun = logit, args = list(a = 0.5), aes(color = &quot;a = 0.5&quot;)) + stat_function(fun = logit, args = list(a = 2), aes(color = &quot;a = 2&quot;)) ## Warning: `mapping` is not used by stat_function() ## Warning: `mapping` is not used by stat_function() ## Warning: `mapping` is not used by stat_function() 12.18 Mapas: plotando polígonos Produzir mapas com o R nunca foi tão fácil como hoje, graças a avanços recentes dos pacotes sf e ggplot2. Foge muito do escopo deste curso explicar a estrutura de dados espaciais, como shapefiles. Mesmo sem esse entedimento, porém, é possível fazer gráficos com mapas de maneira muito simples. O pacote geobr, desenvolvido pelo brasileiro Ítalo Cegatta, facilita a importação de arquivos shapefiles brasileiros. # importar shapefiles de estados brasileiros geo_ufs &lt;- geobr::read_state(code_state = &#39;all&#39;, year = 2018) ## Using year 2018 ## Loading data for the whole country ## | | | 0% | |===== | 4% | |========= | 7% | |============== | 11% | |=================== | 15% | |======================== | 19% | |============================ | 22% | |================================= | 26% | |====================================== | 30% | |=========================================== | 33% | |=============================================== | 37% | |==================================================== | 41% | |========================================================= | 44% | |============================================================== | 48% | |================================================================== | 52% | |======================================================================= | 56% | |============================================================================ | 59% | |================================================================================= | 63% | |===================================================================================== | 67% | |========================================================================================== | 70% | |=============================================================================================== | 74% | |==================================================================================================== | 78% | |======================================================================================================== | 81% | |============================================================================================================= | 85% | |================================================================================================================== | 89% | |======================================================================================================================= | 93% | |=========================================================================================================================== | 96% | |================================================================================================================================| 100% head(geo_ufs) ## Simple feature collection with 6 features and 5 fields ## geometry type: GEOMETRY ## dimension: XY ## bbox: xmin: -73.99045 ymin: -13.6937 xmax: -46.06151 ymax: 5.271841 ## CRS: 4674 ## code_state abbrev_state name_state code_region name_region geom ## 1 11 RO Rondônia 1 Norte POLYGON ((-62.89216 -12.858... ## 2 12 AC Acre 1 Norte POLYGON ((-71.07772 -9.8277... ## 3 13 AM Amazonas 1 Norte POLYGON ((-69.61341 -2.4402... ## 4 14 RR Roraima 1 Norte POLYGON ((-63.97805 2.46753... ## 5 15 PA Pará 1 Norte MULTIPOLYGON (((-46.38475 -... ## 6 16 AP Amapá 1 Norte MULTIPOLYGON (((-53.27918 2... Observe que o dataframe possui cinco colunas, sendo a última relacionada às informações espaciais sobre os polígonos dos estados que serão usadas para construir os mapas. A sintaxe do ggplot2 para construir mapas é relativamente diferente: não é preciso definir nenhuma aesthetic, pois a função geom_sf internamente busca a coluna de polígonos presente no objeto: ggplot(geo_ufs) + # a linha abaixo da no mesmo que geom_sf(aes(geometry = geom)) geom_sf() A partir do gráfico base criado acima, as customizações seguem o padrão do ggplot2. Por exemplo, é possível mapear a cor os polígonos de acordo com uma variável presente nos dados, além de alterar aspectos visuais com a função theme: ggplot(geo_ufs) + # a linha abaixo da no mesmo que geom_sf(aes(geometry = geometry)) geom_sf(aes(geometry = geom, # colorir os poligonos de acordo com sua regiao fill = as.character(code_region))) + # deixar o mapa mais limpo e sem eixos theme( panel.background = element_blank(), panel.grid.major = element_line(color = &quot;transparent&quot;), axis.text = element_blank(), axis.ticks = element_blank() ) + # mudar titulo da legenda labs(fill = &quot;Região&quot;) Referências: [geom_sf()](https://ggplot2.tidyverse.org/reference/ggsf.html) [Tutorial de geom_sf()](https://dcl-2017-01.github.io/curriculum/notes/spatial-vis.html) 12.18.1 Projeto: plotando indicadores socioeconômicos em um mapa. Neste exemplo, mostramos como o ggplot2 pode ser usado para produzir mapas muito informativos, mapeando a cor de cada polígono a uma variável numérica, como PIB ou população. Observe o passo-a-passo de coleta e transformação dos dados do PIB per capita dos municípios brasileiros: # origem do conjunto de dados: # ftp://ftp.ibge.gov.br/Pib_Municipios/2017/base/base_de_dados_2010_2017_xls.zip # baixe o arquivo, descompacte, abra no excel ou no libre office e salve como xlsx # o R não consegue ler arquivos xls df_pib &lt;- read_excel(&#39;dados/base_de_dados_2010_2017_xls/PIB dos Municípios - base de dados 2010-2017.xlsx&#39;) # limpar nomes das colunas df_pib &lt;- janitor::clean_names(df_pib) # observe os dados: glimpse(df_pib) ## Rows: 44,545 ## Columns: 43 ## $ ano &lt;dbl&gt; … ## $ codigo_da_grande_regiao &lt;dbl&gt; … ## $ nome_da_grande_regiao &lt;chr&gt; … ## $ codigo_da_unidade_da_federacao &lt;dbl&gt; … ## $ sigla_da_unidade_da_federacao &lt;chr&gt; … ## $ nome_da_unidade_da_federacao &lt;chr&gt; … ## $ codigo_do_municipio &lt;dbl&gt; … ## $ nome_do_municipio &lt;chr&gt; … ## $ regiao_metropolitana &lt;chr&gt; … ## $ codigo_da_mesorregiao &lt;dbl&gt; … ## $ nome_da_mesorregiao &lt;chr&gt; … ## $ codigo_da_microrregiao &lt;dbl&gt; … ## $ nome_da_microrregiao &lt;chr&gt; … ## $ codigo_da_regiao_geografica_imediata &lt;dbl&gt; … ## $ nome_da_regiao_geografica_imediata &lt;chr&gt; … ## $ municipio_da_regiao_geografica_imediata &lt;chr&gt; … ## $ codigo_da_regiao_geografica_intermediaria &lt;dbl&gt; … ## $ nome_da_regiao_geografica_intermediaria &lt;chr&gt; … ## $ municipio_da_regiao_geografica_intermediaria &lt;chr&gt; … ## $ codigo_concentracao_urbana &lt;dbl&gt; … ## $ nome_concentracao_urbana &lt;chr&gt; … ## $ tipo_concentracao_urbana &lt;chr&gt; … ## $ codigo_arranjo_populacional &lt;dbl&gt; … ## $ nome_arranjo_populacional &lt;chr&gt; … ## $ hierarquia_urbana &lt;chr&gt; … ## $ hierarquia_urbana_principais_categorias &lt;chr&gt; … ## $ codigo_da_regiao_rural &lt;dbl&gt; … ## $ nome_da_regiao_rural &lt;chr&gt; … ## $ regiao_rural_segundo_classificacao_do_nucleo &lt;chr&gt; … ## $ amazonia_legal &lt;chr&gt; … ## $ semiarido &lt;chr&gt; … ## $ cidade_regiao_de_sao_paulo &lt;chr&gt; … ## $ valor_adicionado_bruto_da_agropecuaria_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ valor_adicionado_bruto_da_industria_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ valor_adicionado_bruto_dos_servicos_a_precos_correntes_exceto_administracao_defesa_educacao_e_saude_publicas_e_seguridade_social_r_1_000 &lt;dbl&gt; … ## $ valor_adicionado_bruto_da_administracao_defesa_educacao_e_saude_publicas_e_seguridade_social_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ valor_adicionado_bruto_total_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ impostos_liquidos_de_subsidios_sobre_produtos_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ produto_interno_bruto_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ produto_interno_bruto_per_capita_a_precos_correntes_r_1_00 &lt;dbl&gt; … ## $ atividade_com_maior_valor_adicionado_bruto &lt;chr&gt; … ## $ atividade_com_segundo_maior_valor_adicionado_bruto &lt;chr&gt; … ## $ atividade_com_terceiro_maior_valor_adicionado_bruto &lt;chr&gt; … # agregando dados por estado, calculando o pib por cidade df_pib_uf &lt;- df_pib %&gt;% # filtrar 2017 filter(ano == 2017) %&gt;% # filtrar fora DF filter(sigla_da_unidade_da_federacao != &#39;DF&#39;) %&gt;% group_by(codigo_da_unidade_da_federacao) %&gt;% summarise(qtd_cidades = n(), pib_uf = sum(produto_interno_bruto_a_precos_correntes_r_1_000), pib_por_cidade = pib_uf/qtd_cidades) head(df_pib_uf) ## # A tibble: 6 x 4 ## codigo_da_unidade_da_federacao qtd_cidades pib_uf pib_por_cidade ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 52 43506499. 836663. ## 2 12 22 14271063. 648685. ## 3 13 62 93204175. 1503293. ## 4 14 15 12103236. 806882. ## 5 15 144 155195371. 1077746. ## 6 16 16 15479885. 967493. Com o dataframe de PIB por cidade criado, podemos o unir com o dataframe que contem os dados espaciais dos estados: geo_uf_pib &lt;- left_join(geo_ufs, df_pib_uf, by = c(&#39;code_state&#39; = &#39;codigo_da_unidade_da_federacao&#39;)) head(geo_uf_pib) ## Simple feature collection with 6 features and 8 fields ## geometry type: GEOMETRY ## dimension: XY ## bbox: xmin: -73.99045 ymin: -13.6937 xmax: -46.06151 ymax: 5.271841 ## CRS: 4674 ## code_state abbrev_state name_state code_region name_region qtd_cidades pib_uf pib_por_cidade geom ## 1 11 RO Rondônia 1 Norte 52 43506499 836663.4 POLYGON ((-62.89216 -12.858... ## 2 12 AC Acre 1 Norte 22 14271063 648684.7 POLYGON ((-71.07772 -9.8277... ## 3 13 AM Amazonas 1 Norte 62 93204175 1503293.1 POLYGON ((-69.61341 -2.4402... ## 4 14 RR Roraima 1 Norte 15 12103236 806882.4 POLYGON ((-63.97805 2.46753... ## 5 15 PA Pará 1 Norte 144 155195371 1077745.6 MULTIPOLYGON (((-46.38475 -... ## 6 16 AP Amapá 1 Norte 16 15479885 967492.8 MULTIPOLYGON (((-53.27918 2... Enfim, podemos proceder com a criação do mapa: ggplot(geo_uf_pib) + geom_sf(aes(fill = log(pib_por_cidade))) + # mudar escala de cores para sequencial vermelha scale_fill_distiller(type = &quot;seq&quot;, palette = &quot;Greens&quot;, direction = 1) + # deixar o mapa mais limpo e sem eixos theme( legend.position = &quot;bottom&quot;, panel.background = element_blank(), panel.grid.major = element_line(color = &quot;transparent&quot;), axis.text = element_blank(), axis.ticks = element_blank() ) + labs(title = &quot;PIB por cidade&quot;, fill = NULL) 12.19 Salvando Gráficos Há duas formas de salvar o gráfico gerado pelo ggplot2. A primeira delas é clicando no botão Export na aba Plots. Lá existirão três opções: exportar para o clipboard, salvar como PDF ou salvar como imagem. knitr::include_graphics(&#39;images/salvar_plot.gif&#39;) A outra opção é usar a função ggsave(): ggsave(filename, plot = last_plot(), device = NULL, path = NULL, scale = 1, width = NA, height = NA, units = c(&quot;in&quot;, &quot;cm&quot;, &quot;mm&quot;), dpi = 300, limitsize = TRUE, ...) O argumento device é usado para escolher-se o tipo de arquivo (“eps”, “ps”, “tex” (pictex), “pdf”, “jpeg”, “tiff”, “png”, “bmp”, “svg” or “wmf”). 12.20 Extensões do ggplot2 Um conjunto de pacotes fornece extensões ao ggplot2. Ou seja, cria funcionalidades não existentes no pacote original. Veja neste link uma galeria com as extensões. Aqui, exemplificaremos algumas: 12.20.1 ggrepel O ggrepel é importante para evitar que textos (geom_text) e rótulos (geom_label) se sobreponham. Veja o mesmo gráfico sem e com o ggrepel: library(ggrepel) data(mtcars) ggplot(mtcars, aes(wt, mpg)) + geom_point(color = &#39;red&#39;) + geom_text(aes(label = rownames(mtcars))) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) library(ggrepel) data(mtcars) ggplot(mtcars, aes(wt, mpg)) + geom_point(color = &#39;red&#39;) + geom_text_repel(aes(label = rownames(mtcars))) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) 12.20.2 gganimate Outra extensão muito interessante é o gganimate. Com esta extensão é possível criar gifs (animações) de gráficos do ggplot2. O ponto fundamental é definir-se uma variável que controlará os frames, ou seja, as imagens que serão sobrepostas para compor-se a animação. Veja o exemplo abaixo: # O pacote não está no cran #devtools::install_github(&quot;dgrtwo/gganimate&quot;) library(gganimate) p &lt;- ggplot(gapminder, aes(x = gdpPercap, y = lifeExp, size = pop, color = continent, frame = year)) + geom_point() + scale_x_log10() animation::ani.options(interval = 1) x &lt;- gganimate(p, filename = &#39;images/gapminder1.gif&#39;, ani.width = 750, ani.height = 450) É possível suavizar a animação com o pacote tweenr. É um pouco complicado, mas fica o exemplo abaixo retirado deste post: library(tweenr) years &lt;- unique(gapminder$year) gapminder_list &lt;- list() for(i in 1:length(years)){ j &lt;- years[i] gapminder_list[[i]] &lt;- gapminder %&gt;% filter(year == j) } tf &lt;- tween_states(gapminder_list, tweenlength = 2, statelength = 0, ease = rep(&quot;linear&quot;, length(gapminder_list)), nframes = 308) tf2 &lt;- expand.grid(y = 80, x = 10^(2.5), year = seq(1957, 2007, 5)) tf2 &lt;- split(tf2, tf2$year) tf2 &lt;- tween_states(tf2, tweenlength = 2, statelength = 0, ease = rep(&quot;linear&quot;, length(tf2)), nframes = 308) tf2 &lt;- tf2 %&gt;% mutate(year = rep(seq(1957, 2007, 5), each = 29)[1:310]) p2 &lt;- ggplot(tf, aes(x=gdpPercap, y=lifeExp, frame = .frame)) + geom_point(aes(size=pop, color=continent), alpha=0.8) + geom_text(data = tf2, aes(x = x, y = y, label = year)) + xlab(&quot;GDP per capita&quot;) + ylab(&quot;Life expectancy at birth&quot;) + scale_x_log10() animation::ani.options(interval = 1/20) x &lt;- gganimate(p2, filename = &#39;images/gapminder2.gif&#39;, ani.width = 750, ani.height = 450, title_frame = FALSE) 12.21 Exercícios Crie um gráfico de dispersão utilizando a base gapminder para o ano de 2007. Mapeie uma variável para o tamanho do ponto e adicione os títulos do gráfico e dos eixos. No gráfico anterior, como você faria para que o ponto do Brasil fosse identificado com uma cor adicional? Dica: se uma nova camada usar um segundo conjunto de dados é preciso informar usando o argumento data. Exemplo: geom_point(data = novo_data_frame, ...). Crie um histograma da variável wage a partir da base de dados Wage do pacote ISLR. Crie uma visualização da distribuição da variável wage por nível da variável education. Mapeie a variável education para o elemento estético fill. Crie um data.frame chamado Wage2 em que a variável education é removida. Adicione a seguinte camada no início do código: geom_histogram(data = Wage2, fill = &quot;grey50&quot;, alpha = 0.5) Veja e interprete o resultado. A partir do código abaixo, crie um gráfico que apresenta os dez países que tiveram maior crescimento do PIB em 2016 e aqueles dez que tiveram o menor. Use o facet_wrap para quebrar a visualização em dois gráficos. Escolha o objeto geométrico geom_col ou geom_point(). library(WDI) library(dplyr) gdp_growth &lt;- WDI(indicator = &quot;NY.GDP.MKTP.KD.ZG&quot;, start = 2016, end = 2016, extra = TRUE) # Remove regiões - ISO&#39;s com números gdp_growth &lt;- gdp_growth %&gt;% filter(!is.na(region) &amp; region != &quot;Aggregates&quot; &amp; !is.na(NY.GDP.MKTP.KD.ZG)) Utilize o mapa mundi disponível no pacote chropletrMaps e os dados que criamos no exercício anterior para plotar as variações do PIB em um mapa. library(choroplethrMaps) data(&quot;country.map&quot;) # Dados - Crescimento do PIB em 2016 library(WDI) library(dplyr) gdp_growth &lt;- WDI(indicator = &quot;NY.GDP.MKTP.KD.ZG&quot;, start = 2016, end = 2016, extra = TRUE) # Remove regiões - ISO&#39;s com números gdp_growth &lt;- gdp_growth %&gt;% filter(!is.na(region) &amp; region != &quot;Aggregates&quot; &amp; !is.na(NY.GDP.MKTP.KD.ZG)) # Continue fazendo o join entre country.map e gdp_growth # chaves: wb_a3 e iso3c country.map &lt;- country.map %&gt;% left_join(gdp_growth, by = c(&quot;wb_a3&quot; = &quot;iso3c&quot;)) ggplot(country.map, aes(x = long, y = lat, group = group)) + geom_polygon(aes(fill = NY.GDP.MKTP.KD.ZG)) + scale_fill_continuous(&quot;Var. % GDP&quot;) + coord_quickmap() Utilizando o código “NY.GDP.PCAP.KD” e o pacote WDI, crie um gráfico do tipo connected dot plot comparando a renda per capita entre o Brasil e mais cinco países nos anos de 1990 e 2010. "],
["htmlwidgets.html", "13 Visualizações Interativas 13.1 Introdução 13.2 Plotly 13.3 dygraphs 13.4 Leaflet 13.5 Exercícios", " 13 Visualizações Interativas 13.1 Introdução No R, as visualizações interativas são, geralmente, criadas a partir de pacotes que utilizam um framework chamado htmlwidgets. O hmtlwidgets é um pacote/framework que facilita o uso de bibliotecas javascript de visualizações para o ambiente R, sendo possível usá-las no console, no RMarkdown e no Shiny. Basicamente, javascript é uma linguagem client-side, ou seja, aquelas onde o processamento ocorre no lado do cliente. É utilizada, principalmente, para alterar códigos HTML e CSS (estilos) interativamente. O htmlwidgets busca fazer a ponte entre o R e alguma biblioteca javascript de visualização, fazendo com que o usuário do R consiga utilizar essas bibliotecas sem necessariamente precisar escrever uma linha de código em javascript. Apesar de não ser necessário, pode ser que, em algum momento, a fim de customizar uma visualização, seja necessário algum código em javascript, mas isto não será tratado aqui. Abaixo estão listados alguns projetos de visualização de dados em javascript: D3 D3plus Highcharts C3 Leaflet Plotly Existe uma quantidade significativa de pacotes que utilizam o htmlwidgets. Para se ter uma noção, visite esta galeria. O objetivo deste capítulo é fazer uma pequena apresentação sobre alguns pacotes. Cada pacote possui um conjunto de detalhes que torna inviável apresentá-los neste curso. Dessa forma, faremos um breve tour por alguns pacotes, começando com o plotly. 13.2 Plotly É possível ainda dar ainda mais vida aos seus gráficos os transformando em interativos de maneira muito fácil. O pacote plotly, além de ser um ótimo pacote para produzir gráficos interativos em R ou Python, possui uma funcão chamada ggplotly() que transforma um gráfico estático do ggplot2 em interativo. # criando grafico estatico library(gapminder) p &lt;- gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point(aes(color = continent)) p # converter para interativo ggplotly(p) Com apenas uma simples função, temos um gráfico cheio de recursos interativos, como possibilidade de dar zoom em áreas específicos do gráfico e tooltips, que é a pequena tabela de dados que aparece na tela ao passar o mouse em um ponto. Como era de se esperar, as tooltips também podem ser customizadas. A função ggplotly possui um parâmetro chamado tooltip onde pode ser especificada a aesthetic que será mostrada na tooltip. Por padrão, como você viu, a tooltip mostra todas as aesthetics definidas no gráfico. Caso você queira mudar esse aspecto, pode mudar o valor desse parâmetro em ggplotly: # mostrar apenas a aesthetic x, # na qual foi mapeada a variavel de expectativa de vida ggplotly(p, tooltip = &quot;x&quot;) Incrivelmente, dá para ficar ainda melhor. É definindo uma nova aesthetic chamada text, que por padrão não pertence ao ggplot2 mas é usada pelo plotly para construir a tooltip. Essa nova aesthetic, usada em combinação com a função paste0, pode criar tooltips informativas e elegantes. Caso não conheça a função paste0(), ela serve para concatenar vetores de strings em um só, de maneira paralelizada. Segue alguns exemplos: nome &lt;- c(&quot;Lucas&quot;, &quot;Eduardo&quot;, &quot;Flávio&quot;) sobrenome &lt;- c(&quot;Silva&quot;, &quot;Oliveira&quot;, &quot;Dias&quot;) # concatenar os dois vetores acima, juntando nome e sobrenome com espaço no meio paste0(nome, &quot; &quot;, sobrenome) ## [1] &quot;Lucas Silva&quot; &quot;Eduardo Oliveira&quot; &quot;Flávio Dias&quot; Usando essa função, vamos definir a aesthetic de forma que mostre o nome dos países e os valores das variáveis dos eixos: # refazer o grafico, definindo uma nova aesthetic chamada text: p &lt;- gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point(aes( color = continent, text = paste0(&quot;País: &quot;, country, &#39;\\n&#39;, &quot;Expectativa de vida: &quot;, round(lifeExp), &quot;\\n&quot;, &quot;PIB per capita: &quot;, gdpPercap) )) ggplotly(p, tooltip = &quot;text&quot;) 13.3 dygraphs O dygraphs é uma biblioteca para visualizações de séries temporais. Os detalhes do pacote estão disponíveis neste link. Antes dos exemplos, será necessário falar sobre objetos de séries de tempo no R. Para criar um objeto de séries de tempo usaremos a função ts(): ts(data = NA, start = 1, end = numeric(), frequency = 1, deltat = 1, ts.eps = getOption(&quot;ts.eps&quot;), class = , names = ) Os parâmetros relevantes são: data: um vetor ou uma matriz de valores da(s) série(s) de tempo. Um data.frame é transformado automaticamente em uma matriz; start: o período da primeira observação. Pode ser um valor único ou um vetor de dois inteiros. Geralmente, utiliza-se a segunda opção. Por exemplo, Janeiro de 1997: start = c(1997, 1); end: o período da última observação. Similar ao start, porém não é obrigatório; frequency: frequência dos dados. Mensal(12), Trimestral (4), Anual(1) etc. Exemplo de criação de uma série de tempo: x &lt;- rnorm(24, mean = 100, sd = 10) # Trasnformando em série mensal a partir de janeiro de 2010 x &lt;- ts(x, freq = 12, start = c(2010, 1)) plot(x) Outra maneira de declarar um objeto de série de tempo é utilizando a função xts() do pacote de mesmo nome. No entanto, para essa função, precisamos de um vetor ordenado de datas do tipo Date, POSIXct, timeDate, yearmon e yearqtr. library(xts) xts_df &lt;- data.frame(y = rnorm(365, 100, 10)) xts_df$data &lt;- seq.Date(as.Date(&quot;2011-01-01&quot;), length.out = 365, by = &quot;1 day&quot;) xts_df &lt;- xts(x = xts_df[, &quot;y&quot;], order.by = xts_df[, &quot;data&quot;]) head(xts_df) ## [,1] ## 2011-01-01 94.89732 ## 2011-01-02 94.48670 ## 2011-01-03 96.34324 ## 2011-01-04 94.95528 ## 2011-01-05 107.28498 ## 2011-01-06 99.88217 library(dygraphs) lungDeaths &lt;- cbind(mdeaths, fdeaths) dygraph(lungDeaths, main = &quot;Mortes por Doenças Pulmonares - Reino Unido - 1874-1979&quot;, ylab = &quot;Número de Morets&quot;) %&gt;% dySeries(&quot;mdeaths&quot;, color = &quot;blue&quot;, label = &quot;Homens&quot;) %&gt;% dySeries(&quot;fdeaths&quot;, color = &quot;green&quot;, label = &quot;Mulheres&quot;) %&gt;% dyRangeSelector() Aqui fica o código para alterar os padrões dos números e datas: # Alterar rótulos do eixo x e a legenda axlabform &lt;- &quot;function(date, granularity, opts, dygraph) { var months = [&#39;Janeiro&#39;, &#39;Fevereiro&#39;, &#39;Março&#39;, &#39;Abril&#39;, &#39;Maio&#39;, &#39;Junho&#39;, &#39;Julho&#39;, &#39;Agosto&#39;, &#39;Setembro&#39;, &#39;Outubro&#39;, &#39;Novembro&#39;, &#39;Dezembro&#39;]; return months[date.getMonth()] + \\&quot; \\&quot; + date.getFullYear()}&quot; valueform &lt;- &quot;function(ms) { var months = [&#39;Janeiro&#39;, &#39;Fevereiro&#39;, &#39;Março&#39;, &#39;Abril&#39;, &#39;Maio&#39;, &#39;Junho&#39;, &#39;Julho&#39;, &#39;Agosto&#39;, &#39;Setembro&#39;, &#39;Outubro&#39;, &#39;Novembro&#39;, &#39;Dezembro&#39;]; var ms = new Date(ms); return months[ms.getMonth()] + &#39;/&#39; + ms.getFullYear()}&quot; valueformy &lt;- &quot;function(value) { return (Math.round(value * 100)/100).toString() .replace(&#39;.&#39;, &#39;,&#39;) .replace(/\\\\B(?=(\\\\d{3})+(?!\\\\d))/g, &#39;.&#39;)}&quot; dygraph(lungDeaths, main = &quot;Mortes por Doenças Pulmonares - Reino Unido - 1874-1979&quot;, ylab = &quot;Número de Morets&quot;) %&gt;% dySeries(&quot;mdeaths&quot;, color = &quot;blue&quot;, label = &quot;Homens&quot;) %&gt;% dySeries(&quot;fdeaths&quot;, color = &quot;green&quot;, label = &quot;Mulheres&quot;) %&gt;% dyAxis(&quot;y&quot;, valueFormatter = valueformy) %&gt;% dyAxis(&quot;x&quot;, axisLabelFormatter = axlabform, valueFormatter = valueform) %&gt;% dyRangeSelector() 13.4 Leaflet O leaflet é, provavelmente, a principal biblioteca javascript para visualizações interativas de mapas. Mais informações sobre o pacote estão disponíveis neste link. Para iniciarmos uma visualização com leaflet, basta executar o código abaixo. A função addTiles() adiciona uma camada de mapas ao leaflet que foi inicializado. library(dplyr) library(leaflet) leaflet() %&gt;% addTiles() 13.4.1 Primeiro exemplo No primeiro exemplo, incluiremos um marcador na localização do IBPAD. Para isso, obteremos a latitude e a longitude usando a função geocode() do pacote ggmap. Além disso, foi incluída uma coluna chamada popup, que receberá um texto que será mostrado no mapa. library(ggmap) # Pegar Localização do ibpad (Google desatualizado) #loc.ibpad &lt;- geocode(&quot;IBPAD&quot;) loc.ibpad &lt;- data.frame(lon = -47.8838813, lat = -15.8010146) loc.ibpad$popup &lt;- &quot;Estamos aqui! (teoricamente)&quot; leaflet(loc.ibpad) %&gt;% addTiles() %&gt;% addMarkers(lat = ~lat, lng = ~lon, popup = ~popup) 13.4.2 Marcadores No exemplo abaixo, criaremos uma visualização com a posição de algumas empresas exportadoras de Mato Grosso, a partir de dados disponibilizados pelo MDIC. Como a busca da localização foi feita usando o endereço, nem sempre a localização estará perfeitamente correta. No entanto, para exemplificar o uso do pacote, não há problemas. dados.empresas.mt &lt;- read_delim(&#39;dados/empresas_exp_mt.csv&#39;, delim = &quot;;&quot;, locale = locale(encoding = &#39;ISO-8859-1&#39;, decimal_mark = &quot;,&quot;)) leaflet(dados.empresas.mt) %&gt;% addTiles() %&gt;% addMarkers(lat = ~lat, lng = ~lon, popup = ~EMPRESA) Podemos também adicionar outros tipos de marcadores, como círculos: leaflet(dados.empresas.mt) %&gt;% addTiles() %&gt;% addCircleMarkers(lat = ~lat, lng = ~lon, popup = ~EMPRESA, fillOpacity = 0.3) Adicionalmente, é possível agrupar pontos próximos em clusters. leaflet(dados.empresas.mt) %&gt;% addTiles() %&gt;% addCircleMarkers(lat = ~lat, lng = ~lon, popup = ~EMPRESA, fillOpacity = 0.3, clusterOptions = markerClusterOptions()) 13.4.3 Polígonos Também é possível criar-se polígonos a partir de shapefiles. Para isso, o caminho mais fácil é importar um shapefile usando o pacote sf, criar um gráfico estático com geom_sf() e o converter para interativo com plotly::ggplotly(): # baixa library(brmap) # remotes::install_github(&quot;italocegatta/brmap&quot;) mapa_ufs &lt;- brmap::brmap_estado head(mapa_ufs) ## Simple feature collection with 6 features and 4 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -73.99045 ymin: -13.6937 xmax: -46.07095 ymax: 5.271841 ## CRS: EPSG:4674 ## # A tibble: 6 x 5 ## estado_cod regiao_cod estado_nome estado_sigla geometry ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;POLYGON [°]&gt; ## 1 11 1 Rondônia RO ((-62.86662 -7.975868, -62.86017 -7.982323, -62.85336 -7.987563, -62.84506 -7.98653… ## 2 12 1 Acre AC ((-73.18253 -7.335496, -73.05413 -7.381955, -72.90031 -7.437681, -72.7132 -7.505469… ## 3 13 1 Amazonas AM ((-67.32609 2.029714, -67.31682 2.00125, -67.3104 1.966763, -67.3002 1.92667, -67.2… ## 4 14 1 Roraima RR ((-60.20051 5.264343, -60.19828 5.260453, -60.1969 5.257114, -60.19328 5.252951, -6… ## 5 15 1 Pará PA ((-54.95431 2.583692, -54.93542 2.518585, -54.91956 2.499682, -54.91117 2.489685, -… ## 6 16 1 Amapá AP ((-51.1797 4.000081, -51.17784 3.997409, -51.17739 3.994021, -51.17803 3.990301, -5… mapa_estatico &lt;- ggplot(mapa_ufs) + geom_sf(aes(text = estado_nome)) ## Warning: Ignoring unknown aesthetics: text # converter para interativo ggplotly(mapa_estatico, tooltip = &#39;text&#39;) 13.5 Exercícios Usando os pacotes ggmap e leaflet, crie uma visualização marcando cinco localizações de Brasília. Utilizando a base gapminder (library(gapminder)), crie uma visualização usando o pacote plotly. A partir da base economics do pacote ggplot2, escolha uma variável e plote a série histórica utilizando o pacote dygraphs. Entre na galeria de htmlwidgets [neste link], escolha alguma htmlwidget que você tenha achado interessante e replique um exemplo. .ggiraph{ font-size: 8px !important; } .dygraph-axis-label{ font-size: 60% !important; } .leaflet-control{ font-size: small !important; } "],
["rmarkdown.html", "14 RMarkdown 14.1 Usos do RMarkdown 14.2 Estrutura de um RMarkdown 14.3 Renderizando um documento 14.4 Sintaxe 14.5 Opções de Chunk 14.6 Principais Formatos 14.7 Excercícios", " 14 RMarkdown Antes de falarmos sobre o que é RMarkdown, é interessante discutirmos sobre o Markdown. Markdown é uma linguagem de marcação, ou seja, não é uma linguagem de programação. Linguagens de marcação dizem como algo deve ser entendido, mas não têm capacidade de processamento e execução de funções. Por exemplo, HTML é uma linguagem de marcação. Ela apenas diz como uma página web está estruturada, mas não executa nenhum processamento. O Markdown, da mesma forma, apenas informa como um documento está estruturado. No entanto, a vantagem do Markdown é a sua simplicidade e a possibilidade de utilização de uma linguagem comum para a criação de vários tipos de documentos. Por exemplo, um mesmo código Markdown pode ser convertido para HTML, LaTeX (gera pdf’s), docx etc. Para isso, é necessário um conversor, que lê um código em Markdown e, considerando a escolha do output desejado, converte o arquivo para a linguagem desejada. Isto ficará mais claro com os exemplos. E o que é o RMarkdown? Nada mais é do que a possibilidade de executar-se scripts em R (além de outras linguagens) e incorporá-los a um arquivo Markdown (extensão .md). O pacote knitr executará “pedaços” (chunk) de códigos e gerará um arquivo .md com os códigos e seus resultados. Na sequência, o pandoc, que é um conversor, converte-o para a linguagem desejada, gerando os arquivos nos formatos escolhidos (.html, .docx, .pdf, .odt). A figura abaixo ilustra o processo: Processo - RMarkdow Acesse este link para ver os tipos de formatos disponíveis no RMarkdown. É possível gerar documentos no formato Word, pdf formatados para revistas científicas, apresentações, dashboards etc. 14.1 Usos do RMarkdown A seção anterior já deu algumas dicas sobre a utilidade do RMarkdown. Aqui elaboraremos um pouco mais sua funcionalidade. Reprodutibilidade. Isto é importante quando um estudo é realizado. Pode ser que em algum momento após a realização do seu estudo outro analista/pesquisador deseje replicá-lo. Um documento que une o código às explicações pode ser fundamental neste momento. Compartilhamento de informação. É possível que você tenha aprendido a usar um novo pacote e ache que ele pode ser interessante para outros colegas. Com o RMarkdown, você poderá criar um documento com exemplos de uso do pacote, facilmente compartilhável. Documentação de Rotinas. A criação de rotinas para a realização de tarefas repetitivas é cada vez mais comum. No entanto, é importante que haja uma boa documentação da rotina para que você ou outro colega possa entender e dar manutenção à rotina no futuro. Relatórios parametrizados. O RMarkdown facilita a criação de relatórios, inclusive dashboards, em que a estrutura é padrão, mas os dados dependem de um parâmetro. Por exemplo, relatórios de balança comercial por unidade da federação (UF). No caso, a UF seria um parâmetro que variaria de relatório para relatório. 14.2 Estrutura de um RMarkdown --- title: &quot;Primeiro Exemplo para o Curso de R&quot; author: &quot;Paulo&quot; date: &quot;`r format(Sys.time(), &#39;%d de %B de %Y&#39;)`&quot; output: html_document: default pdf_document: fig_caption: yes fig_height: 3.5 fig_width: 7 number_sections: yes lang: pt-br --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) options(OutDec = &quot;,&quot;) ``` # Cabeçalho de primeiro nível ## Cabeçalho de segundo nível ### Cabeçalho de terceiro nível # Hello World Este é um primeiro exemplo de *RMarkdown* para o **Curso de Introdução ao `R`**. ## Outra Seção Vamos executar um código: ```{r, fig.cap=&quot;Exemplo de Figura&quot;, collapse=TRUE} library(ggplot2) x &lt;- rnorm(100) y &lt;- rnorm(100) dados &lt;- data.frame(x, y) ggplot(dados, aes(x = x, y = y)) + geom_point() ``` A média de x é `r mean(x)`. Vamos agora entender qual é a função de cada parte desse código. YAML (Configurações): --- title: &quot;Primeiro Exemplo para o Curso de R&quot; author: &quot;Paulo&quot; date: &quot;23 de abril de 2020&quot; output: html_document: default pdf_document: fig_caption: yes fig_height: 3.5 fig_width: 7 number_sections: yes lang: pt-br --- O YAML é o responsável pelas configurações dos documentos. Basicamente, estamos informando qual é o título do documento, a data de criação, o nome do autor e o tipo de output que desejamos. No exemplo, está definido como output pdf_document e foram adicionadas opções para que as seções fossem numeradas e de tamanho das figuras. Caso quiséssemos um arquivo no formato Word (.docx), o output poderia ser modificado para word_document. Cada formato possui um conjunto de opções disponíveis. Nesse caso, é importante olhar-se a página de cada formato disponível na documentação do RMarkdown. Code Chunks: Os Code Chunks são pedaços de código em R que podem ser executados para gerar resultados que serão incorporados ao documento. Você pode inserir um chunk manualmente ou com o atalho CTRL + ALT + I. Dentro de {} é possível incluir uma série de opções relacionadas à execução do código. Abaixo, falaremos sobre algumas dessas opções. Textos e Markdown: Na figura acima, é mostrado como o texto se mistura com o código de markdown. Esse código markdown, quando convertido, gerará a formatação desejada. Na próxima seção, detalharemos o que cada marcação faz. 14.3 Renderizando um documento Há duas formas de se renderizar um documento .Rmd. A primeira é via função render() do pacote rmarkdown. render(input, output_format = NULL, output_file = NULL, output_dir = NULL, output_options = NULL, intermediates_dir = NULL, runtime = c(&quot;auto&quot;, &quot;static&quot;, &quot;shiny&quot;), clean = TRUE, params = NULL, knit_meta = NULL, envir = parent.frame(), run_pandoc = TRUE, quiet = FALSE, encoding = getOption(&quot;encoding&quot;)) Veja no help a função de cada argumento. Essa função é especialmente importante quando a renderização de um RMarkdown está inserida dentro de uma rotina. Por exemplo, pode-se usar a função render() dentro de um loop para criar-se vários pdf’s a partir de um relatório parametrizado. A outra opção é usando o botão knit, disponível na interface do RStudio. Botão Knit 14.4 Sintaxe Abaixo estão os principais elementos de sintaxe do RMarkdown. Vários são autoexplicativos. Para alguns, faremos alguns comentários: Cabeçalhos: # Cabeçalho de primeiro nível ## Cabeçalho de segundo nível ### Cabeçalho de terceiro nível O resultado, em um documento com output definido como pdf_document, seria: Estilo de texto: *Itálico* e **Negrito** Itálico e Negrito Citações: &gt; Aqui vai um texto para citação Aqui vai um texto para citação Código no texto: `mean(x)` mean(x) Código processado no texto: A opção abaixo é importante para que resultados do R possam ser incorporados diretamente ao texto do documento. Para demonstração, foi necessário darmos um espaço entre a aspa e o código, mas o correto é não haver esse espaço. ` r mean(c(2, 3, 4)) ` 3 Imagens: ![](images/code_chunk.png) ![Título Opcional](images/code_chunk.png) Listas não ordenadas: * Item a * Item b + Subitem b1 + Subitem b2 Item a Item b Subitem b1 Subitem b2 Listas ordenadas: 1. Item 1 2. Item 2 3. Item 3 i. Item 3a ii. Item 3b Item 1 Item 2 Item 3 Item 3a Item 3b Tabelas: --------: indica que a Coluna 1 está alinhada à direita. :------------: indica que a coluna está centralizada. Alguns pacotes do R fornecem funções para a geração de tabelas a partir de data.frames e matrizes. Veja: Coluna 1 | Coluna 2 -------------: | :-------------: 10 | Brasil 20 | China Fonte: MDIC. Coluna 1 Coluna 2 10 Brasil 20 China Fonte: MDIC. -------------------------------------------------------------------- Column 1 Column 2 ------------------------------------------------------ ------------ I want the contents of this cell to fit into one line Word1 Word2 ------------------------------------------------------ ------------ Column 1 Column 2 I want the contents of this cell to fit into one line Word1 Word2 x &lt;- letters[1:3] y &lt;- LETTERS[1:3] knitr::kable(data.frame(x, y), align = &#39;cc&#39;) x y a A b B c C Links: Site do [MDIC](www.mdic.gov.br) Site do MDIC Linha horizontal ou Quebra de Página: *** --- Equação: Modelo linear simples: $y_i = \\alpha + \\beta x_i + e_i$ Modelo linear simples: \\(y_i = \\alpha + \\beta x_i + e_i\\) Equação em Bloco: Modelo linear simples: $$y_i = \\alpha + \\beta x_i + e_i$$ Modelo linear simples: \\[y_i = \\alpha + \\beta x_i + e_i\\] 14.5 Opções de Chunk Os chunks de códigos ({r, ...}) que possuem uma série de opções. Elencaremos aqui as principais. Para a lista completa, veja este link. Opção Valor Padrão Descrição eval TRUE Indica se o código deve ser executado include TRUE Indica se o código deve ser exibido no documento final. Os resultados não serão apresentados. collapse FALSE Indica se o código e os resultados do chunk devem ser colapsados em um bloco único. echo FALSE Indica se o código será exibido no documento final. Os resultados serão apresentados. results markup Se hide, os resultados não serão exibidos. Se hold, os resultados serão exibidos ao final do chunk. Se asis, os resultados não serão formatados, sendo mostrados os resultados “brutos” (código html, tex, …). error TRUE Indica se mensagens de erros serão exibidas. message TRUE Indica se mensagens geradas pelo código serão exibidas. warning TRUE Indica se avisos gerados pelo código serão exibidos. fig.cap NULL Título de gráfico referente ao chunk. fig.height 7 Altura para gráficos criados pelo código (em polegadas). fig.width 7 Largura para gráficos criados pelo código (em polegadas). 14.6 Principais Formatos 14.6.1 HTML A HTML é a linguagem de marcação para construção de páginas web. Assim, se criarmos um documento e escolhermos como opção de output html_document, o resultado será uma página a ser aberta em browsers. Outros formatos do markdown, como flexdashboard e ioslides, também geram páginas html. Cada tipo de formato tem um conjunto de aspectos específicos. Abaixo listamos os principais para html: A aparência e o estilo são definidos por um arquivo no formato css. Isso impõe uma dificuldade adicional para a formatação do documento. O Rmarkdown fornece alguns temas e pacotes que também podem fornecer documentos com alguma formatação de estilo (ver prettydoc); Único formato que aceita htmlwidgets (o próprio nome indica isso). O código markdown incluído no arquivo .Rmd é convertido pelo pandoc, gerando um documento estruturado com código html. Vejamos abaixo o código em RMarkdown: Código RMarkdown para gerar um arquivo html Após o processamento, será gerado o seguinte código html: Exemplo de código HTML Esse código é interpretado pelo navegador e gera o seguinte resultado: Exemplo de formato HTML 14.6.2 PDF Para a criação de PDFs pelo RMarkdown, utiliza-se o LaTeX (pronuncia-se: Lah-tech or Lay-tech), que é um sistema de preparação de documentos muito utilizado pela comunidade científica. Inicialmente, o RMarkdown abstrai para o usuário a necessidade de saber-se essa linguagem. No entanto, como no HTML, se você quiser avançar na estrutura do documento e nos estilos será necessário aprender esta linguagem, pelo menos o suficiente para resolver o seu problema. Entre as vantagens do LaTeX estão: Numeração automática de seções (e os demais níveis) e de equações; Criação automática de legendas com base em arquivos .bib; Facilidade de referências cruzadas no documento. Como no caso do HTML, é possível usar templates. Isso é bastante útil para a criação de artigos científicos, que devem ser padronizados. Além disso, relatórios de instituições podem ser padronizados. Assim, basta que alguém crie um template e os demais poderão criar documentos com a mesma estrutura usando apenas o RMarkdown. LaTeX é uma versão mais amigável de TeX. Ou seja, LaTeX é uma linguagem em um nível maior do que TeX. Como no R, existem diversos pacotes em LaTeX que fornecem comandos para facilitar a edição de alguma parte do documento. Por exemplo: o pacote fancyhdr fornece comandos que facilitam a construção de cabeçalhos e rodapés. Abaixo está um pequeno código para se ter uma noção sobre essa linguagem: \\documentclass{article} \\title{Exemplo 1} \\author{Nome do Autor} \\date{\\today} \\begin{document} \\maketitle \\newpage \\section{Introdução} Aqui vai o texto! \\end{document} Basicamente, o código acima define a classe do documento como artigo, o título, o nome do autor e a data para o dia em que o documento for compilado. Depois, inicia-se o documento, criando o título (inclui título, autor e data), definindo uma quebra de página e a seção introdução. 14.6.2.1 Instalações necessárias Para criar documentos PDF no RMarkdown é preciso ter uma instalação TeX disponível. Para isso, é preciso baixar uma distribuição compatível com o seu sistema operacional. Nesta página estão listadas as distribuições disponíveis por sistema operacional. No Windows é comum usar a distribuição MiKTeX. 14.6.2.2 Exemplo Como no HTML, mostraremos primeiramente o código em RMarkdown: Código RMarkdown para gerar um arquivo html Esse código gerará um arquivo intermediário com a extensão .tex. Este arquivo terá o seguinte código: Código tex gerado Após a compilação, o seguinte documento é gerado: Exemplo de output pdf 14.6.3 Word A geração de word segue a geração dos demais formatos. No entanto, templates apenas funcionam para definir estilos que serão usados no documento. Atualmente, devido a limitações do conversor (pandoc), é difícil ter-se total acesso à formatação do documento. Código RMarkdown para gerar um arquivo word 14.7 Excercícios Crie um RMarkdown com o formato HTML para output. Neste documento, faça um mini tutorial sobre algum pacote que você aprendeu no curso ou outro pacote que você tenha conhecido. Crie as seções adequadamente e, se for o caso, crie tabelas. Crie um novo RMarkdown e explique o processo de criação de um gráfico usando o ggplot2. O ideal é criar um novo gráfico, mas fique livre para utilizar algum exemplo deste material. Utilizando o pacote WDI, crie uma visualização com o pacote dygraphs para a série de renda per capita do Brasil (BRA). Coloque um título no seu documento e faça com que o código não seja apresentado ao leitor. A partir do exemplo anterior, crie um parâmetro chamado country_code no cabeçalho de configuração (yaml). Este parâmetro será usado para selecionar-se o país base para a visualização. Crie um vetor com cinco códigos de países. A partir deste vetor, utilize a função render para criar um arquivo para cada país. library(rpart) library(randomForest) library(ModelMetrics) library(rpart.plot) "],
["modelos.html", "15 Modelos 15.1 Modelo Linear 15.2 Exercícios", " 15 Modelos O objetivo deste capítulo é dar uma visão geral sobre a estrutura de modelos no R. Isto é, quais são as suas funções básicas, como especificar um modelo, recuperar resíduos, realizar predições etc. Esse processo é parte fundamental de análises mais aprofundadas. Os modelos podem ser usados, de maneira não exclusiva, para exploração de dados, geração de predições e análises de causalidade. Por exemplo: Descritivo: relação entre salários, idade, experiência e anos de estudo; Predição: modelo para identificar risco de fraude em uma transação bancária, classificação de imagens, previsão do PIB para o ano que vem; Causalidade: aumento de imposto sobre cigarro e redução no consumo. 15.1 Modelo Linear Vamos introduzir a estrutura de modelos no R a partir de modelos lineares. Trataremos do modelo linear para regressão e do modelo de regressão logística para classificação. O modelo de regressão é utilizado quando a variável de interesse (dependente ou target) é uma variável quantitativa contínua. Por exemplo, salários, preços, notas em um exame etc. Por outro lado, modelos de classificação são utilizados quando a variável de interesse é categórica. Por exemplo: uma pessoa tem ou não tem a doença X, o cliente pagou ou não o cartão de crédito, o usuário X é um robô ou uma pessoa etc. 15.1.1 Regressão Vamos começar com o modelo linear de regressão: \\[y_i = \\beta_0 + \\beta_1 x_{1i} + \\beta_2 x_{2i} + ... + \\beta_k x_{ki} + \\epsilon_i, ~~ i = 1, ..., N,\\] onde \\(y\\) é a variável dependente, \\(x_{k}\\) é a k-ésima variável explicativa, \\(\\beta_k\\) é o parâmetro estimado para k-ésima variável e \\(\\epsilon\\) é o termo de erro. A função lm() estima esse modelo pelo método denominado de mínimos quadrados ordinários (MQO). Antes de exemplificarmos o uso da função, vamos falar sobre a representação simbólica do modelo, ou seja, como especificar o modelo no R. Em geral, o modelo terá argumentos x e y, em que o usuário passa os dados nesses argumentos ou terá a estrutura de fórmula. Por ser o método menos usado no modelo linear, detalharemos a estrutura de fórmula. Na função lm(), é obrigatório passar-se um objeto da classe fórmula, ou algum objeto que possa ser convertido para uma fórmula. Por exemplo: para o modelo linear com duas variáveis (\\(y\\) e \\(x\\)) e uma constante, a fórmula correspondente é: f &lt;- &#39;y ~ x&#39; class(f) ## [1] &quot;character&quot; class(as.formula(f)) ## [1] &quot;formula&quot; Para mostrarmos as possibilidades de uso da fórmula de especificação do modelo, utilizaremos a base mtcars. Esta base traz o consumo de gasolina (mpg) e algumas outras características do veículo. Detalharemos cada variável explicativa conforme elas são usadas. No entanto, você pode olhar o help dessa base: ?mtcars. Para iniciarmos, utilizaremos a variável mpg (miles per galon) e a variável hp (Gross horsepower). data(mtcars) lm(mpg ~ hp, data = mtcars) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars) ## ## Coefficients: ## (Intercept) hp ## 30.09886 -0.06823 Note que não houve especificação de uma constante. Automaticamente, o R inclui a constante. Você pode inclui-la explicitamente ou retirá-la: lm(mpg ~ hp + 1, data = mtcars) lm(mpg ~ hp + 0, data = mtcars) Já temos uma pista de como incluir mais variáveis: basta “adicioná-las” com o símbolo +. Isto é, vamos incluir a variável am - Transmission (0 = automatic, 1 = manual) - no modelo: lm(mpg ~ hp + am, data = mtcars) Se quiséssemos incluir todas as variáveis explicativas: lm(mpg ~ ., data = mtcars) Interações: lm(mpg ~ hp + am + hp:am, data = mtcars) Transformações: lm(log(mpg) ~ log(hp) + am, data = mtcars) ## ## Call: ## lm(formula = log(mpg) ~ log(hp) + am, data = mtcars) ## ## Coefficients: ## (Intercept) log(hp) am ## 5.1196 -0.4591 0.1954 No entanto, algumas transformações podem se confundir com símbolos quem são usados na fórmula. No exemplo abaixo, abstraia os dados e foque no efeito resultante da fórmula: lm(mpg ~ (am + hp)^2 + hp^2, data = mtcars) ## ## Call: ## lm(formula = mpg ~ (am + hp)^2 + hp^2, data = mtcars) ## ## Coefficients: ## (Intercept) am hp am:hp ## 26.6248479 5.2176534 -0.0591370 0.0004029 (am + hp)^2, em termos simbólicos, retorna am + hp + am*hp e hp^2 retorna hp. No caso em que um símbolo não pode ser usado diretamente, este deve ser usado dentro da função I(): lm(mpg ~ hp + I(hp^2), data = mtcars) ## ## Call: ## lm(formula = mpg ~ hp + I(hp^2), data = mtcars) ## ## Coefficients: ## (Intercept) hp I(hp^2) ## 40.4091172 -0.2133083 0.0004208 Variáveis categóricas são convertidas automaticamente para dummies. Por exemplo, vamos adicionar uma variável fictícia chamada cat, que receberá valores a, b e c ao data.frame mtcars: library(tidyverse) mtcars &lt;- mutate(mtcars, cat = sample(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), size = nrow(mtcars), replace = TRUE)) lm(mpg ~ hp + cat, data = mtcars) ## ## Call: ## lm(formula = mpg ~ hp + cat, data = mtcars) ## ## Coefficients: ## (Intercept) hp catb catc ## 30.21184 -0.06691 0.60568 -2.18058 Falta agora discutir os principais argumentos da função lm(): lm(formula, data, subset, weights, na.action, method = &quot;qr&quot;, model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...) O argumento formula já foi discutido anteriormente. É neste argumento que o modelo é especificado. O argumento data recebe (opcionalmente) um data.frame com os dados. O parâmetro data é opcional, porque você pode passar diretamente os vetores de dados. Por exemplo: lm(log(mtcars$mpg) ~ log(mtcars$hp)) ## ## Call: ## lm(formula = log(mtcars$mpg) ~ log(mtcars$hp)) ## ## Coefficients: ## (Intercept) log(mtcars$hp) ## 5.5454 -0.5301 Continuando, há possibilidade de estimar-se o modelo para um subconjunto dos dados, sendo necessário informar um vetor que selecione as observações que entrarão na estimação, no argumento subset. No exemplo que estamos utilizando, suponha que você queira estimar o modelo apenas para os carros automáticos: lm(mpg ~ hp, data = mtcars, subset = (am == 0)) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars, subset = (am == 0)) ## ## Coefficients: ## (Intercept) hp ## 26.62485 -0.05914 lm(mpg ~ hp, data = mtcars, subset = (am == 1)) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars, subset = (am == 1)) ## ## Coefficients: ## (Intercept) hp ## 31.84250 -0.05873 Há também a possibilidade de utilizar-se um vetor de pesos no argumento weight para a estimação de mínimos quadrados ordinários. Para ver-se um sumário dos resultados da estimação, utiliza-se a função summary(): summary(lm(mpg ~ hp, data = mtcars)) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.7121 -2.1122 -0.8854 1.5819 8.2360 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 30.09886 1.63392 18.421 &lt; 2e-16 *** ## hp -0.06823 0.01012 -6.742 1.79e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.863 on 30 degrees of freedom ## Multiple R-squared: 0.6024, Adjusted R-squared: 0.5892 ## F-statistic: 45.46 on 1 and 30 DF, p-value: 1.788e-07 15.1.1.1 Acessando os resultados Além do resumo, é possível acessar uma série de objetos gerados pela função lm(), como coeficientes, resíduos, valores preditos (dentro do conjunto de estimação) etc. Primeiro, vamos listar esses elementos: fit &lt;- lm(mpg ~ hp, data = mtcars) is.list(fit) ## [1] TRUE ls(fit) ## [1] &quot;assign&quot; &quot;call&quot; &quot;coefficients&quot; &quot;df.residual&quot; &quot;effects&quot; &quot;fitted.values&quot; &quot;model&quot; &quot;qr&quot; ## [9] &quot;rank&quot; &quot;residuals&quot; &quot;terms&quot; &quot;xlevels&quot; Como se trata de uma lista, podemos acessar os objetos usando o $. fit$coefficients ## (Intercept) hp ## 30.09886054 -0.06822828 fit$residuals[1:10] ## 1 2 3 4 5 6 7 8 9 10 ## -1.5937500 -1.5937500 -0.9536307 -1.1937500 0.5410881 -4.8348913 0.9170676 -1.4687073 -0.8171741 -2.5067823 Também existem funções para se acessar esses resultados: coefficients(fit) ## (Intercept) hp ## 30.09886054 -0.06822828 residuals(fit)[1:5] ## 1 2 3 4 5 ## -1.5937500 -1.5937500 -0.9536307 -1.1937500 0.5410881 15.1.1.2 Predições No R, para realizar-se predições, utiliza-se a função predict(), que é uma função genérica. Isso significa que os seus argumentos e os valores retornados dependem da classe do objeto que estamos passando. No caso de um objeto da classe lm, é suficiente passar o próprio objeto. Abaixo está um exemplo do seu uso: set.seed(13034) # para replicação # 70% dos dados idx &lt;- sample(nrow(mtcars), size = 0.7*nrow(mtcars), replace = FALSE) train &lt;- mtcars[idx, ] test &lt;- mtcars[-idx, ] # 2 Modelos fit1 &lt;- lm(mpg ~ hp, data = train) fit2 &lt;- lm(mpg ~ hp + am + disp, data = train) # Predições pred1 &lt;- predict(fit1, newdata = test[,-1]) pred2 &lt;- predict(fit2, newdata = test[,-1]) # Comparando Root Mean Square Errors library(ModelMetrics) rmse(pred1, test[, &quot;mpg&quot;]) ## [1] 4.958482 rmse(pred2, test[, &quot;mpg&quot;]) ## [1] 3.568993 15.1.2 Classificação Como já mencionado, quando a variável de interesse é categórica, utilizamos modelos de classificação. O modelo linear mais conhecido é o chamado Regressão Logística. Suponha que queremos prever se uma pessoa irá ou não pagar a fatura do cartão de crédito. Definimos como \\(p\\) a probabilidade da pessoa não pagar e como razão de chance (_odds ratio) o valor \\(\\frac{p}{1-p}\\). A função logit, por sua vez, é definida como: \\[ logit(p) = log\\left(\\frac{p}{1-p}\\right)\\] Sendo \\(y\\) a nossa variável dependente, vamos definir que ela recebe valor 1 se o cliente não paga e 0 caso contrário. Logo, o modelo linear para o logit é definido como: \\[ logit(p(y = 1|X)) = \\beta_0 + \\beta_1 x_{1i} + \\beta_2 x_{2i} + ... + \\beta_k x_{ki}\\] Os parâmetros \\(\\beta&#39;s\\) são obtidos a partir de métodos de otimização em que o objetivo minimizar é uma função de perda determinada. Note que a probabilidade de ocorrência do evento pode ser calculada como: \\[ p(y = 1|X) = \\frac{e^{\\beta_0 + \\beta_1 x_{1i} + \\beta_2 x_{2i} + ... + \\beta_k x_{ki}}}{1 + e^{\\beta_0 + \\beta_1 x_{1i} + \\beta_2 x_{2i} + ... + \\beta_k x_{ki}}}\\] Um detalhe importante sobre a regressão logística é que este modelo se enquadra na classe de modelos lineares generalizados (generalized linear models - glm). Logo, este modelo pode ser estimado a partir da função glm(), escolhendo a família binomial no argumento family. O exemplo a seguir vem do livro An Introduction to Statistical Learning with Application in R. Utilizaremos o pacote ISLR e o conjunto de dados Smarket (?Smarket). Essa base traz informações sobre as variações do índice S&amp;P 500 entre 2001 e 2005. Este índice é composto por 500 ativos negociados na NYSE ou Nasdaq. library(ISLR) data(&quot;Smarket&quot;) head(Smarket) ## Year Lag1 Lag2 Lag3 Lag4 Lag5 Volume Today Direction ## 1 2001 0.381 -0.192 -2.624 -1.055 5.010 1.1913 0.959 Up ## 2 2001 0.959 0.381 -0.192 -2.624 -1.055 1.2965 1.032 Up ## 3 2001 1.032 0.959 0.381 -0.192 -2.624 1.4112 -0.623 Down ## 4 2001 -0.623 1.032 0.959 0.381 -0.192 1.2760 0.614 Up ## 5 2001 0.614 -0.623 1.032 0.959 0.381 1.2057 0.213 Up ## 6 2001 0.213 0.614 -0.623 1.032 0.959 1.3491 1.392 Up A base consiste em nove variáveis. A variável de interesse é Direction e outras cinco variáveis serão usadas como variáveis explicativas ou preditores. Inicialmente, separaremos nossos dados em treino e teste. Como trata-se de um problema de série temporal, utilizaremos a variável Year para separar os dados. train &lt;- Smarket %&gt;% filter(Year &lt;= 2004) %&gt;% select(-Year) test &lt;- Smarket %&gt;% filter(Year == 2005) %&gt;% select(-Year) Agora vamos estimar o modelo: fit &lt;- glm(Direction ~ . -Today, data = train, family = binomial()) summary(fit) ## ## Call: ## glm(formula = Direction ~ . - Today, family = binomial(), data = train) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.302 -1.190 1.079 1.160 1.350 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.191213 0.333690 0.573 0.567 ## Lag1 -0.054178 0.051785 -1.046 0.295 ## Lag2 -0.045805 0.051797 -0.884 0.377 ## Lag3 0.007200 0.051644 0.139 0.889 ## Lag4 0.006441 0.051706 0.125 0.901 ## Lag5 -0.004223 0.051138 -0.083 0.934 ## Volume -0.116257 0.239618 -0.485 0.628 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 1383.3 on 997 degrees of freedom ## Residual deviance: 1381.1 on 991 degrees of freedom ## AIC: 1395.1 ## ## Number of Fisher Scoring iterations: 3 As predições são realizadas com a função predict(), mas com o detalhe de que temos que escolher o tipo de predição. O default, link, passará o logit. Isto é, o valor da predição linear. Já response estimará a probabilidade da observação do evento de interesse. Por fim, terms retorna uma matriz com a predição linear para cada variável explicativa. O nosso interesse é na probabilidade do mercado ter subido, logo, usaremos o tipo response e transformaremos a probabilidade em Up e Down. pred &lt;- predict(fit, test, type = &#39;response&#39;) pred &lt;- ifelse(pred &gt; 0.5, &quot;Up&quot;, &quot;Down&quot;) pred &lt;- factor(pred, levels = c(&quot;Down&quot;, &quot;Up&quot;)) Abaixo avaliamos o erro de classificação, que é de, aproximadamente, 52%. Ou seja, pior do que um chute aleatório. # Taxa de erro ce(test$Direction, pred) ## [1] 0.5198413 Os autores, então, sugerem estimar-se o modelo com apenas duas variáveis. fit &lt;- glm(Direction ~ Lag1 + Lag2, data = train, family = binomial()) pred &lt;- predict(fit, test, type = &#39;response&#39;) pred &lt;- ifelse(pred &gt; 0.5, &quot;Up&quot;, &quot;Down&quot;) pred &lt;- factor(pred, levels = c(&quot;Down&quot;, &quot;Up&quot;)) # Taxa de erro ce(test$Direction, pred) ## [1] 0.4404762 Nesse caso, o modelo acertaria 56% das vezes. 15.1.3 Classificação com modelos baseados em árvores Uma das limitações da regressão logística é que esse método não vai funcionar bem quando não for possível separar as classes linearmente, como no exemplo abaixo: #### atencao: nao precisam se preocupar em reproduzir o codigo abaixo # criar matriz de dados aleatorios mat &lt;- matrix(rnorm(5000, mean = 0, sd = 3), ncol = 2) %&gt;% as.data.frame() # criar elipse que circunda 25% dos pontos el &lt;- car::dataEllipse(mat[, 1], mat[, 2], levels = 0.25, draw = FALSE) # determinar se um ponto da matriz está dentro da elipse mat$ta_dentro &lt;- sp::point.in.polygon(mat[,1], mat[,2], el[,1], el[,2]) mat$ta_dentro &lt;- as.factor(mat$ta_dentro) # construir grafico de pontos, colorindo a elipse ggplot(mat, aes(x = V1, y = V2, color = ta_dentro)) + geom_point() Algoritmos baseados em Decision Trees tentam achar maneiras de criar subsets ou subgrupos do universo dos dados, onde cada subgrupo pertence a um node. O objetivo do modelo é criar nodes onde haja uma distinção clara entre as classes previstas de forma que possa a cada node a probabilidade de um indivíduo pertencer a uma classe. O gráfico abaixo é um exemplo simples e didática de uma árvore de decisão: Figura 15.1: Fonte: Machine Learning Mastery Nesse modelo, que tenta prever o sexo de uma pessoa baseada na altura e no peso, o algoritmo de classificação funciona como uma série de regras SE-NÃO: Se a altura for maior que 180cm, o indivíduo é um homem; Se a altura é menor ou igual a 180cm e o peso é maior que 80kg, o indivíduo é homem; Caso contrário, o indivíduo é mulher. No R, os modelos de Decision Trees são aplicados principalmente pelo pacote rpart. Este tutorial é bem explicativo. 15.1.3.1 Estudo de caso: coleta dos dados e análise exploratória Como dataset de demonstração para a árvore de decisão, usaremos um bem interessante: Tentaremos entender o que leva um empregado a pedir ou não demissão de sua empresa. Entrem neste link, loguem no Kaggle e baixem o dataset para a mesma pasta de trabalho que estão usando no R. O código abaixo mostra como importar e consolidar todos os datasets em um só dataframe: Vejamos como ficou nosso conjunto de dados: glimpse(rh) ## Rows: 4,300 ## Columns: 30 ## $ Age &lt;dbl&gt; 51, 31, 32, 38, 32, 46, 28, 29, 31, 25, 45, 55, 47, 28, 37, 21, 37, 35, 38, 26, 50, 53, 29, 55, 26… ## $ Attrition &lt;fct&gt; No, Yes, No, No, No, No, Yes, No, No, No, No, No, Yes, No, No, No, No, No, No, No, No, No, No, No,… ## $ BusinessTravel &lt;fct&gt; Travel_Rarely, Travel_Frequently, Travel_Frequently, Non-Travel, Travel_Rarely, Travel_Rarely, Tra… ## $ Department &lt;fct&gt; Sales, Research &amp; Development, Research &amp; Development, Research &amp; Development, Research &amp; Developm… ## $ DistanceFromHome &lt;dbl&gt; 6, 10, 17, 2, 10, 8, 11, 18, 1, 7, 17, 14, 1, 1, 1, 3, 1, 7, 8, 1, 8, 11, 16, 1, 9, 5, 1, 2, 4, 7,… ## $ Education &lt;dbl&gt; 2, 1, 4, 5, 1, 3, 2, 3, 3, 4, 2, 4, 1, 3, 3, 2, 3, 4, 3, 4, 4, 4, 4, 4, 3, 1, 2, 3, 3, 3, 1, 3, 4,… ## $ EducationField &lt;fct&gt; Life Sciences, Life Sciences, Other, Life Sciences, Medical, Life Sciences, Medical, Life Sciences… ## $ EmployeeCount &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… ## $ EmployeeID &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29,… ## $ Gender &lt;fct&gt; Female, Female, Male, Male, Male, Female, Male, Male, Male, Female, Male, Female, Male, Male, Male… ## $ JobLevel &lt;dbl&gt; 1, 1, 4, 3, 1, 4, 2, 2, 3, 4, 2, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 3, 1, 2, 3, 1,… ## $ JobRole &lt;fct&gt; Healthcare Representative, Research Scientist, Sales Executive, Human Resources, Sales Executive, … ## $ MaritalStatus &lt;fct&gt; Married, Single, Married, Married, Single, Married, Single, Married, Married, Divorced, Married, S… ## $ MonthlyIncome &lt;dbl&gt; 131160, 41890, 193280, 83210, 23420, 40710, 58130, 31430, 20440, 134640, 79910, 55380, 57620, 2592… ## $ NumCompaniesWorked &lt;dbl&gt; 1, 0, 1, 3, 4, 3, 2, 2, 0, 1, 0, 0, 1, 1, 4, 1, 2, 7, 1, 1, 3, 3, 1, 3, 1, 1, 3, 9, 2, 1, 9, 4, 1,… ## $ Over18 &lt;fct&gt; Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y,… ## $ PercentSalaryHike &lt;dbl&gt; 11, 23, 15, 11, 12, 13, 20, 22, 21, 13, 13, 17, 11, 14, 11, 12, 13, 16, 11, 18, 23, 11, 11, 11, 22… ## $ StandardHours &lt;dbl&gt; 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,… ## $ StockOptionLevel &lt;dbl&gt; 0, 1, 3, 3, 2, 0, 1, 3, 0, 1, 2, 0, 2, 0, 0, 3, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,… ## $ TotalWorkingYears &lt;dbl&gt; 1, 6, 5, 13, 9, 28, 5, 10, 10, 6, 21, 37, 10, 5, 7, 3, 15, 10, 8, 6, 28, 21, 10, 12, 5, 17, 19, 10… ## $ TrainingTimesLastYear &lt;dbl&gt; 6, 3, 2, 5, 2, 5, 2, 2, 2, 2, 2, 2, 4, 2, 2, 3, 2, 5, 5, 3, 2, 2, 2, 2, 3, 2, 2, 3, 5, 6, 2, 2, 4,… ## $ YearsAtCompany &lt;dbl&gt; 1, 5, 5, 8, 6, 7, 0, 0, 9, 6, 20, 36, 10, 5, 5, 3, 5, 7, 8, 6, 10, 5, 10, 10, 5, 17, 1, 2, 3, 5, 3… ## $ YearsSinceLastPromotion &lt;dbl&gt; 0, 1, 0, 7, 0, 7, 0, 0, 7, 1, 4, 4, 9, 0, 0, 1, 0, 6, 7, 1, 1, 1, 0, 0, 3, 5, 0, 1, 0, 0, 1, 7, 2,… ## $ YearsWithCurrManager &lt;dbl&gt; 0, 4, 3, 5, 4, 7, 0, 0, 8, 5, 10, 13, 9, 4, 1, 0, 2, 2, 7, 4, 6, 3, 9, 8, 3, 7, 0, 2, 2, 2, 2, 7, … ## $ EnvironmentSatisfaction &lt;dbl&gt; 3, 3, 2, 4, 4, 3, 1, 1, 2, 2, 3, 4, 1, 4, 3, 4, 1, 2, 1, 3, 1, 3, 2, 2, 1, 4, 4, 4, 1, 4, 3, 3, 4,… ## $ JobSatisfaction &lt;dbl&gt; 4, 2, 2, 4, 1, 2, 3, 2, 4, 1, 4, 1, 2, 4, 4, 3, 4, 2, 1, 2, 2, 3, 4, 4, 1, 4, 3, 4, 2, 4, 1, 2, 2,… ## $ WorkLifeBalance &lt;dbl&gt; 2, 4, 1, 3, 3, 2, 1, 3, 3, 3, 3, 3, 2, 2, 4, 4, 3, 2, 3, 1, 2, 2, 2, 3, 3, 3, 1, 3, 3, 3, 3, 3, 2,… ## $ JobInvolvement &lt;dbl&gt; 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 2, 3, 3, 2, 3, 2, 3, 3, 2, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3,… ## $ PerformanceRating &lt;dbl&gt; 3, 4, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3,… ## $ tempo_medio_trabalho &lt;dbl&gt; 7.373651, 7.718969, 7.013240, 7.193678, 8.006175, 10.796096, 6.923570, 6.725621, 7.236499, 7.08008… Exercícios: - Conheça melhor nossa variável Resposta. Qual o % da base que saiu da empresa (Attrition = Yes). Baseado nessa informação, qual o pior modelo aceitável? - Quais são as 2 variáveis numéricas que mais influenciam a variável resposta EmployeeID? Façam gráficos para investigar essa relação. - Façam o mesmo para duas variáveis categóricas. 15.1.3.2 Criação do modelo Conforme já comentamos, uma etapa essencial de um projeto de modelagem é criar uma separação de conjuntos de treino e teste. ### separacao de conjuntos de treino e teste # salvar em um objeto o tamanho vertical do dataframe n = nrow(rh) # sortear aleatoriamente 70% das linhas do dataframe para compor # o conjunto de treino ind_treino &lt;- sample(1:n, size = n * 0.7) # criar conjunto de treino rh_treino &lt;- rh[ind_treino, ] # criar conjunto de teste a partir da exclusao das linhas do conjunto de treino rh_teste &lt;- rh[-ind_treino, ] A sintaxe para criar um modelo de Decision Tree no R é bem simples, sendo a mesma da Regressão. A única diferença é que a função usada é rpart: # construcao do modelo mod_arvore &lt;- rpart(Attrition ~ . - EmployeeID, data = rh_treino) # visualizar o modelo rpart.plot::prp(mod_arvore, type = 4, extra = 6, fallen.leaves = FALSE, varlen = 0, faclen = 0, box.palette = &quot;auto&quot;) A árvore ficou meio grande, não? Uma boa alternativa nesse caso é salvar o gráfico da árvore em um pdf no computador: # inicializar pdf em branco pdf(&quot;minha_primeira_arvore.pdf&quot;) # preencher pdf com o grafico da arvore rpart.plot::prp(mod_arvore, type = 4, extra = 6, fallen.leaves = FALSE, varlen = 0, faclen = 0, box.palette = &quot;auto&quot;) # destravar a sessao para o pdf ser salvo dev.off() 15.1.3.3 Avaliação do desempenho preditivo de um modelo de classificação: Vamos avaliar a acurácia do modelo: # criar vetor com previsoes ycast &lt;- predict(mod_arvore, newdata = rh_teste, type = &quot;class&quot;) yreal &lt;- rh_teste$Attrition caret::confusionMatrix(data = ycast, reference = yreal, positive = &quot;Yes&quot;, mode = &quot;everything&quot;) ## Confusion Matrix and Statistics ## ## Reference ## Prediction No Yes ## No 1055 139 ## Yes 23 73 ## ## Accuracy : 0.8744 ## 95% CI : (0.8551, 0.892) ## No Information Rate : 0.8357 ## P-Value [Acc &gt; NIR] : 6.138e-05 ## ## Kappa : 0.414 ## ## Mcnemar&#39;s Test P-Value : &lt; 2.2e-16 ## ## Sensitivity : 0.34434 ## Specificity : 0.97866 ## Pos Pred Value : 0.76042 ## Neg Pred Value : 0.88358 ## Precision : 0.76042 ## Recall : 0.34434 ## F1 : 0.47403 ## Prevalence : 0.16434 ## Detection Rate : 0.05659 ## Detection Prevalence : 0.07442 ## Balanced Accuracy : 0.66150 ## ## &#39;Positive&#39; Class : Yes ## Alguns dos conceitos mostrados acima são: Sensitivity ou Recall: De todos os casos que saíram de fato, quantos foram previstas corretamente? Specificity: De todos os casos que não saíram, quantos foram previstos corretamente? Accuracy: De todos os casos, quantos foram previstos corretamente? Precision: De todos os casos previstos que não iriam sair, quantos de fato não saíram? No Information Rate: Também conhecido como Null Error Rate. Qual teria sido a acurácia de um modelo que previsse sempre o caso mais comum? 15.1.3.4 Random Forest O algoritmo de árvore de decisão, apesar de simples, serviu como base para modelos de árvores mais avançados, generalizáveis e flexíveis. Um deles é o Random Forest, que cria um número \\(N\\) de árvores a partir de uma amostragem de um número \\(p2 &lt; p1\\) de colunas, onde \\(p1\\) é a quantidade total de colunas no conjunto de dados. Os dois livros referenciados são ótimas referências sobre esse algoritmo. Criar um modelo de Random Forest no R também é muito fácil. # construir modelo mod_rf &lt;- randomForest::randomForest(Attrition ~ . - EmployeeID, data = rh_treino, importance = TRUE) # obter previsoes a partir do modelo yhat_rf &lt;- predict(mod_rf, newdata = rh_teste, type = &quot;class&quot;) # obter matriz de confusao caret::confusionMatrix(data = yhat_rf, reference = yreal) ## Confusion Matrix and Statistics ## ## Reference ## Prediction No Yes ## No 1078 9 ## Yes 0 203 ## ## Accuracy : 0.993 ## 95% CI : (0.9868, 0.9968) ## No Information Rate : 0.8357 ## P-Value [Acc &gt; NIR] : &lt; 2.2e-16 ## ## Kappa : 0.9742 ## ## Mcnemar&#39;s Test P-Value : 0.007661 ## ## Sensitivity : 1.0000 ## Specificity : 0.9575 ## Pos Pred Value : 0.9917 ## Neg Pred Value : 1.0000 ## Prevalence : 0.8357 ## Detection Rate : 0.8357 ## Detection Prevalence : 0.8426 ## Balanced Accuracy : 0.9788 ## ## &#39;Positive&#39; Class : No ## Um recurso muito interessante do modelo Random Forest é o cálculo da importância de cada variável, que é medido com base no impacto de realizar permutações de cada variável explanatória usada no modelo sobre alguma métrica de acurácia. O gráfico abaixo mostra que a maior perda de perfomance preditiva ocorre quando a variável de tempo no trabalho é permutada aleatoriamente: varImpPlot(mod_rf, # especificar que a medida de importancia é a perda media de acuracia type = 1, main = &quot;Importância de cada variável explan. no modelo de RF&quot;) O modelo Random Forest também pode ser usado de maneira probabilística, ou seja, mudando o output para a probabilidade de ele ser sim: yhat_rf_prob &lt;- predict(mod_rf, newdata = rh_teste, type = &quot;prob&quot;) head(yhat_rf_prob) ## No Yes ## 1 0.970 0.030 ## 2 0.990 0.010 ## 3 0.988 0.012 ## 4 0.984 0.016 ## 5 0.984 0.016 ## 6 0.206 0.794 15.2 Exercícios Utilizando a base de dados Wage, do pacote ISLR, crie dois data.frames: um com 70% dos dados (train) e outro com 30% (test). Crie um novo objeto chamado fit, a partir da função lm(). Use como variável dependente (\\(Y\\)) a coluna logwage e escolha outras três colunas como variáveis explicativas. Compute as predições desse modelo utilizando a função predict(). Compute a raiz do erro quadrático médio (rmse). (ModelMetrics::rmse()). Inclua outras variáveis e cheque o que acontece com o rmse. library(ISLR) library(ModelMetrics) idx &lt;- sample(nrow(Wage), 0.7 * nrow(Wage)) train &lt;- Wage[idx, ] test &lt;- Wage[idx, ] fit &lt;- lm(logwage ~ age + education + maritl + health_ins, data = train) pred &lt;- predict(fit, test) rmse(actual = test$logwage, predicted = pred) ## [1] 0.2777082 "],
["revisão-titanic.html", "16 Revisão - Titanic 16.1 Objetivo 16.2 Carregando os Dados 16.3 Manipulando os dados 16.4 Idade 16.5 Visualizações 16.6 Modelo Preditivo", " 16 Revisão - Titanic 16.1 Objetivo O objetivo deste capítulo é fazer uma breve revisão do que foi ensinado no curso. Para isso, será utilizada a base disponível no pacote titanic. É esperado que o aluno consiga realizar manipulações nos dados, visualizações e um modelo preditivo. A análise deve ser demonstrada em um documento criado com o RMarkdown. 16.2 Carregando os Dados library(tidyverse) library(titanic) data(&quot;titanic_train&quot;) # Base de treinamento head(titanic_train) ## PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare ## 1 1 0 3 Braund, Mr. Owen Harris male 22 1 0 A/5 21171 7.2500 ## 2 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Thayer) female 38 1 0 PC 17599 71.2833 ## 3 3 1 3 Heikkinen, Miss. Laina female 26 0 0 STON/O2. 3101282 7.9250 ## 4 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35 1 0 113803 53.1000 ## 5 5 0 3 Allen, Mr. William Henry male 35 0 0 373450 8.0500 ## 6 6 0 3 Moran, Mr. James male NA 0 0 330877 8.4583 ## Cabin Embarked ## 1 S ## 2 C85 C ## 3 S ## 4 C123 S ## 5 S ## 6 Q Variável Descrição PassengerId Identificador do Passageiro Survived Variável de indicadora de sobrevivência (0 = Não Sobreviveu, 1 = Sobreviveu) Pclass Classe do passageiro Name Nome do passageiro Sex Sexo do passageiro Age Idade do passageiro SibSp Número de irmãos/cônjuge no navio Parch Número de pais e filhos no navio Ticket Número da passagem Fare Preço da passagem Cabin Código da cabine Embarked Porto de embarque 16.3 Manipulando os dados Nesta seção, faremos alguma alteração nos dados. Veja o summary do dataset. summary(titanic_train) ## PassengerId Survived Pclass Name Sex Age SibSp ## Min. : 1.0 Min. :0.0000 Min. :1.000 Length:891 Length:891 Min. : 0.42 Min. :0.000 ## 1st Qu.:223.5 1st Qu.:0.0000 1st Qu.:2.000 Class :character Class :character 1st Qu.:20.12 1st Qu.:0.000 ## Median :446.0 Median :0.0000 Median :3.000 Mode :character Mode :character Median :28.00 Median :0.000 ## Mean :446.0 Mean :0.3838 Mean :2.309 Mean :29.70 Mean :0.523 ## 3rd Qu.:668.5 3rd Qu.:1.0000 3rd Qu.:3.000 3rd Qu.:38.00 3rd Qu.:1.000 ## Max. :891.0 Max. :1.0000 Max. :3.000 Max. :80.00 Max. :8.000 ## NA&#39;s :177 ## Parch Ticket Fare Cabin Embarked ## Min. :0.0000 Length:891 Min. : 0.00 Length:891 Length:891 ## 1st Qu.:0.0000 Class :character 1st Qu.: 7.91 Class :character Class :character ## Median :0.0000 Mode :character Median : 14.45 Mode :character Mode :character ## Mean :0.3816 Mean : 32.20 ## 3rd Qu.:0.0000 3rd Qu.: 31.00 ## Max. :6.0000 Max. :512.33 ## 16.3.1 Variável Survived A variável Survived está definida como indicadora (1 ou 0). Como será usada em um modelo de classificação, é interessante que esta variável seja transformada ou que seja criada uma nova variável, tornando-a uma variável do tipo factor ou character. titanic_train &lt;- titanic_train %&gt;% mutate(Survived = factor(Survived)) levels(titanic_train$Survived) &lt;- c(&quot;Não&quot;, &quot;Sim&quot;) 16.3.2 Variável Name Na variável Name, percebe-se que os passageiros possuíam títulos: Mr., Miss., Mrs. etc. Seria interessante criar-se uma nova variável que possua apenas o título do passageiro. Para isto, precisaremos usar a função str_extract() do pacote stringr e um pouco de regex. titanic_train &lt;- titanic_train %&gt;% mutate(title = str_extract(tolower(Name), &#39;[a-z]{1,}\\\\.&#39;)) Quais são os títulos mais comuns? titanic_train %&gt;% group_by(title) %&gt;% summarise(n = n()) %&gt;% arrange(-n) ## # A tibble: 17 x 2 ## title n ## &lt;chr&gt; &lt;int&gt; ## 1 mr. 517 ## 2 miss. 182 ## 3 mrs. 125 ## 4 master. 40 ## 5 dr. 7 ## 6 rev. 6 ## 7 col. 2 ## 8 major. 2 ## 9 mlle. 2 ## 10 capt. 1 ## 11 countess. 1 ## 12 don. 1 ## 13 jonkheer. 1 ## 14 lady. 1 ## 15 mme. 1 ## 16 ms. 1 ## 17 sir. 1 Faremos mais uma modificação. Pode ser interessante agregarmos os títulos menos frequentes em uma única categoria. classes_de_interesse &lt;- c(&quot;mr.&quot;, &quot;miss&quot;, &quot;mrs.&quot;, &quot;master.&quot;) titanic_train &lt;- titanic_train %&gt;% mutate(title = ifelse(title %in% classes_de_interesse, title, &quot;other&quot;)) 16.4 Idade Como vimos no summary, há alguns valores faltantes para a variável Age. Alguns modelos conseguem tratar internamente os missing values, outros não. Para o modelo que usaremos, não podemos ter missings. Assim, podemos eliminar essas observações ou atribuir-lhes um valor. Utilizaremos a segunda opção. Para imputação, existem inúmeros métodos, podendo até mesmo ser utilizado o modelo auxiliar. Aqui, vamos inserir a mediana da idade, separando por título e sexo. titanic_train &lt;- titanic_train %&gt;% group_by(Sex, title) %&gt;% mutate(Age = ifelse(is.na(Age), median(Age, na.rm = TRUE), Age)) summary(titanic_train$Age) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.42 22.00 30.00 29.43 35.00 80.00 16.4.1 Exercício Crie mais duas variáveis: 16.5 Visualizações Abaixo, criamos algumas visualizações iniciais. Explore as demais variáveis da base e mostre relações com a variável Survived. library(hrbrthemes) theme_set(theme_ipsum(base_size = 10)) ggplot(titanic_train, aes(x = Age)) + geom_histogram(boundary = 0, fill = &quot;#223e63&quot;, bins = 20) ggplot(titanic_train, aes(x = Age, fill = Survived)) + geom_histogram(boundary = 0, bins = 20) + facet_wrap(~ Survived) + scale_fill_ipsum() ggplot(titanic_train, aes(x = Sex, fill = Survived)) + geom_bar() + labs(title = &quot;Número de passageiros por Sexo&quot;, y = &quot;Contagem&quot;, x = &quot;Sexo&quot;) titanic_train %&gt;% group_by(Sex, Survived) %&gt;% summarise(n = n()) %&gt;% group_by(Sex) %&gt;% mutate(prop = n/sum(n) * 100) %&gt;% ggplot(aes(x = Sex, y = prop, fill = Survived)) + geom_col() + labs(title = &quot;Proporção de Sobreviventes por Sexo&quot;, y = &quot;%&quot;, x = &quot;Sexo&quot;) + scale_fill_ipsum(&quot;Sobreviveu&quot;) Crie mais duas visualizações: 16.6 Modelo Preditivo Crie um modelo preditivo a partir da base de treinamento. Para isso, selecione um subconjunto de variáveis que você utilizará como input (features). Divida a base de treinamentos em duas: 70% para treinamento e 30% para a validação. Utilize a função glm() para estimar um modelo de regressão logística. Calcule a acurácia do modelo. Treine o modelo na base titanic_train completa. Realize predições para base titanic_test. "],
["referências-1.html", "17 Referências", " 17 Referências Seguem algumas referências de estudo. "]
]
