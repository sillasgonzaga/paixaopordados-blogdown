[
["index.html", "Ciência de Dados com R - Introdução Prefácio", " Ciência de Dados com R - Introdução Saulo Guerra, Paulo Felipe de Oliveira, Robert McDonnell e Sillas Gonzaga 07/08/2020 Prefácio Este livro foi criado por Saulo Guerra, Paulo Felipe e Sillas Gonzaga para o curso Introdução à Ciência de Dados com R, oferecido pelo IBPAD. Para a construção deste livro, foi utilizado o Bookdown. Em alguns trechos, este livro foi baseado no material produzido por Robert McDonnell. "],
["introdução.html", "1 Introdução 1.1 O que é Ciência de Dados? 1.2 Workflow da Ciência de Dados 1.3 Linguagens para Ciência de dados 1.4 O que é R e por que devo aprendê-lo? 1.5 RStudio 1.6 Buscando Ajuda 1.7 Exercícios", " 1 Introdução 1.1 O que é Ciência de Dados? Trata-se de um termo cada vez mais utilizado para designar uma área de conhecimento voltada para o estudo e a análise de dados, onde busca-se extrair conhecimento e criar novas informações. É uma atividade interdisciplinar, que concilia principalmente duas grandes áreas: Ciência da Computação e Estatística. A Ciência de Dados vem sendo aplicada como apoio em diferentes outras áreas de conhecimento, tais como: Medicina, Biologia, Economia, Comunicação, Ciências Políticas etc. Apesar de não ser uma área nova, o tema vem se popularizando cada vez mais, graças à explosão na produção de dados e crescente dependência dos dados para a tomada de decisão. 1.2 Workflow da Ciência de Dados Não existe apenas uma forma de estruturar e aplicar os conhecimentos da Ciência de Dados. A forma de aplicação varia bastante conforme a necessidade do projeto ou do objetivo que se busca alcançar. Neste curso, usaremos um modelo de workflow bastante utilizado, apresentado no livro R for Data Science (Hadley Wickham 2017). Figura 1.1: Workflow básico para ciência de dados Esse workflow propõe basicamente os seguintes passos: Carregar os dados; Limpar os dados; Transformar, visualizar e modelar (fase exploratória); Comunicar o resultado. 1.3 Linguagens para Ciência de dados Para a aplicação dessas atividades comuns da Ciência de Dados, é necessário dominar-se as ferramentas corretas. Existem diversas linguagens/ferramentas: R, Python, SAS, SQL, Matlab, Stata, Aplicações de BI etc. Cabe ao cientista de dados avaliar qual é a ferramenta mais adequada para alcançar seus objetivos. 1.4 O que é R e por que devo aprendê-lo? R é uma linguagem de programação estatística que vem passando por diversas evoluções e se tornando cada vez mais uma linguagem de amplos objetivos. Podemos entender o R também como um conjunto de pacotes e ferramentas estatísticas, munido de funções que facilitam sua utilização, desde a criação de simples rotinas até análises de dados complexas, com visualizações bem acabadas. Segue alguns motivos para aprender-se R: É completamente gratuito e de livre distribuição; Curva de aprendizado bastante amigável, sendo muito fácil de se aprender; Enorme quantidade de tutoriais e ajuda disponíveis gratuitamente na internet; É excelente para criar rotinas e sistematizar tarefas repetitivas; Amplamente utilizado pela comunidade acadêmica e pelo mercado; Quantidade enorme de pacotes, para diversos tipos de necessidades; Ótima ferramenta para criar relatórios e gráficos. Apenas para exemplificar-se sua versatilidade, este eBook e os slides das aulas foram todos feitos em R. 1.5 RStudio O R puro se apresenta como uma simples “tela preta” com uma linha para inserir comandos. Isso é bastante assustador para quem está começando e bastante improdutivo para quem já faz uso intensivo da ferramenta. Felizmente existe o RStudio, ferramenta auxiliar que usaremos durante todo o curso. Entenda o RStudio como uma interface gráfica com diversas funcionalidades que melhoram ainda mais o uso e aprendizado do R. Na prática, o RStudio facilita muito o dia a dia de trabalho. Portanto, desde já, ao falarmos em R, falaremos automaticamente no RStudio. Essa é a “cara” do RStudio: Figura 1.2: RStudio se divide em 4 partes Repare que, além da barra de menu superior, o RStudio é divido em quatro partes principais: Editor de Código No editor de código, você poderá escrever e editar os scripts. Script nada mais é do que uma sequência de comandos/ordens que serão executados em sequência pelo R. O editor do RStudio oferece facilidades como organização dos comandos, “auto-complete” de comandos, destaque da sintaxe dos comandos etc. Provavelmente é a parte que mais utilizaremos. Console É no console que o R mostrará a maioria dos resultados dos comandos. Também é possível escrever os comandos diretamente no console, sem o uso do editor de código. É muito utilizado para testes e experimentos rápidos. Um uso rápido do console é, por exemplo, chamar a ajuda do R usando o comando ? (isso mesmo, a interrogação é um comando!). Voltaremos a falar deste comando ? em breve. Environment e History No Environment ficarão guardados todos os objetos que forem criados na sessão do R. Entenda sessão como o espaço de tempo entre o momento em que você inicia o R e o momento em que finaliza. Neste período, tudo que você faz usa memória RAM e o processador do computador. E na aba History, como você deve imaginar, o RStudio cria um histórico de comandos utilizados. Files, Plots, Packages, Help e Viewer. Nesta janela, estão várias funcionalidades do RStudio. Na aba Files, você terá uma navegação de arquivos do seu computador. Também será possível definir o diretório de trabalho (você também pode definir diretamente no código, mas isto será tratado posteriormente), ou seja, o R entende o seu diretório de trabalho como ponto de partida para localizar arquivos que sejam chamados no script. 4.1 Aba Plots A aba Plots trará os gráficos gerados, possibilitando a exportação para alguns formatos diferentes, como .png e .pdf. 4.2 Aba Packages Em Packages estão listados os pacotes instalados. Você pode verificar quais estão carregados e, caso necessário, poderá carregar algum pacote necessário para a sua análise. Também é possível instalar e atualizar pacotes. Novamente, tudo isto é possível fazer diretamente no código. 4.3 Aba Help O nome já diz tudo. Esta aba será bastante utilizada por você. Saber usar o help é fundamental para evitar desperdício de tempo. Os usuários de R, em geral, são bastante solícitos. Entretanto, uma olhadinha rápida no help pode evitar que você gaste “créditos” desnecessariamente. 4.4 Aba Viewer Por fim, o Viewer. Esta funcionalidade é utilizada para visualizar-se localmente conteúdo web. O gráfico da figura está na aba Viewer porque é uma visualização em javascript, que pode ser adicionada a documentos html gerados usando o RMarkdown ou em aplicações web com suporte do Shiny. 1.6 Buscando Ajuda Independentemente do seu nível de conhecimento, sempre haverá a necessidade de buscar ajuda. Ou seja, saber procurar ajuda é essencial para aprimorar seus conhecimentos em Ciência de Dados. Segue algumas dicas de como buscar ajuda para sanar dúvidas e resolver problemas em R: Sempre procure em inglês. Apesar da comunidade R em língua portuguesa ser bem grande, a de língua inglesa é maior ainda. É muito provável que seus problemas e dúvidas já tenham sido sanados; Explore bem o help do próprio R; Conheça e aprenda a usar o stack overflow, a maior comunidade de ajuda técnica da internet. Se mesmo explorando todas as dicas acima não conseguir resolver seu problema, procure por fóruns específicos. Se você for realizar uma pergunta em algum fórum ou site de perguntas e respostas, é importante atentar para alguns pontos que deverão ser informados para que fique mais fácil de alguém te ajudar: Versão do R que está usando; Sistema operacional; Forneça um exemplo replicável; Veja se a sua dúvida já não foi abordada em outro tópico. 1.7 Exercícios Digite o comando R.Version(). O que acontece? Encontre o item de menu Help e descubra como identificar a versão do seu RStudio. Encontre o item de menu Cheatsheets. O que este menu oferece? Entre no site https://stackoverflow.com e digite [r] na caixa de busca. O que acontece? References "],
["conceitos-básicos.html", "2 Conceitos Básicos 2.1 Console 2.2 Scripts 2.3 Objetos (Variáveis) 2.4 Funções 2.5 Pacotes 2.6 Boas práticas 2.7 Tidyverse 2.8 Exercícios", " 2 Conceitos Básicos ## ── Attaching packages ────────────────────────────────────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.3 ✓ dplyr 1.0.1 ## ✓ tidyr 1.1.0 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.4.0 ## ── Conflicts ───────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Entenda o R como uma grande calculadora científica cheia de botões, mas, ao invés de apertar os botões, você irá escrever os comandos. Ou seja, aprender R significa se familiarizar com os comandos e saber quando usá-los. Todos os comandos são baseados em inglês e seus nomes, normalmente, dão dicas a respeito do seu uso. 2.1 Console O console é uma das quatro partes principais do RStudio. Lá é onde você vai digitar suas ordens (comandos) e também é onde o R vai “responder”. Para que o R possa interpretar corretamente, será necessário que você conheça a sintaxe da linguagem e a escrita correta dos comandos. Olhando para o console, você verá o símbolo &gt;. Este símbolo indica a linha onde você deve inserir os comandos. Clique nesse símbolo para posicionar o cursor na linha de comandos e digite seu primeiro comando em R: 2 * 3. Digite e aperte enter. Você verá o seguinte resultado: ## [1] 6 Além de outras funcionalidades mais interessantes, o R é como uma grande calculadora científica, como apontado anteriormente. Para entender melhor esse conceito, vamos exercitar um pouco o console de comandos. Digite um por um os seguintes comandos e acompanhe os resultados: 7 * 9 + 2 * 6 2.5 * 4 (50 + 7)/(8 * (3 - 5/2)) 3 ^ 4 Repare que, na medida em que executa os comandos, o R vai respondendo. Esse é o comportamento básico do console, muito utilizado para obter-se resultados rápidos de comandos específicos. Uma funcionalidade importante é o fato de que o R guarda um histórico dos últimos comandos executados e para acessá-los basta apertar a seta para cima no teclado. 2.2 Scripts Enquanto no console seus comandos são executados na medida em que você os “envia” com a ordem enter, em um script você ordena a execução de uma sequência de comandos, escritos previamente, um seguido do outro. Esses scripts são escritos no editor de códigos do RStudio. Para entender melhor, localize o editor de códigos no RStudio e copie os mesmos comandos anteriores, executados no console. No editor de códigos, a ordem para a execução dos comandos não é o enter, para executá-los, clique em Source, no canto superior direito da área do editor de códigos. Repare bem, pois há uma setinha escura que revelará duas opções de Source (execução do script): Source, e Source With Echo. A diferença entre as duas opções é que a primeira executa mas não exibe as respostas no console, já a segunda executa mostrando as respostas no mesmo. A primeira opção será útil em outros casos de scripts muito grandes, ou em situações nas quais não convenha “poluir” o console com um monte de mensagens. Há um atalho de teclado para o Source: ctrl + shift + enter. Aprenda este atalho, pois você usará muito mais o editor de códigos do que o console para executar os passos da sua análise. Agora posicione o cursor do mouse com um clique em apenas um dos comandos do seu script. Em seguida, clique no ícone Run, também no canto superior na área do editor de códigos. Repare que, dessa vez, o R executou apenas um comando, aquele que estava na linha selecionada. Esse tipo de execução também é bastante útil, mas esteja atento, pois é muito comum que comandos em sequência dependam da execução de comandos anteriores para funcionarem corretamente. Há, também, um atalho de teclado para o Run: ctrl + enter. Este é outro comando importante de ser lembrado, pois é muito importante e será muito utilizado. 2.2.1 Salvando Scripts Ao digitar seus comandos no console, o máximo que você consegue recuperar são os comandos imediatamente anteriores, usando a seta para cima. Já no editor de códigos, existe a possibilidade de salvar os seus scripts para continuar em outro momento ou em outro computador, preservar trabalhos passados ou compartilhar seus códigos com a equipe. Um script em R tem a extensão (terminação) .R. Se você tiver o RStudio instalado e der dois clicks em um arquivo com extesão .R, o windows abrirá esse arquivo diretamente no RStudio. Ainda utilizando os comandos digitados no editor de códigos, vá em File &gt; Save, escolha um local e um nome para seu script e confirme no botão Save. Lembre-se sempre de ser organizado na hora de armazenar os seus arquivos. Utilize pastas para os diferentes projetos e dentro delas escolha nomes explicativos para os seus trabalhos. Para salvar mais rapidamente, utilize o atalho ctrl + S. 2.2.2 Comentários de Código Ao utilizar o símbolo # em uma linha, você está dizendo para o R ignorar aquela linha, pois trata-se de um comentário. Clique na primeira linha do seu script, aperte enter para adicionar uma linha a mais e digite # Meu primeiro comentário de código!. Repare que a cor do comentário é diferente. Execute novamente seu script com o Source (ctrl + shift + enter) e veja que nada mudou na execução. A título de experimento, retire o símbolo # e mantenha o texto do comentário. Execute novamente. O R tenta interpretar essa linha como comando e já que ele não consegue entendê-lo, exibe uma mensagem de erro no console. O símbolo de comentário também é muito útil para suprimir linhas de código que servem para testar determinados comportamentos. Para exemplificar, adicione o símbolo # em qualquer uma das linhas com as operações e veja que ela não será mais executada, será ignorada, pois foi entendida pelo R como um simples comentário de código. 2.3 Objetos (Variáveis) Para que o R deixe de ser uma simples calculadora, será necessário aprender, dentre outras coisas, o uso de variáveis. Se você tem alguma noção de estatística, provavelmente já tem a intuição do que é uma variável para uma linguagem de programação. No contexto do R, vamos entender variável como um objeto, ou seja, como uma estrutura predefinida que vai “receber” algum valor. Utilizando uma linguagem mais técnica, objeto (ou variável) é um pequeno espaço na memória do seu computador onde o R armazenará um valor ou o resultado de um comando, utilizando um nome que você mesmo definiu. Conhecer os tipos de objetos do R é fundamental. Para criar objetos, utiliza-se o símbolo &lt;-. Este provavelmente é o símbolo que você mais verá daqui para frente. Execute, no console ou no editor de códigos, o seguinte comando x &lt;- 15. Pronto, agora o nome x representa o valor 15. Para comprovar, execute apenas o nome do objeto x, o R mostrará o conteúdo dele. A partir de então, você poderá utilizar esse objeto como se fosse o valor 15. Experimente os seguintes resultados: x + 5 x * x / 2 2 ^ x y &lt;- x / 3 Dê uma boa lida em Dicas e boas práticas para um código organizado para aprender a organizar seus objetos e funções da melhor maneira possível. Todos os objetos que você criar estarão disponíveis na aba Environment. O RStudio possui a função auto complete. Digite as primeiras letras de um objeto (ou função) que você criou e, em seguida, use o atalho ctrl + barra de espaço. O RStudio listará tudo que começar com essas letras no arquivo. Selecione algum item e aperte enter para escrevê-lo no editor de códigos. 2.4 Funções Entenda função como uma sequência de comandos preparados para serem usados de forma simples e, assim, facilitar sua vida. Funções são usadas para tudo que você possa imaginar: cálculos mais complexos, estatística, análise de dados, manipulação de dados, gráficos, relatórios etc. Assim que você o instala, o R já vem configurado com várias funções prontas para uso. A partir de agora, chamaremos esse conjunto de funções que já vem por padrão com o R de R Base. Claro que as funções do R base não serão suficientes para resolver todos os problemas que você encontrará pela frente. Nesse sentido, o R também mostra outro ponto forte. Você pode instalar conjuntos extras de funções específicas de maneira muito simples: usando pacotes. Funcões do R base. raiz.quadrada &lt;- sqrt(16) # função para calcular raiz quadrada round(5.3499999, 2) # função para arredondamento Uma função tem dois elementos básicos: o nome e o(s) parâmetro(s) (também chamados de argumentos). Por exemplo, a função log(10) possui o nome log() e apenas um parâmetro, que é o número que você quer calcular o log. Já a função round() possui dois parâmetros, o número que você quer arredondar e a quantidade de dígitos para arredondamento. Quando você usa uma função, você pode informar os parâmetros de duas formas: sequencialmente, sem explicitar o nome dos parâmetros, ou na ordem que quiser, explicitando o nome dos parâmetros. Veja o exemplo a seguir: round(5.3499999, 2) # o mesmo que: round(digits = 2, x = 5.3499999) Para saber como informar os parâmetros corretamente, utilize o comando ? (ou coloque o cursor no nome da função e pressione F1) para ver a documentação de funções, ou seja, conhecer para que serve, entender cada um dos seus parâmetros e ver exemplos de uso. ?round ?rnorm ??inner_join # procurar ajuda de funções que não estão &quot;instaladas&quot; ainda Vale comentar que é possível informar objetos nos parâmetros das funções. x &lt;- 3.141593 round(x, 3) ## [1] 3.142 ceiling(x) ## [1] 4 floor(x) ## [1] 3 Observe algumas das principais funções para estatísticas básicas no R: Função R Estatística sum() Soma de valores mean() Média var() Variância median() Mediana summary() Resumo Estatístico quantile() Quantis 2.5 Pacotes Como dito antes, pacotes são conjuntos extras de funções que podem ser instalados além do R base. Existem pacotes para auxiliar as diversas linhas de estudo que você possa imaginar: estatística, econometria, ciências sociais, medicina, biologia, gráficos, machine learning etc. Caso você precise de algum pacote específico, procure no Google pelo tema que necessita. Você encontrará o nome do pacote e o instalará normalmente. Nesse link você pode ver uma lista de todos os pacotes disponíveis no repositório central. Além desses, ainda existe a possibilidade de instalar-se pacotes “não oficiais”, que ainda não fazem parte de um repositório central. Para instalar um pacote, execute o seguinte comando: install.packages(&quot;dplyr&quot;) # instala um famoso pacote de manipulação de dados Uma vez instalado, esse pacote estará disponível para uso sempre que quiser, sem a necessidade de instalá-lo novamente. Mas, sempre que iniciar um código novo, você precisará carregá-lo na memória. Para isso, use o seguinte comando: library(dplyr) Para instalar um pacote, você precisa informar o nome entre aspas install.packages(“readxl”), caso contrário o pacote não funcionará. Porém, para carregar o pacote em memória, você pode usar com ou sem aspas library(readxl) ou library(“readxl”), ambas as formas funcionam. 2.6 Boas práticas Rapidamente você perceberá que quanto mais organizado e padronizado mantiverem-se os seus códigos, melhor para você e para sua equipe. Existem dois guias de boas práticas bastante famosos na comunidade do R. Um sugerido pelo Hadley Wickham e outro por uma equipe do Google. Dentre as dicas de boa prática, algumas são mais importantes, como, por exemplo: não use acentos e caracteres especiais. Outro ponto importante: o R não aceita variáveis que comecem com números. Você pode até usar números no meio do nome, mas nunca começar com números. O principal de tudo é: seja qual for o padrão que você preferir, escolha apenas um padrão e seja consistente a ele. Guia sugerido Hadley Wickham: http://adv-r.had.co.nz/Style.html _ Guia sugerido pelo Google: https://google.github.io/styleguide/Rguide.xml 2.7 Tidyverse Como já dito, eventualmente as funções do R base não são suficientes ou simplesmente não fornecem a maneira mais fácil de resolver-se um problema. Neste curso utilizaremos o Tidyverse: uma coleção de pacotes R cuidadosamente desenhados para atuarem no workflow comum da ciência de dados: importação, manipulação, exploração e visualização de dados. Uma vez carregado, esse pacote disponibiliza todo o conjunto de ferramentas de outros pacotes importantes: ggplot2, tibble, tidyr, readr, purrr e dplyr. Oportunamente, detalharemos cada um deles. O Tidyverse foi idealizado, dentre outros responsáveis, por Hadley Wickham, um dos maiores colaboradores da comunidade R. Se você não o conhece e pretende seguir em frente com o R, certamente ouvirá falar muito dele. Recomendamos segui-lo nas redes sociais para ficar por dentro das novidades do Tidyverse. Para instalar os pacotes do Tidyverse, rode o comando abaixo: install.packages(&quot;tidyverse&quot;) 2.8 Exercícios Quais as principais diferenças entre um script e o console? Digite ?dplyr. O que acontece? E se digitar ??dplyr? Para que serve esse pacote? Para que serve a função rnorm()? Quais os seus parâmetros/atributos? Para que serve a função rm()? Quais os seus parâmetros/atributos? Rode o comando abaixo para instalar os pacotes usados neste livro: install.packages(c(&quot;broom&quot;, &quot;choroplethrMaps&quot;, &quot;DT&quot;, &quot;dygraphs&quot;, &quot;gapminder&quot;, &quot;ggrepel&quot;, &quot;ggthemes&quot;, &quot;gridExtra&quot;, &quot;hrbrthemes&quot;, &quot;htmltools&quot;, &quot;ISLR&quot;, &quot;jsonlite&quot;, &quot;knitr&quot;, &quot;leaflet&quot;, &quot;ModelMetrics&quot;, &quot;nycflights13&quot;, &quot;plotly&quot;, &quot;RColorBrewer&quot;, &quot;readxl&quot;, &quot;scales&quot;, &quot;titanic&quot;, &quot;viridis&quot;, &quot;WDI&quot;, &quot;xtable&quot;, &quot;xts&quot;, &quot;sf&quot;) "],
["lendo-os-dados.html", "3 Lendo os dados 3.1 Tipos de Estrutura dos Dados 3.2 Definindo o Local dos Dados 3.3 Pacote para leitura dos dados", " 3 Lendo os dados Após o entendimento do problema/projeto que se resolverá com a ciência de dados, será necessário fazer com que o R leia os dados. Seja lá qual for o assunto do projeto, é muito importante garantir uma boa fonte de dados. Dados ruins, inconsistentes, não confiáveis ou mal formatados podem gerar muita dor de cabeça para o analista. 3.1 Tipos de Estrutura dos Dados Os dados podem ser apresentados de diversas maneiras, não existe um padrão único para a difusão ou divulgação. Sendo assim, é bom que você esteja preparado para lidar com qualquer tipo de estrutura de dados. Existem diversas classificações de estrutura de dados. Vamos utilizar uma classificação mais generalista, que diz respeito a como os dados são disponibilizados. Sendo assim, podemos classificar os dados em três grandes tipos quanto à sua estrutura ou forma: dados estruturados, semiestruturados e não estruturados. 3.1.1 Dados Estruturados Talvez seja o formato de dados mais fácil de se trabalhar no R. São conjuntos de informações organizadas em colunas (atributos, variáveis, features etc.) e linhas (registros, itens, observações etc.). São dados mais comumente encontrados diretamente em bancos de dados, arquivos com algum tipo de separação entre as colunas, Excel, arquivos com campos de tamanho fixo etc. 3.1.2 Dados Não Estruturados Como o nome diz, estes dados não têm uma estrutura previsível, ou seja, cada conjunto de informações possui uma forma única. Geralmente são arquivos com forte teor textual. Não podemos dizer que são dados “desorganizados”, e sim que são organizações particulares para cada conjunto de informações. Podemos citar, por exemplo, e-mails, twitters, PDF, imagens, vídeos etc. Analisar este tipo de dado é muito mais complexo e exige conhecimento avançado em mineração de dados. Apesar disso, é o tipo de dado mais abundante na realidade. 3.1.3 Dados Semiestruturados São dados que também possuem uma organização fixa, porém não seguem o padrão de estrutura linha/coluna, ou seja, seguem uma estrutura mais complexa e flexível, geralmente hierárquica, estruturada em tags ou marcadores de campos. São exemplos de arquivos semiestruturados: JSON, XML, HTML, YAML etc. É o formato mais usado em troca de dados pela internet e consumo de Application programming interface (API). Dados semiestruturados, algumas vezes, são facilmente transformados em dados estruturados. 3.2 Definindo o Local dos Dados O R sempre trabalha com o conceito de Working direcotry, ou seja, uma pasta de trabalho onde vai “ler” e “escrever” os dados. Para verificar qual o diretório que o R está “olhando”, utilize o seguinte comando: getwd() #Get Working Directory Para informar ao R em qual pasta ele deve ler os arquivos, utilizamos o comando set working directory, que muda o diretório padrão do R para leitura e escrita: setwd(&#39;D:/caminho/do/arquivo/arquivo.csv&#39;) 3.3 Pacote para leitura dos dados O R base possui funções para a leitura dos principais tipos de arquivos. Um outro pacote específico, e muito bom para isso, é o readr. O Tidyverse inclui o carregamento do pacote readr. Diversos tipos de arquivos são lidos pelo R: Comma-Separated Values (csv), Excel, arquivos separados por delimitadores, colunas de tamanho fixo etc. Talvez o tipo de arquivo (estruturado) mais comum hoje em dia, e mais simples de trabalhar, seja o csv. Começaremos a importar dados com arquivos csv. library(tidyverse) # já carrega o readr #ou library(readr) Vamos importar um csv chamado senado.csv. Caso o arquivo esteja em seu working directory (getwd()), basta passar apenas o nome do arquivo para a função, caso contrário será necessário informar todo o caminho até a pasta do arquivo. Usamos o read_csv() para fazer isso. senado &lt;- read_csv(&quot;senado.csv&quot;) Esse comando carrega o conteúdo do arquivo senado.csv para o objeto (variável) senado. Após o carregamento, começaremos a investigar o conteúdo desse objeto: os dados. O head e o tail são funções para ver a “cabeça” e o “rabo” dos seus dados, ou seja, o começo e o fim das amostras. É muito importante sempre observar a “aparência” dos dados após o carregamento. Essa observação ajuda a identificar erros básicos no carregamento, possibilitando ajustes o quanto antes, impedindo que esses erros se propaguem. Repare que na primeira linha temos os nomes das colunas e, em seguida, os registros. head(senado) ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2007001 PRS0002/… FLEXA RIBEI… S PSDB FALSE PA 2 11 0 85.5 S ## 2 2007001 PRS0002/… ARTHUR VIRG… S PSDB FALSE AM 2 11 0 85.5 S ## 3 2007001 PRS0002/… FLAVIO ARNS N PT TRUE PR 2 11 0 85.5 S ## 4 2007001 PRS0002/… MARCELO CRI… S PRB TRUE RJ 2 11 0 85.5 S ## 5 2007001 PRS0002/… JOAO DURVAL N PDT FALSE BA 2 11 0 85.5 S ## 6 2007001 PRS0002/… PAULO PAIM S PT TRUE RS 2 11 0 85.5 S ## # … with 3 more variables: VoteType &lt;dbl&gt;, Content &lt;chr&gt;, Round &lt;dbl&gt; tail(senado) ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2010027 PLC0010/… EDISON LOBAO S PMDB TRUE MA 1 1 0 97.8 S ## 2 2010027 PLC0010/… EDUARDO SUP… S PT TRUE SP 1 1 0 97.8 S ## 3 2010027 PLC0010/… JARBAS VASC… N PMDB TRUE PE 1 1 0 97.8 S ## 4 2010027 PLC0010/… MARISA SERR… S PSDB FALSE MS 1 1 0 97.8 S ## 5 2010027 PLC0010/… EPITACIO CA… S PTB FALSE MA 1 1 0 97.8 S ## 6 2010027 PLC0010/… INACIO ARRU… S PCdoB TRUE CE 1 1 0 97.8 S ## # … with 3 more variables: VoteType &lt;dbl&gt;, Content &lt;chr&gt;, Round &lt;dbl&gt; Outros comandos muito importantes para começar a investigar os dados são o str(), o class() e o summary(). Para verificar o tipo do objeto, ou seja, sua classe, utilize: class(senado) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Já para verificar a estrutura do objeto, ou seja, seus campos (quando aplicável), insira: str(senado) #STRucture ## tibble [9,262 × 15] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ VoteNumber : num [1:9262] 2007001 2007001 2007001 2007001 2007001 ... ## $ SenNumber : chr [1:9262] &quot;PRS0002/07&quot; &quot;PRS0002/07&quot; &quot;PRS0002/07&quot; &quot;PRS0002/07&quot; ... ## $ SenatorUpper: chr [1:9262] &quot;FLEXA RIBEIRO&quot; &quot;ARTHUR VIRGILIO&quot; &quot;FLAVIO ARNS&quot; &quot;MARCELO CRIVELLA&quot; ... ## $ Vote : chr [1:9262] &quot;S&quot; &quot;S&quot; &quot;N&quot; &quot;S&quot; ... ## $ Party : chr [1:9262] &quot;PSDB&quot; &quot;PSDB&quot; &quot;PT&quot; &quot;PRB&quot; ... ## $ GovCoalition: logi [1:9262] FALSE FALSE TRUE TRUE FALSE TRUE ... ## $ State : chr [1:9262] &quot;PA&quot; &quot;AM&quot; &quot;PR&quot; &quot;RJ&quot; ... ## $ FP : num [1:9262] 2 2 2 2 2 2 2 2 2 2 ... ## $ Origin : num [1:9262] 11 11 11 11 11 11 11 11 11 11 ... ## $ Contentious : num [1:9262] 0 0 0 0 0 0 0 0 0 0 ... ## $ PercentYes : num [1:9262] 85.5 85.5 85.5 85.5 85.5 ... ## $ IndGov : chr [1:9262] &quot;S&quot; &quot;S&quot; &quot;S&quot; &quot;S&quot; ... ## $ VoteType : num [1:9262] 1 1 1 1 1 1 1 1 1 1 ... ## $ Content : chr [1:9262] &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and Information Technology (CCT).&quot; &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and Information Technology (CCT).&quot; &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and Information Technology (CCT).&quot; &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and Information Technology (CCT).&quot; ... ## $ Round : num [1:9262] 1 1 1 1 1 1 1 1 1 1 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. VoteNumber = col_double(), ## .. SenNumber = col_character(), ## .. SenatorUpper = col_character(), ## .. Vote = col_character(), ## .. Party = col_character(), ## .. GovCoalition = col_logical(), ## .. State = col_character(), ## .. FP = col_double(), ## .. Origin = col_double(), ## .. Contentious = col_double(), ## .. PercentYes = col_double(), ## .. IndGov = col_character(), ## .. VoteType = col_double(), ## .. Content = col_character(), ## .. Round = col_double() ## .. ) Para verificar estatísticas básicas do objeto (média, mediana, quantis, mínimo, máximo etc.), quando aplicáveis: summary(senado) ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition ## Min. :2007001 Length:9262 Length:9262 Length:9262 Length:9262 Mode :logical ## 1st Qu.:2008006 Class :character Class :character Class :character Class :character FALSE:3480 ## Median :2009003 Mode :character Mode :character Mode :character Mode :character TRUE :5782 ## Mean :2008483 ## 3rd Qu.:2009048 ## Max. :2010027 ## State FP Origin Contentious PercentYes IndGov ## Length:9262 Min. :1.000 Min. : 1.000 Min. :0.00000 Min. : 2.174 Length:9262 ## Class :character 1st Qu.:2.000 1st Qu.: 1.000 1st Qu.:0.00000 1st Qu.: 66.667 Class :character ## Mode :character Median :2.000 Median : 2.000 Median :0.00000 Median : 96.078 Mode :character ## Mean :1.878 Mean : 2.595 Mean :0.01781 Mean : 82.509 ## 3rd Qu.:2.000 3rd Qu.: 4.000 3rd Qu.:0.00000 3rd Qu.: 98.148 ## Max. :2.000 Max. :11.000 Max. :1.00000 Max. :100.000 ## VoteType Content Round ## Min. :1.000 Length:9262 Min. :1.000 ## 1st Qu.:1.000 Class :character 1st Qu.:1.000 ## Median :1.000 Mode :character Median :1.000 ## Mean :1.159 Mean :1.358 ## 3rd Qu.:1.000 3rd Qu.:2.000 ## Max. :2.000 Max. :4.000 Acontece que nem sempre o separador será o ;, típico do csv. Nesse caso será necessário usar o read_delim(), onde você pode informar qualquer tipo de separador. Outro tipo de arquivo bastante comum é o de colunas com tamanho fixo (fixed width), também conhecido como colunas posicionais. Nesse caso, será necessário usar o read_fwf() informando o tamanho de cada coluna. Exemplo: #lendo arquivo com delimitador # read_delim(&#39;caminho/do/arquivo/arquivo_separado_por#.txt&#39;, delim = &#39;#&#39;) #lendo arquivo de coluna fixa #coluna 1 de tamanho 5, coluna 2 de tamanho 2 e coluna 3 de tamanho 10 read_fwf(&#39;caminho/do/arquivo/arquivo_posicional.txt&#39;, col_positions = fwf_widths(c(5, 2, 10), c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;))) No capítulo a seguir exploraremos melhor os tipos de objetos mais comuns no R. Referências: Site do pacote readr com mais exemplos Site do pacote readxl, usado para ler arquivos Excel "],
["manipulando-os-dados.html", "4 Manipulando os dados 4.1 Tipos de Variáveis e Colunas 4.2 Estruturas de Controle de Fluxo 4.3 Manipulações com R base 4.4 Pacote dplyr 4.5 Exercícios", " 4 Manipulando os dados Neste capítulo, usaremos estes pacotes: library(nycflights13) library(tidyverse) Após obter uma boa fonte de dados, e carregá-los para poder trabalhá-los no R, você certamente precisará realizar algumas limpezas e manipulações para que os dados estejam no ponto ideal para as fases finais de uma análise: execução de modelos econométricos, visualizações de dados, tabelas agregadas, relatórios etc. A realidade é que, na prática, os dados nunca estarão do jeito que você de fato precisa. Portanto, é fundamental dominar técnicas de manipulação de dados. Entendamos a manipulação de dados como o ato de transformar, reestruturar, limpar, agregar e juntar os dados. Para se ter uma noção da importância dessa fase, alguns estudiosos da área de Ciência de Dados costumam afirmar que 80% do trabalho é encontrar uma boa fonte de dados, limpar e preparar os dados, sendo que os 20% restantes seriam o trabalho de aplicar modelos e realizar alguma análise propriamente dita. 80% of data analysis is spent on the process of cleaning and preparing the data (Dasu and Johnson, 2003). Data preparation is not just a first step, but must be repeated many over the course of analysis as new problems come to light or new data is collected (Hadley Wickham). 4.1 Tipos de Variáveis e Colunas Existem diversos tipos de objetos, e cada tipo “armazena” um conteúdo diferente, desde tabelas de dados recém-carregados a textos, números, ou simplesmente a afirmação de verdadeiro ou falso (Boleano). inteiro &lt;- 928 outro.inteiro &lt;- 5e2 decimal &lt;- 182.93 caracter &lt;- &#39;exportação&#39; logico &lt;- TRUE outro.logico &lt;- FALSE Repare nas atribuições acima. Usaremos a função class() para ver o tipo de cada uma: class(inteiro) ## [1] &quot;numeric&quot; class(outro.inteiro) ## [1] &quot;numeric&quot; class(decimal) ## [1] &quot;numeric&quot; class(caracter) ## [1] &quot;character&quot; class(logico) ## [1] &quot;logical&quot; class(outro.logico) ## [1] &quot;logical&quot; Esses são alguns dos tipos básicos de objetos/variáveis no R. Para valores inteiros ou decimais, numeric , character para valores textuais e logical para valores lógicos (verdadeiro ou falso). Existe também o tipo integer, que representa apenas números inteiros, sem decimais, porém, na maioria das vezes, o R interpreta o integer como numeric, pois o integer também é um numeric. Além dos tipos básicos, existem também os tipos “complexos”, que são vector, array, matrix, list, data.frame e factor. Data frame é, provavelmente, o tipo de dado complexo mais utilizado em R. É nele que você armazena conjuntos de dados estruturados em linhas e colunas. Um data frame possui colunas nomeadas, sendo que todas as colunas possuem a mesma quantidade de linhas. Imagine o dataframe como uma tabela. class(senado) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; dim(senado) ## [1] 9262 15 Percebeu o termo tbl no output acima? Significa tibble(), que, conforme o próprio pacote chamado tibble descreve, corresponde a uma moderna implementação da estrutura data.frame. A classe tibble não possui algumas deficiências da classe data.frame, por isso a usaremos sempre que possui. É muito simples transformar um data.frame em tibble. # carregando um dataset pronto do R data(iris) # verificando a classe class(iris) ## [1] &quot;data.frame&quot; # transformando para tibble iris_tbl &lt;- as_tibble(iris) # verificando a classe do novo objeto class(iris_tbl) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Imprima no seu console os dois objetos e note a diferença: print(iris) print(iris_tbl) Outro tipo que já utilizamos bastante até agora, mas que não foi detalhado, é o vector, ou vetor. Vetores são sequências unidimensionais de valores de um mesmo tipo: #faça as seguintes atribuições vetor.chr &lt;- c(&#39;tipo1&#39;, &#39;tipo2&#39;, &#39;tipo3&#39;, &#39;tipo4&#39;) vetor.num &lt;- c(1, 2, 5, 8, 1001) vetor.num.repetidos &lt;- c(rep(2, 50)) #usando funcão para repetir números vetor.num.sequencia &lt;- c(seq(from=0, to=100, by=5)) #usando função para criar sequências vetor.logical &lt;- c(TRUE, TRUE, TRUE, FALSE, FALSE) ##veja o conteúdo das variáveis vetor.chr ## [1] &quot;tipo1&quot; &quot;tipo2&quot; &quot;tipo3&quot; &quot;tipo4&quot; vetor.num ## [1] 1 2 5 8 1001 vetor.num.repetidos ## [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 vetor.num.sequencia ## [1] 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 vetor.logical ## [1] TRUE TRUE TRUE FALSE FALSE Para a criação de vetores, usamos a função de combinação de valores c() (combine). Esta função vai combinar todos os parâmetros em um único vetor. Lembre-se: vetores são sequências que contêm apenas um tipo de dado. Conhecendo o data.frame e o vector, você será capaz de entender como os dois se relacionam. Cada coluna de um data frame é um vetor. Um data frame pode ter colunas de diferentes tipos, mas cada coluna só pode ter registros de um único tipo. Ficará mais claro a seguir. Veja como se cria um data.frame: #cria-se diferentes vetores nome &lt;- c(&#39;João&#39;, &#39;José&#39;, &#39;Maria&#39;, &#39;Joana&#39;) idade &lt;- c(45, 12, 28, 31) adulto &lt;- c(TRUE, FALSE, TRUE, TRUE) uf &lt;- c(&#39;DF&#39;, &#39;SP&#39;, &#39;RJ&#39;, &#39;MG&#39;) #cada vetor é uma combinação de elementos de um MESMO tipo de dados #sendo assim, cada vetor pode ser uma coluna de um data.frame clientes &lt;- data.frame(nome, idade, adulto, uf) clientes ## nome idade adulto uf ## 1 João 45 TRUE DF ## 2 José 12 FALSE SP ## 3 Maria 28 TRUE RJ ## 4 Joana 31 TRUE MG str(clientes) ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ nome : Factor w/ 4 levels &quot;Joana&quot;,&quot;João&quot;,..: 2 3 4 1 ## $ idade : num 45 12 28 31 ## $ adulto: logi TRUE FALSE TRUE TRUE ## $ uf : Factor w/ 4 levels &quot;DF&quot;,&quot;MG&quot;,&quot;RJ&quot;,..: 1 4 3 2 4.1.1 Conversões de tipos de variáveis Quando é feito o carregamento de algum arquivo de dados no R, ele tenta “deduzir” os tipos de dados de cada coluna. Nem sempre essa dedução sai correta e, eventualmente, você precisará converter de um tipo para o outro. O R tem algumas funções para fazer essas conversões. class(&quot;2015&quot;) ## [1] &quot;character&quot; as.numeric(&quot;2015&quot;) ## [1] 2015 class(55) ## [1] &quot;numeric&quot; as.character(55) ## [1] &quot;55&quot; class(3.14) ## [1] &quot;numeric&quot; as.integer(3.14) ## [1] 3 as.numeric(TRUE) ## [1] 1 as.numeric(FALSE) ## [1] 0 as.logical(1) ## [1] TRUE as.logical(0) ## [1] FALSE O R também tenta “forçar a barra”, às vezes, para te ajudar. Quando você faz uma operação entre dois tipos diferentes, ele tenta fazer algo chamado coerção de tipos, ou seja, ele tenta converter os dados para que a operação faça sentido. Caso o R não consiga fazer a coerção, ele vai mostrar uma mensagem de erro. Experimente os comandos a seguir no console: 7 + TRUE 2015 &gt; &quot;2016&quot; &quot;2014&quot; &lt; 2017 # em alguns casos a coerção irá falhar ou dar resultado indesejado 6 &gt; &quot;100&quot; &quot;6&quot; &lt; 5 1 + &quot;1&quot; Recomendamos fortemente que sempre se realize as conversões explicitamente com as funções apropriadas ao invés de confiar na coerção do R, a não ser que se tenha certeza do resultado. 4.1.2 Outros tipos de variáveis Existem outros tipos de variáveis bastante utilizados. Citaremos alguns deles, pois nesse curso utilizaremos muito pouco os demais tipos. Tipo Descrição Dimensões Homogêneo vector Coleção de elementos simples. Todos os elementos precisam ser do mesmo tipo básico de dado 1 Sim array Coleção que se parece com o vector, mas é multidimensional n Sim matrix Tipo especial de array com duas dimensões 2 Sim list Objeto complexo com elementos que podem ser de diferentes tipos 1 Não data.frame Tipo especial de lista, onde cada coluna é um vetor de apenas um tipo e todas as colunas têm o mesmo número de registros. É o tipo mais utilizado para se trabalhar com dados 2 Não factor Tipo especial de vector, que só contém valores predefinidos (levels) e categóricos (characters). Não é possível adicionar novas categorias sem criação de novos levels 1 Não 4.1.3 Valores faltantes e o ‘NA’ Em casos onde não existe valor em uma coluna de uma linha, o R atribui NA. É muito comum lidar com conjuntos de dados que tenham ocorrências de NA em alguns campos. É importante saber o que se fazer em casos de NA, e nem sempre a solução será a mesma: varia de acordo com as suas necessidades. Em algumas bases de dados, quem gera o dado atribui valores genéricos como 999 ou até mesmo um “texto vazio”, ' '. Neste caso, você provavelmente terá que substituir esses valores “omissos” por NA. Imputar dados em casos de NA é uma das várias estratégias para lidar-se com ocorrência de missing no conjunto dos dados. Seguem algumas funções úteis para lidar-se com NA: A função summary() pode ser usada para averiguar a ocorrência de NA. A função is.na() realiza um teste para saber se a variável/coluna possui um valor NA. retorna TRUE se for NA e FALSE se não for. A função complete.cases() retorna TRUE para as linhas em que todas as colunas possuem valores válidos (preenchidos) e FALSE para as linhas em que, em alguma coluna, existe um NA. Ou seja, esta função diz quais são as linhas (amostras) completas em todas as suas características (campos). Algumas funções possuem o argumento na.rm, ou semelhantes, para desconsiderar NA no cálculo. É o caso da função mean() ou sum(). Por exemplo: data(&quot;airquality&quot;) # carrega uma base de dados pré-carregada no R summary(airquality) # verificando ocorrência de NA ## Ozone Solar.R Wind Temp Month Day ## Min. : 1.00 Min. : 7.0 Min. : 1.700 Min. :56.00 Min. :5.000 Min. : 1.0 ## 1st Qu.: 18.00 1st Qu.:115.8 1st Qu.: 7.400 1st Qu.:72.00 1st Qu.:6.000 1st Qu.: 8.0 ## Median : 31.50 Median :205.0 Median : 9.700 Median :79.00 Median :7.000 Median :16.0 ## Mean : 42.13 Mean :185.9 Mean : 9.958 Mean :77.88 Mean :6.993 Mean :15.8 ## 3rd Qu.: 63.25 3rd Qu.:258.8 3rd Qu.:11.500 3rd Qu.:85.00 3rd Qu.:8.000 3rd Qu.:23.0 ## Max. :168.00 Max. :334.0 Max. :20.700 Max. :97.00 Max. :9.000 Max. :31.0 ## NA&#39;s :37 NA&#39;s :7 is.na(airquality$Ozone) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [18] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE ## [35] TRUE TRUE TRUE FALSE TRUE FALSE FALSE TRUE TRUE FALSE TRUE TRUE FALSE FALSE FALSE FALSE FALSE ## [52] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE ## [69] FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE ## [86] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [103] TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE ## [120] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [137] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE 4.2 Estruturas de Controle de Fluxo Para auxiliar no processo de manipulação de dados, você eventualmente precisará de algumas técnicas e estruturas de controle de fluxo. Estruturas para controle de fluxo nada mais são do que loops e condições. São estruturas fundamentais para qualquer linguagem de programação. 4.2.1 If e Else A estrutura condicional é algo bastante intuitivo. A estrutura de if (se) e else (então) usa os operadores lógicos apresentados anteriormente. Se a condição do if() for verdadeira, executa-se uma tarefa específica, se for falsa, executa-se uma tarefa diferente. A estrutura parece algo do tipo: if( variavel &gt;= 500 ) { #executa uma tarefa se operação resultar TRUE } else { #executa outra tarefa se operação resultar FALSE } Da mesma forma, existe uma função que gera o mesmo resultado, o ifelse() (e uma do pacote dplyr, o if_else()). ifelse(variavel &gt;= 500, &#39;executa essa tarefa se TRUE&#39;, &#39;executa outra se FALSE&#39;) Existe uma diferença entre as duas formas de “if else”: a estrutura if() {} else {} só opera variáveis, uma por uma, já a estrutura ifelse() opera vetores, ou seja, consegue fazer a comparação para todos os elementos. Isso faz com que a forma if() {} else {} seja mais utilizada para comparações fora dos dados, com variáveis avulsas. Já a estrutura ifelse() é mais usada para comparações dentro dos dados, com colunas, vetores e linhas. Qualquer uma dessas estruturas pode ser “aninhada”, ou seja, encadeada. Por exemplo: a &lt;- 9823 if(a &gt;= 10000) { b &lt;- &#39;VALOR ALTO&#39; } else if(a &lt; 10000 &amp; a &gt;= 1000) { b &lt;- &#39;VALOR MEDIO&#39; } else if(a &lt; 1000) { b &lt;- &#39;VALOR BAIXO&#39; } b ## [1] &quot;VALOR MEDIO&quot; Ou ainda: a &lt;- 839 c &lt;- ifelse(a &gt;= 10000, &#39;VALOR ALTO&#39;, ifelse(a &lt; 10000 &amp; a &gt;= 1000, &#39;VALOR MEDIO&#39;, &#39;VALOR BAIXO&#39;)) c ## [1] &quot;VALOR BAIXO&quot; 4.2.2 Loops Trata-se de um dos conceitos mais importantes de qualquer linguagem de programação, em R não é diferente. Loops (ou laços) repetem uma sequência de comando quantas vezes você desejar, ou até que uma condição aconteça, variando-se alguns aspectos entre uma repetição e outra. Supondo que você tenha que ler 400 arquivos de dados que você obteve de um cliente. Você vai escrever 400 vezes a funcão de leitura? Nesse caso, basta fazer um loop para percorrer todos os arquivos da pasta e ler um por um com a função de leitura. 4.2.2.1 For O for() é usado para realizar uma série de ordens para uma determinada sequência ou índices (vetor). Sua sintaxe é bem simples: for(i in c(1, 2, 3, 4, 5)) { print(i^2) } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 ## [1] 25 Para cada valor (chamamos esse valor de i) dentro do vetor c(1, 2, 3, 4, 5), execute o comando print(i^2). Qualquer outro comando dentro das chaves { ... } seria executado para cada valor do vetor. Para entendermos melhor, vamos repensar o exemplo das séries usando o for(). lista.de.arquivos &lt;- list.files(&#39;dados/dados_loop&#39;) #lista todos os arquivos de uma pasta is.vector(lista.de.arquivos) ## [1] TRUE for(i in lista.de.arquivos) { print(paste(&#39;Leia o arquivo:&#39;, i)) #exemplo: read_delim(i, delim = &quot;|&quot;) } ## [1] &quot;Leia o arquivo: arquivo1.txt&quot; ## [1] &quot;Leia o arquivo: arquivo10.txt&quot; ## [1] &quot;Leia o arquivo: arquivo11.txt&quot; ## [1] &quot;Leia o arquivo: arquivo12.txt&quot; ## [1] &quot;Leia o arquivo: arquivo13.txt&quot; ## [1] &quot;Leia o arquivo: arquivo2.txt&quot; ## [1] &quot;Leia o arquivo: arquivo3.txt&quot; ## [1] &quot;Leia o arquivo: arquivo4.txt&quot; ## [1] &quot;Leia o arquivo: arquivo5.txt&quot; ## [1] &quot;Leia o arquivo: arquivo6.txt&quot; ## [1] &quot;Leia o arquivo: arquivo7.txt&quot; ## [1] &quot;Leia o arquivo: arquivo8.txt&quot; ## [1] &quot;Leia o arquivo: arquivo9.txt&quot; Também é possível utilizar loop com if. No exemplo a seguir, queremos ver todos os números de 1 a 1000 que são divisíveis por 29 e por 3 ao mesmo tempo. Para isso, utilizaremos o operador %%, que mostra o resto da divisão. Se o resto for zero, é divisível. for(i in 1:1000){ if((i %% 29 == 0) &amp; (i %% 3 == 0)){ print(i) } } ## [1] 87 ## [1] 174 ## [1] 261 ## [1] 348 ## [1] 435 ## [1] 522 ## [1] 609 ## [1] 696 ## [1] 783 ## [1] 870 ## [1] 957 4.2.2.2 While O while() também é uma estrutura de controle de fluxo do tipo loop, mas, diferentemente do for(), o while executa as tarefas repetidamente até que uma condição seja satisfeita, não percorrendo um vetor. i &lt;- 1 while(i &lt;= 5){ print(i) i &lt;- i + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 O uso do while é um pouco menos intuitivo, mas não menos importante. O while é mais apropriado para eventos de automação ou simulação, onde tarefas serão executadas quando um “gatilho” for acionado. Um simples exemplo para ajudar na intuição de seu uso é: automatico &lt;- list.files(&#39;dados/automatico/&#39;) length(automatico) == 0 Temos uma pasta vazia. O loop abaixo vai monitorar essa pasta. Enquanto essa pasta estiver vazia, ele estará em execução. Quando você colocar um arquivo dentro dessa pasta, vai mudar a condição length(automatico) == 0 de TRUE para FALSE e vai mudar a condição length(automatico) &gt; 0 de FALSE para TRUE, disparando todas as tarefas programadas. Usamos a função Sys.sleep(5) para que o código espere por mais cinco segundos antes de começar o loop novamente. while (length(automatico) == 0) { automatico &lt;- list.files(&#39;dados/automatico/&#39;) if(length(automatico) &gt; 0) { print(&#39;O arquivo chegou!&#39;) print(&#39;Inicia a leitura dos dados&#39;) print(&#39;Faz a manipulação&#39;) print(&#39;Envia email informando conclusão dos cálculos&#39;) } else { print(&#39;aguardando arquivo...&#39;) Sys.sleep(5) } } Faça o teste: execute o código acima, aguarde alguns segundos e perceba que nada aconteceu. Crie um arquivo qualquer dentro da pasta dados/automatico/. Imediatamente o loop será encerrado e as tarefas executadas. Observe o output em tela. 4.2.3 Funções Funções “encapsulam” uma sequência de comandos e instruções. É uma estrutura nomeada, que recebe parâmetros para iniciar sua execução e retorna um resultado ao final. Até o momento, você já usou diversas funções. Vejamos então como criar uma função: sua_funcao &lt;- function(parametro1, parametro2){ # sequência de tarefas return(valores_retornados) } # chamada da função sua_funcao Agora tente entender a seguinte função: montanha_russa &lt;- function(palavra) { retorno &lt;- NULL for(i in 1:nchar(palavra)) { if(i %% 2 == 0) { retorno &lt;- paste0(retorno, tolower(substr(palavra, i, i))) } else { retorno &lt;- paste0(retorno, toupper(substr(palavra, i, i))) } } return(retorno) } montanha_russa(&#39;teste de função: letras maiúsculas e minúsculas&#39;) ## [1] &quot;TeStE De fUnÇãO: lEtRaS MaIúScUlAs e mInÚsCuLaS&quot; montanha_russa(&#39;CONSEGUIU ENTENDER?&#39;) ## [1] &quot;CoNsEgUiU EnTeNdEr?&quot; montanha_russa(&#39;É Fácil Usar Funções!&#39;) ## [1] &quot;É FáCiL UsAr fUnÇõEs!&quot; 4.3 Manipulações com R base Dominar a manipulação de data frames e vetores é muito importante. Em geral, toda manipulação pode ser feita com o R base, mas acreditamos que utilizando técnicas do tidyverse a atividade fica bem mais fácil. Portanto, utilizaremos o dplyr, um dos principais pacotes do tidyverse. Porém, alguns conceitos do R base são clássicos e precisam ser dominados. 4.3.1 Trabalhando com colunas de um data.frame Para selecionar ou trabalhar separadamente com apenas um campo (coluna) do seu data.frame, deve-se utilizar o $. Repare nas funções abaixo e no uso do sifrão. head(airquality$Ozone) ## [1] 41 36 12 18 NA 28 tail(airquality$Ozone) ## [1] 14 30 NA 14 18 20 class(airquality$Ozone) # Informa o tipo da coluna ## [1] &quot;integer&quot; is.vector(airquality$Ozone) # Apenas para verificar que cada coluna de um data.frame é um vector ## [1] TRUE unique(senado$Party) # Função que retorna apenas os valores únicos, sem repetição, de um vetor ## [1] &quot;PSDB&quot; &quot;PT&quot; &quot;PRB&quot; &quot;PDT&quot; &quot;PR&quot; &quot;PFL/DEM&quot; &quot;PMDB&quot; &quot;PP&quot; &quot;PSB&quot; &quot;PTB&quot; ## [11] &quot;PCdoB&quot; &quot;PSOL&quot; &quot;S/PART&quot; &quot;PSC&quot; &quot;PV1&quot; Lembre-se sempre: cada coluna de um data.frame é um vetor, portanto todos os registros (linhas) daquela coluna devem ser do mesmo tipo. Um data.frame pode ser considerado um conjunto de vetores nomeados, todos do mesmo tamanho, ou seja, todos com a mesma quantidade de registros. Usando termos mais técnicos, um data frame é um conjunto de dados HETEROGÊNEOS, pois cada coluna pode ser de um tipo, e BIDIMENSIONAL, por possuir apenas linhas e colunas. Já o vetor é um conjunto de dados HOMOGÊNEO, pois só pode ter valores de um mesmo tipo, e UNIDIMENSIONAL. Com esses conceitos em mente fica mais fácil entender o que mostraremos a seguir: vetor &lt;- c(seq(from=0, to=100, by=15)) #vetor de 0 a 100, de 15 em 15. vetor #lista todos os elementos ## [1] 0 15 30 45 60 75 90 vetor[1] #mostra apenas o elemento na posição 1 ## [1] 0 vetor[2] #apenas o elemento na posição 2 ## [1] 15 vetor[7] #apenas o elemento na posição 7 ## [1] 90 vetor[8] #não existe nada na posição 8... ## [1] NA A notação [] é usada para selecionar o elemento em uma ou mais posições do vetor. vetor[c(2,7)] #selecionando mais de um elemento no vetor ## [1] 15 90 Uma notação parecida é usada para selecionar elementos no data.frame. Porém, como já comentamos, data frames são BIDIMENSIONAIS. Então usaremos a notação [,] com uma vírgula separando qual a linha (posição antes da vírgula) e a coluna (posição após a vírgula) que queremos selecionar. senado[10, ] #linha 10, todas as colunas ## # A tibble: 1 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2007001 PRS0002/… MAO SANTA S PMDB TRUE PI 2 11 0 85.5 S ## # … with 3 more variables: VoteType &lt;dbl&gt;, Content &lt;chr&gt;, Round &lt;dbl&gt; senado[72, 3] #linha 72, coluna 3 ## # A tibble: 1 x 1 ## SenatorUpper ## &lt;chr&gt; ## 1 WELLINGTON SALGADO senado[c(100, 200), c(2,3,4)] # selecionando mais de uma linha e coluna em um data.frame ## # A tibble: 2 x 3 ## SenNumber SenatorUpper Vote ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PLS0229/06 MARISA SERRANO S ## 2 PLS0134/06 EPITACIO CAFETEIRA S senado[c(10:20), ] ## # A tibble: 11 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2007001 PRS0002/… MAO SANTA S PMDB TRUE PI 2 11 0 85.5 S ## 2 2007001 PRS0002/… MAGNO MALTA S PR TRUE ES 2 11 0 85.5 S ## 3 2007001 PRS0002/… EDUARDO SUP… S PT TRUE SP 2 11 0 85.5 S ## 4 2007001 PRS0002/… GILVAM BORG… S PMDB TRUE AP 2 11 0 85.5 S ## 5 2007001 PRS0002/… RAIMUNDO CO… S PFL/… FALSE SC 2 11 0 85.5 S ## 6 2007001 PRS0002/… CICERO LUCE… S PSDB FALSE PB 2 11 0 85.5 S ## 7 2007001 PRS0002/… FRANCISCO D… S PP TRUE RJ 2 11 0 85.5 S ## 8 2007001 PRS0002/… OSMAR DIAS N PDT FALSE PR 2 11 0 85.5 S ## 9 2007001 PRS0002/… ALFREDO NAS… S PR TRUE AM 2 11 0 85.5 S ## 10 2007001 PRS0002/… VALDIR RAUPP S PMDB TRUE RO 2 11 0 85.5 S ## 11 2007001 PRS0002/… GARIBALDI A… S PMDB TRUE RN 2 11 0 85.5 S ## # … with 3 more variables: VoteType &lt;dbl&gt;, Content &lt;chr&gt;, Round &lt;dbl&gt; Repare na notação c(10:20), você pode usar : para criar sequências. Experimente 1:1000 Também é possível selecionar o item desejado utilizando o próprio nome da coluna: senado[1:10, c(&#39;SenatorUpper&#39;, &#39;Party&#39;, &#39;State&#39;)] ## # A tibble: 10 x 3 ## SenatorUpper Party State ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 FLEXA RIBEIRO PSDB PA ## 2 ARTHUR VIRGILIO PSDB AM ## 3 FLAVIO ARNS PT PR ## 4 MARCELO CRIVELLA PRB RJ ## 5 JOAO DURVAL PDT BA ## 6 PAULO PAIM PT RS ## 7 EXPEDITO JUNIOR PR RO ## 8 EFRAIM MORAIS PFL/DEM PB ## 9 ALOIZIO MERCADANTE PT SP ## 10 MAO SANTA PMDB PI Existem diversas outras formas de seleção e manipulação de dados, como, por exemplo, seleção condicional: head(senado[senado$Party == &#39;PDT&#39;, ]) ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2007001 PRS0002/… JOAO DURVAL N PDT FALSE BA 2 11 0 85.5 S ## 2 2007001 PRS0002/… OSMAR DIAS N PDT FALSE PR 2 11 0 85.5 S ## 3 2007001 PRS0002/… CRISTOVAM B… A PDT FALSE DF 2 11 0 85.5 S ## 4 2007002 PLS0229/… JOAO DURVAL S PDT FALSE BA 2 11 0 98.2 S ## 5 2007002 PLS0229/… OSMAR DIAS S PDT FALSE PR 2 11 0 98.2 S ## 6 2007002 PLS0229/… CRISTOVAM B… S PDT FALSE DF 2 11 0 98.2 S ## # … with 3 more variables: VoteType &lt;dbl&gt;, Content &lt;chr&gt;, Round &lt;dbl&gt; Em todas as comparações do R usamos operadores lógicos. São operações matemáticas em que o resultado é TRUE ou FALSE (tipo logic). Para melhor entendimento, selecionamos alguns operadores lógicos e seus significados: == igual a: compara dois objetos e se forem iguais retorna TRUE, caso contrário, FALSE; != diferente: compara dois objetos e se forem diferentes retorna TRUE, caso contrário, FALSE; | ou (or): compara dois objetos, se um dos dois for TRUE, retorna TRUE, se os dois forem FALSE, retorna FALSE; &amp; e (and): compara dois objetos, se os dois forem TRUE, retorna TRUE, se um dos dois ou os dois forem FALSE, retorna FALSE; &gt;, &gt;=, &lt;, &lt;= maior, maior ou igual, menor, menor ou igual: compara grandeza de dois números e retorna TRUE ou FALSE conforme a condição; É possível fazer muita coisa com o R base, porém, vamos avançar com as manipulações, utilizando o pacote dplyr, por ser mais simples e, por isso, de mais rápido aprendizado. 4.4 Pacote dplyr O forte do pacote dplyr é a sintaxe simples e concisa, o que facilita o aprendizado e torna o pacote um dos preferidos para as tarefas do dia a dia. Também conta como ponto forte sua otimização de performance para manipulação de dados. Ao carregar o pacote tidyverse, você já carregará automaticamente o pacote dplyr, mas você também pode carregá-lo individualmente: install.packages(&quot;dplyr&quot;) library(dplyr) ?dplyr Referências: Site do pacote dplyr 4.4.1 Verbetes do dplyr e o operador %&gt;% O dplyr cobre praticamente todas as tarefas básicas da manipulação de dados: agregar, sumarizar, filtrar, ordenar, criar variáveis, joins, dentre outras. As funções do dplyr reproduzem as principais tarefas da manipulação, de forma bastante intuitiva. Veja só: select() filter() arrange() mutate() group_by() summarise() Esses são os principais verbetes, mas existem outros disponíveis, como por exemplo slice(), rename() e transmute(). Além de nomes de funções intuitivos, o dplyr também faz uso de um recurso disponível em boa parte dos pacotes do Hadley, o operador %&gt;% (originário do pacote magrittr). Este operador encadeia as chamadas de funções de forma que você não vai precisar ficar chamando uma função dentro da outra ou ficar fazendo atribuições usando diversas linhas para concluir suas manipulações. Aliás, podemos dizer que esse operador %&gt;%, literalmente, cria um fluxo sequencial bastante claro e legível para todas as atividades de manipulação. Os 6 principais verbetes listados acima possuem funções derivadas com os sufixos _at, _if e _all, que podem ser muito úteis em arquivos com muitas colunas. 4.4.2 Select O select() é a função mais simples de ser entendida. É usada para selecionar variáveis (colunas, campos, features…) do seu data frame. senadores.partido &lt;- senado %&gt;% select(SenatorUpper, Party) head(senadores.partido) ## # A tibble: 6 x 2 ## SenatorUpper Party ## &lt;chr&gt; &lt;chr&gt; ## 1 FLEXA RIBEIRO PSDB ## 2 ARTHUR VIRGILIO PSDB ## 3 FLAVIO ARNS PT ## 4 MARCELO CRIVELLA PRB ## 5 JOAO DURVAL PDT ## 6 PAULO PAIM PT Você pode, também, fazer uma “seleção negativa”, ou seja, escolher as colunas que não quer: senadores.partido &lt;- senado %&gt;% select(-SenatorUpper, -Party) head(senadores.partido) ## # A tibble: 6 x 13 ## VoteNumber SenNumber Vote GovCoalition State FP Origin Contentious PercentYes IndGov VoteType Content ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2007001 PRS0002/… S FALSE PA 2 11 0 85.5 S 1 Create… ## 2 2007001 PRS0002/… S FALSE AM 2 11 0 85.5 S 1 Create… ## 3 2007001 PRS0002/… N TRUE PR 2 11 0 85.5 S 1 Create… ## 4 2007001 PRS0002/… S TRUE RJ 2 11 0 85.5 S 1 Create… ## 5 2007001 PRS0002/… N FALSE BA 2 11 0 85.5 S 1 Create… ## 6 2007001 PRS0002/… S TRUE RS 2 11 0 85.5 S 1 Create… ## # … with 1 more variable: Round &lt;dbl&gt; select_at(): Selecionar um conjunto de variáveis, especificadas pelo nome ou pela posição numérica, podendo aplicar uma função ao nome delas: # manter apenas as colunas que começam com S e transformar o nome para maiusculo senado %&gt;% select_at(vars(starts_with(&quot;S&quot;)), toupper) %&gt;% head() ## # A tibble: 6 x 3 ## SENNUMBER SENATORUPPER STATE ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PRS0002/07 FLEXA RIBEIRO PA ## 2 PRS0002/07 ARTHUR VIRGILIO AM ## 3 PRS0002/07 FLAVIO ARNS PR ## 4 PRS0002/07 MARCELO CRIVELLA RJ ## 5 PRS0002/07 JOAO DURVAL BA ## 6 PRS0002/07 PAULO PAIM RS select_if(): Selecionar o conjunto de variáveis do dataframe que atende a um teste lógico: # selecionar apenas as colunas numericas do dataframe senado %&gt;% select_if(is.numeric) %&gt;% head() ## # A tibble: 6 x 7 ## VoteNumber FP Origin Contentious PercentYes VoteType Round ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2007001 2 11 0 85.5 1 1 ## 2 2007001 2 11 0 85.5 1 1 ## 3 2007001 2 11 0 85.5 1 1 ## 4 2007001 2 11 0 85.5 1 1 ## 5 2007001 2 11 0 85.5 1 1 ## 6 2007001 2 11 0 85.5 1 1 select_all(): seleciona todas as colunas, opcionalmente aplicando uma função ao nome delas. senado %&gt;% select_all(tolower) ## # A tibble: 9,262 x 15 ## votenumber sennumber senatorupper vote party govcoalition state fp origin contentious percentyes indgov ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2007001 PRS0002/… FLEXA RIBEI… S PSDB FALSE PA 2 11 0 85.5 S ## 2 2007001 PRS0002/… ARTHUR VIRG… S PSDB FALSE AM 2 11 0 85.5 S ## 3 2007001 PRS0002/… FLAVIO ARNS N PT TRUE PR 2 11 0 85.5 S ## 4 2007001 PRS0002/… MARCELO CRI… S PRB TRUE RJ 2 11 0 85.5 S ## 5 2007001 PRS0002/… JOAO DURVAL N PDT FALSE BA 2 11 0 85.5 S ## 6 2007001 PRS0002/… PAULO PAIM S PT TRUE RS 2 11 0 85.5 S ## 7 2007001 PRS0002/… EXPEDITO JU… S PR TRUE RO 2 11 0 85.5 S ## 8 2007001 PRS0002/… EFRAIM MORA… S PFL/… FALSE PB 2 11 0 85.5 S ## 9 2007001 PRS0002/… ALOIZIO MER… S PT TRUE SP 2 11 0 85.5 S ## 10 2007001 PRS0002/… MAO SANTA S PMDB TRUE PI 2 11 0 85.5 S ## # … with 9,252 more rows, and 3 more variables: votetype &lt;dbl&gt;, content &lt;chr&gt;, round &lt;dbl&gt; Referências: Documentação da função select() Documentação das funções derivadas de select() 4.4.3 Filter Além de escolher apenas alguns campos, você pode escolher apenas algumas linhas, utilizando alguma condição como filtragem. Para isso, basta utilizar a função filter. senadores.pdt.df &lt;- senado %&gt;% select(SenatorUpper, Party, State) %&gt;% filter(State == &#39;RJ&#39;, Party == &#39;PMDB&#39;) %&gt;% distinct() #semelhante ao unique(), traz registros únicos sem repetição head(senadores.pdt.df) ## # A tibble: 2 x 3 ## SenatorUpper Party State ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PAULO DUQUE PMDB RJ ## 2 REGIS FICHTNER PMDB RJ # filtrar votações com votos SIM acima de 90% senado %&gt;% filter(PercentYes &gt; 90) %&gt;% head() ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2007002 PLS0229/… JOAO DURVAL S PDT FALSE BA 2 11 0 98.2 S ## 2 2007002 PLS0229/… EDUARDO SUP… S PT TRUE SP 2 11 0 98.2 S ## 3 2007002 PLS0229/… OSMAR DIAS S PDT FALSE PR 2 11 0 98.2 S ## 4 2007002 PLS0229/… PRESIDENT L… S PT TRUE &lt;NA&gt; 2 11 0 98.2 S ## 5 2007002 PLS0229/… GERALDO MES… S PMDB TRUE AC 2 11 0 98.2 S ## 6 2007002 PLS0229/… FLEXA RIBEI… S PSDB FALSE PA 2 11 0 98.2 S ## # … with 3 more variables: VoteType &lt;dbl&gt;, Content &lt;chr&gt;, Round &lt;dbl&gt; Referências: Documentação da função filter() Documentação das funções derivadas de filter() 4.4.4 Mutate Para criar novos campos, podemos usar o mutate: glimpse(senado) ## Rows: 9,262 ## Columns: 15 ## $ VoteNumber &lt;dbl&gt; 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 2007001, 200700… ## $ SenNumber &lt;chr&gt; &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PRS0002/07&quot;, &quot;PR… ## $ SenatorUpper &lt;chr&gt; &quot;FLEXA RIBEIRO&quot;, &quot;ARTHUR VIRGILIO&quot;, &quot;FLAVIO ARNS&quot;, &quot;MARCELO CRIVELLA&quot;, &quot;JOAO DURVAL&quot;, &quot;… ## $ Vote &lt;chr&gt; &quot;S&quot;, &quot;S&quot;, &quot;N&quot;, &quot;S&quot;, &quot;N&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;N&quot;, &quot;S… ## $ Party &lt;chr&gt; &quot;PSDB&quot;, &quot;PSDB&quot;, &quot;PT&quot;, &quot;PRB&quot;, &quot;PDT&quot;, &quot;PT&quot;, &quot;PR&quot;, &quot;PFL/DEM&quot;, &quot;PT&quot;, &quot;PMDB&quot;, &quot;PR&quot;, &quot;PT&quot;, &quot;P… ## $ GovCoalition &lt;lgl&gt; FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE… ## $ State &lt;chr&gt; &quot;PA&quot;, &quot;AM&quot;, &quot;PR&quot;, &quot;RJ&quot;, &quot;BA&quot;, &quot;RS&quot;, &quot;RO&quot;, &quot;PB&quot;, &quot;SP&quot;, &quot;PI&quot;, &quot;ES&quot;, &quot;SP&quot;, &quot;AP&quot;, &quot;SC&quot;, &quot;PB… ## $ FP &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, … ## $ Origin &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,… ## $ Contentious &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ PercentYes &lt;dbl&gt; 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.45455, 85.4545… ## $ IndGov &lt;chr&gt; &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S… ## $ VoteType &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … ## $ Content &lt;chr&gt; &quot;Creates the Senate Commission of Science, Technology, Innovation, Communication, and I… ## $ Round &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … # criar coluna com o nome do senador em minusculo senado %&gt;% select(SenatorUpper) %&gt;% mutate(SenatorLower = tolower(SenatorUpper)) %&gt;% head() ## # A tibble: 6 x 2 ## SenatorUpper SenatorLower ## &lt;chr&gt; &lt;chr&gt; ## 1 FLEXA RIBEIRO flexa ribeiro ## 2 ARTHUR VIRGILIO arthur virgilio ## 3 FLAVIO ARNS flavio arns ## 4 MARCELO CRIVELLA marcelo crivella ## 5 JOAO DURVAL joao durval ## 6 PAULO PAIM paulo paim Caso o argumento da esquerda em mutate() seja um nome de coluna que já existe no dataframe, esta será sobrescrita: senado %&gt;% mutate(Party = tolower(Party)) %&gt;% head() ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2007001 PRS0002/… FLEXA RIBEI… S psdb FALSE PA 2 11 0 85.5 S ## 2 2007001 PRS0002/… ARTHUR VIRG… S psdb FALSE AM 2 11 0 85.5 S ## 3 2007001 PRS0002/… FLAVIO ARNS N pt TRUE PR 2 11 0 85.5 S ## 4 2007001 PRS0002/… MARCELO CRI… S prb TRUE RJ 2 11 0 85.5 S ## 5 2007001 PRS0002/… JOAO DURVAL N pdt FALSE BA 2 11 0 85.5 S ## 6 2007001 PRS0002/… PAULO PAIM S pt TRUE RS 2 11 0 85.5 S ## # … with 3 more variables: VoteType &lt;dbl&gt;, Content &lt;chr&gt;, Round &lt;dbl&gt; Veja como é simples realizar a operação acima, de transformar uma coluna para minúsculo, para todas as colunas de texto do dataframe com o auxílio de mutate_if(), na qual o primeiro argumento é um teste lógico e o segundo é a função a ser aplicada para todas as colunas onde o teste lógico seja TRUE. senado %&gt;% # o primeiro argumento de mutate_if mutate_if(is.character, tolower) %&gt;% head() ## # A tibble: 6 x 15 ## VoteNumber SenNumber SenatorUpper Vote Party GovCoalition State FP Origin Contentious PercentYes IndGov ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2007001 prs0002/… flexa ribei… s psdb FALSE pa 2 11 0 85.5 s ## 2 2007001 prs0002/… arthur virg… s psdb FALSE am 2 11 0 85.5 s ## 3 2007001 prs0002/… flavio arns n pt TRUE pr 2 11 0 85.5 s ## 4 2007001 prs0002/… marcelo cri… s prb TRUE rj 2 11 0 85.5 s ## 5 2007001 prs0002/… joao durval n pdt FALSE ba 2 11 0 85.5 s ## 6 2007001 prs0002/… paulo paim s pt TRUE rs 2 11 0 85.5 s ## # … with 3 more variables: VoteType &lt;dbl&gt;, Content &lt;chr&gt;, Round &lt;dbl&gt; Referências: Documentação da função mutate() Documentação das funções derivadas de mutate() 4.4.5 Group By e Summarise O group_by() e o summarise() são operações que trabalham na agregação dos dados, ou seja, um dado mais detalhado passa a ser um dado mais agregado e agrupado, em consequência disso, menos detalhado. O agrupamento de dados geralmente é trabalhado em conjunção com sumarizações, que usam funções matemáticas do tipo soma, média, desvio padrão etc. Enquanto o group_by() “separa” seus dados nos grupos que você selecionar, o summarise() faz operações de agregação de linhas limitadas a esse grupo. Vale observar que operações de agrupamento e sumarização geralmente DIMINUEM a quantidade de linhas dos seus dados, pois está reduzindo o nível de detalhe. Ou seja, de alguma forma, você está “perdendo” detalhe para “ganhar” agregação. Como exemplo, utilizaremos os dados disponíveis no pacote nycflights13: install.packages(&quot;nycflights13&quot;) library(nycflights13) data(&quot;flights&quot;) str(flights) ## tibble [336,776 × 19] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ dep_time : int [1:336776] 517 533 542 544 554 554 555 557 557 558 ... ## $ sched_dep_time: int [1:336776] 515 529 540 545 600 558 600 600 600 600 ... ## $ dep_delay : num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_time : int [1:336776] 830 850 923 1004 812 740 913 709 838 753 ... ## $ sched_arr_time: int [1:336776] 819 830 850 1022 837 728 854 723 846 745 ... ## $ arr_delay : num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ carrier : chr [1:336776] &quot;UA&quot; &quot;UA&quot; &quot;AA&quot; &quot;B6&quot; ... ## $ flight : int [1:336776] 1545 1714 1141 725 461 1696 507 5708 79 301 ... ## $ tailnum : chr [1:336776] &quot;N14228&quot; &quot;N24211&quot; &quot;N619AA&quot; &quot;N804JB&quot; ... ## $ origin : chr [1:336776] &quot;EWR&quot; &quot;LGA&quot; &quot;JFK&quot; &quot;JFK&quot; ... ## $ dest : chr [1:336776] &quot;IAH&quot; &quot;IAH&quot; &quot;MIA&quot; &quot;BQN&quot; ... ## $ air_time : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... ## $ distance : num [1:336776] 1400 1416 1089 1576 762 ... ## $ hour : num [1:336776] 5 5 5 5 6 5 6 6 6 6 ... ## $ minute : num [1:336776] 15 29 40 45 0 58 0 0 0 0 ... ## $ time_hour : POSIXct[1:336776], format: &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; ... Gostaríamos de obter a média de atraso da chegada para cada mês. Para isso, primeiro agrupamos no nível necessário e depois sumarizamos. atraso_por_mes &lt;- flights %&gt;% group_by(month) %&gt;% summarise(arr_delay_media = mean(arr_delay, na.rm=TRUE), dep_delay_media = mean(dep_delay, na.rm=TRUE)) ## `summarise()` ungrouping output (override with `.groups` argument) atraso_por_mes ## # A tibble: 12 x 3 ## month arr_delay_media dep_delay_media ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 6.13 10.0 ## 2 2 5.61 10.8 ## 3 3 5.81 13.2 ## 4 4 11.2 13.9 ## 5 5 3.52 13.0 ## 6 6 16.5 20.8 ## 7 7 16.7 21.7 ## 8 8 6.04 12.6 ## 9 9 -4.02 6.72 ## 10 10 -0.167 6.24 ## 11 11 0.461 5.44 ## 12 12 14.9 16.6 A função n() retorna a quantidade de observacões (linhas) por variável especificada em group_by(): # Quantidade de voos por hora do dia flights %&gt;% group_by(carrier) %&gt;% summarise(n_voos = n()) %&gt;% head() ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 6 x 2 ## carrier n_voos ## &lt;chr&gt; &lt;int&gt; ## 1 9E 18460 ## 2 AA 32729 ## 3 AS 714 ## 4 B6 54635 ## 5 DL 48110 ## 6 EV 54173 A função n_distinct() retorna a quantidade de casos únicos por grupo: # quantas companhias aéreas diferentes operam por aeroporto por mês nos EUA? flights %&gt;% group_by(origin, month) %&gt;% summarise(n_empresas = n_distinct(carrier)) %&gt;% head(6) ## `summarise()` regrouping output by &#39;origin&#39; (override with `.groups` argument) ## # A tibble: 6 x 3 ## # Groups: origin [1] ## origin month n_empresas ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 EWR 1 10 ## 2 EWR 2 10 ## 3 EWR 3 10 ## 4 EWR 4 11 ## 5 EWR 5 11 ## 6 EWR 6 12 Referências: Documentação da função group_by() Documentação da função summarise() 4.4.6 Arrange A função arrange() serve para organizar os dados em sua ordenação. Costuma ser uma das últimas operações, normalmente usada para organizar os dados e facilitar visualizações ou criação de relatórios. Utilizando o exemplo anterior, gostaríamos de ordenar os meses pelas menores médias de decolagem (para ordens decrescentes basta usar o sinal de menos -) media &lt;- flights %&gt;% group_by(month) %&gt;% summarise(arr_delay_media = mean(arr_delay, na.rm=TRUE), dep_delay_media = mean(dep_delay, na.rm=TRUE)) %&gt;% arrange(dep_delay_media) ## `summarise()` ungrouping output (override with `.groups` argument) media ## # A tibble: 12 x 3 ## month arr_delay_media dep_delay_media ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 0.461 5.44 ## 2 10 -0.167 6.24 ## 3 9 -4.02 6.72 ## 4 1 6.13 10.0 ## 5 2 5.61 10.8 ## 6 8 6.04 12.6 ## 7 5 3.52 13.0 ## 8 3 5.81 13.2 ## 9 4 11.2 13.9 ## 10 12 14.9 16.6 ## 11 6 16.5 20.8 ## 12 7 16.7 21.7 Referências: Documentação da função arrange() 4.5 Exercícios 4.5.1 Parte 1 Utilizando os dados em senado.csv, tente usar da manipulação de dados para responder às perguntas a seguir: Verifique a existência de registros NA em State. Caso existam, crie um novo data.frame senado2 sem esses registros e utilize-o para os próximos exercícios. Dica: is.na(State) Quais partidos foram parte da coalizão do governo? E quais não foram? Dica: filter() Quantos senadores tinha cada partido? Qual tinha mais? Quais tinham menos? Dica: group_by(), summarise() e n_distinct() Qual partido votou mais “sim”? E qual voltou menos “sim”? Dica: sum(Vote == 'S') Qual região do país teve mais votos “sim”? Primeiro será necessário criar uma coluna região para depois contabilizar o total de votos por região. #&gt;Dica: mutate(Regiao = ifelse(State %in% c(&quot;AM&quot;, &quot;AC&quot;, &quot;TO&quot;, &quot;PA&quot;, &quot;RO&quot;, &quot;RR&quot;), &quot;Norte&quot;, ifelse(State %in% c(&quot;SP&quot;, &quot;MG&quot;, &quot;RJ&quot;, &quot;ES&quot;), &quot;Sudeste&quot;, ifelse(State %in% c(&quot;MT&quot;, &quot;MS&quot;, &quot;GO&quot;, &quot;DF&quot;), &quot;Centro-Oeste&quot;, ifelse(State %in% c(&quot;PR&quot;, &quot;SC&quot;, &quot;RS&quot;), &quot;Sul&quot;, &quot;Nordeste&quot;))))) 4.5.2 Parte 2 Baixe o dataset de anúncios do AirBNB no Rio de Janeiro a partir deste link: http://data.insideairbnb.com/brazil/rj/rio-de-janeiro/2020-05-24/data/listings.csv.gz Leia o arquivo listings com a função read_csv() e salve no objeto df_anuncios Inspecione os dados: funções summary() e glimpse() A partir do output de glimpse(), explique as diferentes classes de objetos no R. Observe o problema nas variáveis de preço Retorne a url (scrape_url) do anúncio mais caro do airbnb Retorne o nome do host (host_name) que tem a maior quantidade de anúncios Retorne a quantidade de hosts por ano em que entrou no airbnb Selecione as colunas name e space e filtre as linhas que contem a palavra praia em space. Dica: Vc pode usar a função str_detect() dentro de filter() ou de mutate() Imóveis que mencionam a palavra praia são em média mais caros? Use mutate() para modificar o dataframe criando uma coluna booleana chamada esgotado informando se o imovel esta indisponivel para os proximos 30 dias (coluna availability_30) Quais os 5 bairros que possuem mais de 100 anúncios com a maior taxa de anúncios esgotados nos próximos 30 dias? Dica: crie duas colunas com summarise, uma usando n() e outra com mean(esgotado) e depois use filter(), arrange() e head() Retorne a quantidade de anúncios e reviews (number_of_reviews) por bairro, calcule uma taxa de quantidade de reviews por quantidade de anuncios. Os bairros que possuem mais anuncios são, proporcionalmente, os que tem mais reviews? Quais são os diferentes tipos de anúncio (quarto, apt, etc.) que existem? (Coluna room_type) A quantidade de quartos tem relação com o preço dos apartamentos inteiros? DESAFIO Suponha que você planeja uma viagem para o RJ com mais 1 pessoa de 5 diárias nos… proximos 30 dias. Você e seu grupo têm alguns critérios de escolha: Vocês querem ficar em Ipanema, Copacabana ou Leblon. Vocês preferem que o host esteja no mesmo bairro. Não desejam pagar um depósito de segurança; Querem um apartamento inteiro só para vocês que seja “instant bookable” A diária já inclua duas pessoas Filtre os anúncios que atendem aos critérios acima e crie uma coluna chamada preco_total_viagem, com a formula sendo: taxa de limpeza + preço da diaria x quantidade de diarias. Compare os resultados com os do site. Dica: Comece com o código abaixo, selecionando as colunas importantes "],
["limpando-dados.html", "5 Limpando dados 5.1 O formato “ideal” dos dados 5.2 Pacote tidyr 5.3 Exercicios", " 5 Limpando dados No dia a dia de quem trabalha com dados, infelizmente, é muito comum se deparar com dados formatados de um jeito bastante complicado de se manipular. Isso acontece pois a forma de se trabalhar com dados é muito diferente da forma de se apresentar ou visualizar dados. Resumindo: “olhar” dados requer uma estrutura bem diferente de “mexer” com dados. Limpeza de dados também é considerada parte da manipulação de dados. 5.1 O formato “ideal” dos dados É importante entender um pouco mais sobre como os dados podem ser estruturados antes de entrarmos nas funções de limpeza. O formato ideal para analisar dados, visualmente, é diferente do formato ideal para analisá-los de forma sistemática. Observe as duas tabelas a seguir: Figura 5.1: Tabela wide Figura 5.2: Tabela long A primeira tabela é mais intuitiva para análise visual, pois faz uso de cores e propõe uma leitura natural, da esquerda para a direita. Utiliza, ainda, elementos e estruturas que guiam seus olhos por uma análise de forma simples. Já a segunda tabela é um pouco árida para se interpretar “no olho”. Há uma espécie de regra geral a qual diz que um dado bem estruturado deve conter uma única variável em uma coluna e uma única observação em uma linha. Observando-se a primeira tabela, com essa regra em mente, podemos perceber que as observações de ano estão organizadas em colunas. Apesar de estar num formato ideal para análise visual, esse formato dificulta bastante certas análises sistemáticas. O melhor a se fazer é converter a primeira tabela a um modelo mais próximo o possível da segunda tabela. Infelizmente, não temos como apresentar um passo a passo padrão para limpeza de dados, pois isso depende completamente do tipo de dado que você receber, da análise que você quer fazer e da sua criatividade em manipulação de dados. Mas conhecer os pacotes certos ajuda muito nessa tarefa. Lembre-se: é muito mais fácil trabalhar no R com dados “bem estruturados”, onde cada coluna deve ser uma única variável e cada linha deve ser uma única observação. Na contramão da limpeza de dados, você provavelmente terá o problema contrário ao final da sua análise. Supondo que você organizou seus dados perfeitamente, conseguiu executar os modelos que gostaria, gerou diversos gráficos interessantes e está satisfeito com o resultado, você ainda precisará entregar relatórios finais da sua análise em forma de tabelas sumarizadas e explicativas, de modo que os interessados possam entender facilmente, apenas com uma rápida análise visual. Neste caso, que tipo de tabela seria melhor produzir? Provavelmente, quem for ler seus relatórios entenderá mais rapidamente as tabelas mais próximas do primeiro exemplo mostrado. É importante aprender a estruturar e desestruturar tabelas de todas as formas possíveis. Para exemplificar, veja algumas tabelas disponíveis no pacote tidyverse, ilustrando os diferentes tipos de organização nos formatos wide e long. Todas as tabelas possuem os mesmos dados e informações: library(tidyverse) table1 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4b ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 table5 ## # A tibble: 6 x 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 5.2 Pacote tidyr Apesar de existirem diversas possibilidades de situações que necessitem de limpeza de dados, a conjugação de três pacotes consegue resolver a grande maioria dos casos: dplyr, tidyr, stringr. O pacote tidyr é mais um dos pacotes criados por Hadley Wickham. Este fato, por si só, já traz algumas vantagens: ele se integra perfeitamente com o dplyr, usando o conector %&gt;%, e tem a sintaxe de suas funções bastante intuitiva. install.packages(&quot;tidyr&quot;) library(tidyr) ?tidyr O tidyr também tem suas funções organizadas em pequenos verbetes, onde cada um representa uma tarefa para organizar os dados. Os verbetes básicos que abordaremos são os seguintes: pivot_longer() pivot_wider() separate() spread() unite() separate_rows() Figura 5.3: Tabela long Referências: Site do pacote tidyr 5.2.1 pivot_longer() A função pivot_longer(), antiga gather(), serve para agrupar duas ou mais colunas e seus respectivos valores (conteúdos) em pares. Assim, o resultado após o agrupamento é sempre duas colunas. A primeira delas possui observações cujos valores chave eram as colunas antigas e a segunda possui os valores respectivos relacionados com as colunas antigas. Na prática, a função gather diminui o número de colunas e aumenta o número de linhas de nossa base de dados. Usaremos dados disponíveis no R base para exemplificar: relig_income ## # A tibble: 18 x 11 ## religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k` `$100-150k` `&gt;150k` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Agnostic 27 34 60 81 76 137 122 109 84 ## 2 Atheist 12 27 37 52 35 70 73 59 74 ## 3 Buddhist 27 21 30 34 33 58 62 39 53 ## 4 Catholic 418 617 732 670 638 1116 949 792 633 ## 5 Don’t k… 15 14 15 11 10 35 21 17 18 ## 6 Evangel… 575 869 1064 982 881 1486 949 723 414 ## 7 Hindu 1 9 7 9 11 34 47 48 54 ## 8 Histori… 228 244 236 238 197 223 131 81 78 ## 9 Jehovah… 20 27 24 24 21 30 15 11 6 ## 10 Jewish 19 19 25 25 30 95 69 87 151 ## 11 Mainlin… 289 495 619 655 651 1107 939 753 634 ## 12 Mormon 29 40 48 51 56 112 85 49 42 ## 13 Muslim 6 7 9 10 9 23 16 8 6 ## 14 Orthodox 13 17 23 32 32 47 38 42 46 ## 15 Other C… 9 7 11 13 13 14 18 14 12 ## 16 Other F… 20 33 40 46 49 63 46 40 41 ## 17 Other W… 5 2 3 4 2 7 3 4 4 ## 18 Unaffil… 217 299 374 365 341 528 407 321 258 ## # … with 1 more variable: `Don&#39;t know/refused` &lt;dbl&gt; Para transformar a tabela acima do formato wide para o long, usamos a função: relig_income %&gt;% pivot_longer( # o argumento cols controla quais colunas serão (ou não serão) transformadas cols = -religion, #names_to controla o nome da nova coluna que irá receber os nomes das colunas transpostas names_to = &quot;renda&quot;, # values_to controla o nome da nova coluna que irá recebebr os valores das colunas transpostas values_to = &quot;quantidade&quot;) ## # A tibble: 180 x 3 ## religion renda quantidade ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Agnostic &lt;$10k 27 ## 2 Agnostic $10-20k 34 ## 3 Agnostic $20-30k 60 ## 4 Agnostic $30-40k 81 ## 5 Agnostic $40-50k 76 ## 6 Agnostic $50-75k 137 ## 7 Agnostic $75-100k 122 ## 8 Agnostic $100-150k 109 ## 9 Agnostic &gt;150k 84 ## 10 Agnostic Don&#39;t know/refused 96 ## # … with 170 more rows Referências: Documentação da função pivot_longer() 5.2.2 pivot_wider() É a operação antagônica do pivot_longer(). Ela espalha os valores de duas colunas em diversos campos para cada registro: os valores de uma coluna viram o nome das novas colunas, e os valores de outra viram valores de cada registro nas novas colunas. O output tem mais colunas e menos linhas. us_rent_income ## # A tibble: 104 x 5 ## GEOID NAME variable estimate moe ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama income 24476 136 ## 2 01 Alabama rent 747 3 ## 3 02 Alaska income 32940 508 ## 4 02 Alaska rent 1200 13 ## 5 04 Arizona income 27517 148 ## 6 04 Arizona rent 972 4 ## 7 05 Arkansas income 23789 165 ## 8 05 Arkansas rent 709 5 ## 9 06 California income 29454 109 ## 10 06 California rent 1358 3 ## # … with 94 more rows us_rent_income %&gt;% pivot_wider( #names_from controla de qual coluna serão criados os nomes das novas colunas names_from = variable, # values_from controla as colunas cujos valores serão os valores das novas colunas values_from = c(estimate, moe) ) ## # A tibble: 52 x 6 ## GEOID NAME estimate_income estimate_rent moe_income moe_rent ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama 24476 747 136 3 ## 2 02 Alaska 32940 1200 508 13 ## 3 04 Arizona 27517 972 148 4 ## 4 05 Arkansas 23789 709 165 5 ## 5 06 California 29454 1358 109 3 ## 6 08 Colorado 32401 1125 109 5 ## 7 09 Connecticut 35326 1123 195 5 ## 8 10 Delaware 31560 1076 247 10 ## 9 11 District of Columbia 43198 1424 681 17 ## 10 12 Florida 25952 1077 70 3 ## # … with 42 more rows Referências: Documentação da função pivot_wider() 5.2.3 separate O separate() é usado para separar duas variáveis que estão em uma mesma coluna. Lembre-se: cada coluna deve ser apenas uma única variável! É muito normal virem variáveis juntas em uma única coluna, mas nem sempre isso é prejudicial, cabe avaliar quando vale a pena separá-las. Usaremos o exemplo da table3 para investigar: table3.wide &lt;- table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep=&#39;/&#39;) head(table3.wide) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Referências: Documentação da função separate 5.2.4 unite A operação unite() é o oposto da separate(), ela pega duas colunas (variáveis) e transforma em uma só. É muito utilizada para montar relatórios finais ou tabelas para análise visual. Aproveitemos o exemplo em table2 para montarmos uma tabela final comparando a “case” e “population” de cada país, em cada ano. table2.relatorio &lt;- table2 %&gt;% unite(type_year, type, year) %&gt;% spread(key = type_year, value = count, sep = &#39;_&#39;) table2.relatorio ## # A tibble: 3 x 5 ## country type_year_cases_1999 type_year_cases_2000 type_year_population_1999 type_year_population_2000 ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 19987071 20595360 ## 2 Brazil 37737 80488 172006362 174504898 ## 3 China 212258 213766 1272915272 1280428583 Referências: Documentação da função unite O primeiro parâmetro é a coluna que desejamos criar, os próximos são as colunas que desejamos unir e, por fim, temos o sep, que representa algum símbolo opcional para ficar entre os dois valores na nova coluna. 5.2.5 separate_rows Do mesmo modo que separate() quebra uma coluna em várias, separate_rows() quebra uma linha em várias de acordo com um separador. Essa função é muito útil para lidar com dados sujos. Observe o exemplo: # criar dataframe de exemplo exemplo &lt;- tibble(grupo = c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;,&quot;b&quot;), y = c(&quot;1, 2&quot;, &quot;3;4&quot;, &quot;1,2,3&quot;, &quot;4&quot;)) exemplo %&gt;% separate_rows(y, sep = &quot;,&quot;) ## # A tibble: 7 x 2 ## grupo y ## &lt;chr&gt; &lt;chr&gt; ## 1 a &quot;1&quot; ## 2 a &quot; 2&quot; ## 3 a &quot;3;4&quot; ## 4 b &quot;1&quot; ## 5 b &quot;2&quot; ## 6 b &quot;3&quot; ## 7 b &quot;4&quot; Referências: Documentação da função separate_rows 5.3 Exercicios Transforme a table1 para a table2 usando pivot_longer() Transforme a table2 para a table1 usando pivot_wider() Transforme a table5 para a table1 e para a table2 "],
["juntando-dados.html", "6 Juntando dados 6.1 União de dados (Union) 6.2 Cruzamento de Dados (Join) 6.3 Exercícios 6.4 Exercícios gerais do Tidyverse", " 6 Juntando dados Existem duas grandes formas de junção de dados: UNIÃO e CRUZAMENTO. Para que uma união seja possível, os dois conjuntos de dados precisam ter os mesmos campos. Para que um cruzamento seja possível, os dois conjuntos precisam ter pelo menos um campo em comum. Figura 6.1: União de tabelas Figura 6.2: Cruzamento de tabelas 6.1 União de dados (Union) A união de dados é mais intuitiva. Basta ter a mesma quantidade de campos e que estes estejam “alinhados”. A função mais usada para isso é o famoso rbind() (Row Bind). Caso os campos tenham exatamente os mesmos nomes e tipo, o rbind() consegue fazer a união perfeitamente. dados2016 &lt;- data.frame(ano = c(2016, 2016, 2016), valor = c(938, 113, 1748), produto = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)) dados2017 &lt;- data.frame(valor = c(8400, 837, 10983), produto = c(&#39;H&#39;, &#39;Z&#39;, &#39;X&#39;), ano = c(2017, 2017, 2017)) dados.finais &lt;- rbind(dados2016, dados2017) dados.finais ## ano valor produto ## 1 2016 938 A ## 2 2016 113 B ## 3 2016 1748 C ## 4 2017 8400 H ## 5 2017 837 Z ## 6 2017 10983 X A união de dados é a forma mais simples de juntá-los. 6.2 Cruzamento de Dados (Join) O cruzamento de dados é um pouco mais complexo, mas nem por isso chega a ser algo difícil. Para entender-se como fazer “joins” (cruzamentos), é preciso compreender-se o conceito de chave. Entenda chave como uma coluna que está presente da mesma forma em dois conjuntos de dados distintos. O conceito completo de chave é bem mais complexo que isto, mas, para começarmos a entender e usar os joins, basta usar essa intuição. Tendo esse conceito simplificado de chave em mente, a primeira coisa que se deve fazer quando for preciso cruzar dois conjuntos de dados é tentar identificar quais os campos chaves, ou seja, quais campos estão presentes nos dois grupos. O que acontece quando nem todos os códigos de um grupo estão no outro? E quando um grupo tem códigos repetidos em várias linhas? Para responder a essas e outras perguntas precisamos conhecer os diferentes tipos de joins. Existe pelo menos uma dezena de tipos de joins, mas 90% das vezes você precisará apenas dos tipos básicos que explicaremos a seguir. Usaremos o pacote dplyr para aplicar os joins. O R base possui a função merge() para joins, se tiver curiosidade procure mais sobre ela depois. Referências: Documentação das funções *_join 6.2.1 Inner Join (ou apenas Join) Trata-se do join mais simples, mais básico e mais usado dentre todos os outros tipos. O seu comportamento mantém no resultado apenas as linhas presentes nos dois conjuntos de dados que estão sendo cruzados. O inner join funciona da seguinte forma: Figura 6.3: Cruzamento de tabelas A tabela final, após o cruzamento, conterá as linhas com as chaves que estiverem em AMBOS os conjuntos de dados. As linhas com chaves que não estão em ambos serão descartadas. Esta característica torna o inner join muito útil para fazer-se filtros. Vamos utilizar dados já disponíveis no dplyr para testar os joins: band_members ## # A tibble: 3 x 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones ## 2 John Beatles ## 3 Paul Beatles band_instruments ## # A tibble: 3 x 2 ## name plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar str(band_members) ## tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## $ name: chr [1:3] &quot;Mick&quot; &quot;John&quot; &quot;Paul&quot; ## $ band: chr [1:3] &quot;Stones&quot; &quot;Beatles&quot; &quot;Beatles&quot; str(band_instruments) ## tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## $ name : chr [1:3] &quot;John&quot; &quot;Paul&quot; &quot;Keith&quot; ## $ plays: chr [1:3] &quot;guitar&quot; &quot;bass&quot; &quot;guitar&quot; #vamos juntar os dois conjuntos com um join band_members %&gt;% inner_join(band_instruments) ## # A tibble: 2 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass #o dplyr &quot;adivinhou&quot; a coluna chave pelo nome Repare que, nesse caso, a chave é a coluna name. Repare também que os dois conjuntos têm três registros. Então, por que o resultado final só tem dois registros? A resposta é simples: porque o comportamento do join é justamente retornar apenas as linhas em que as chaves coincidiram (efeito de filtro). Vamos fazer o mesmo experimento com band_intruments2: band_instruments2 ## # A tibble: 3 x 2 ## artist plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar str(band_instruments2) #o nome da coluna é diferente ## tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## $ artist: chr [1:3] &quot;John&quot; &quot;Paul&quot; &quot;Keith&quot; ## $ plays : chr [1:3] &quot;guitar&quot; &quot;bass&quot; &quot;guitar&quot; band_members %&gt;% inner_join(band_instruments2, by = c(&#39;name&#39; = &#39;artist&#39;)) ## # A tibble: 2 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass Repare que, dessa vez, tivemos que especificar qual a coluna chave para que o join aconteça. Mais um exemplo: empregados &lt;- read_csv(&#39;dados/Employees.csv&#39;) departamentos &lt;- read_csv(&#39;dados/Departments.csv&#39;) str(empregados) ## tibble [6 × 4] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ Employee : num [1:6] 1 2 3 4 5 6 ## $ EmployeeName: chr [1:6] &quot;Alice&quot; &quot;Bob&quot; &quot;Carla&quot; &quot;Daniel&quot; ... ## $ Department : num [1:6] 11 11 12 12 13 21 ## $ Salary : num [1:6] 800 600 900 1000 800 700 ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. Employee = col_double(), ## .. EmployeeName = col_character(), ## .. Department = col_double(), ## .. Salary = col_double() ## .. ) str(departamentos) ## tibble [4 × 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ Department : num [1:4] 11 12 13 14 ## $ DepartmentName: chr [1:4] &quot;Production&quot; &quot;Sales&quot; &quot;Marketing&quot; &quot;Research&quot; ## $ Manager : num [1:4] 1 4 5 NA ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. Department = col_double(), ## .. DepartmentName = col_character(), ## .. Manager = col_double() ## .. ) empregados ## # A tibble: 6 x 4 ## Employee EmployeeName Department Salary ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Alice 11 800 ## 2 2 Bob 11 600 ## 3 3 Carla 12 900 ## 4 4 Daniel 12 1000 ## 5 5 Evelyn 13 800 ## 6 6 Ferdinand 21 700 departamentos ## # A tibble: 4 x 3 ## Department DepartmentName Manager ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 11 Production 1 ## 2 12 Sales 4 ## 3 13 Marketing 5 ## 4 14 Research NA final &lt;- empregados %&gt;% inner_join(departamentos, by = c(&#39;Employee&#39; = &#39;Manager&#39;)) final ## # A tibble: 3 x 6 ## Employee EmployeeName Department.x Salary Department.y DepartmentName ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Alice 11 800 11 Production ## 2 4 Daniel 12 1000 12 Sales ## 3 5 Evelyn 13 800 13 Marketing Novamente tivemos o mesmo efeito, listamos apenas os empregados que são gerentes de departamento. Acontece que existem situações em que esse descarte de registro do inner join não é interessante. Nesses casos usamos outros tipos de join: os Outer Joins. Existem três tipos básicos de outer join: left outer join (ou só left join), right outer join (ou só right join) e full outer join (ou apenas full join). 6.2.2 Left Outer Join Chama-se LEFT outer join pois todos os registros do “conjunto à esquerda” estarão presentes no resultado final, além dos registros à direita que coincidirem na chave. Podemos usar no caso a seguir: band_members %&gt;% left_join(band_instruments2, by = c(&#39;name&#39; = &#39;artist&#39;)) ## # A tibble: 3 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass band_instruments2 ## # A tibble: 3 x 2 ## artist plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar Reparem no efeito: mesmo Mick não tendo referência no conjunto de dados “à direita” (band_instruments2), ele apareceu no registro final com NA, no campo que diz respeito ao conjunto à direita. Da mesma forma, Keith não está presente no conjunto final, pois não tem referência no conjunto à esquerda. Figura 6.4: Cruzamento de tabelas Repare que a “posição” das tabelas faz diferença. No caso da nossa manipulação de exmeplo, aplicamos o left join pois a tabela que queríamos preservar estava “à esquerda” na manipulação. final2 &lt;- empregados %&gt;% left_join(departamentos, by = c(&#39;Employee&#39; = &#39;Manager&#39;)) final2 ## # A tibble: 6 x 6 ## Employee EmployeeName Department.x Salary Department.y DepartmentName ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Alice 11 800 11 Production ## 2 2 Bob 11 600 NA &lt;NA&gt; ## 3 3 Carla 12 900 NA &lt;NA&gt; ## 4 4 Daniel 12 1000 12 Sales ## 5 5 Evelyn 13 800 13 Marketing ## 6 6 Ferdinand 21 700 NA &lt;NA&gt; 6.2.3 Right Outer Join O princípio é EXATAMENTE o mesmo do left join. A única diferença é a permanência dos registros do conjunto à direita. Podemos chegar ao mesmo resultado anterior apenas mudando os data frames de posição na manipulação. final3 &lt;- departamentos %&gt;% right_join(empregados, by = c(&#39;Manager&#39;=&#39;Employee&#39;)) final3 ## # A tibble: 6 x 6 ## Department.x DepartmentName Manager EmployeeName Department.y Salary ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 Production 1 Alice 11 800 ## 2 12 Sales 4 Daniel 12 1000 ## 3 13 Marketing 5 Evelyn 13 800 ## 4 NA &lt;NA&gt; 2 Bob 11 600 ## 5 NA &lt;NA&gt; 3 Carla 12 900 ## 6 NA &lt;NA&gt; 6 Ferdinand 21 700 final2 ## # A tibble: 6 x 6 ## Employee EmployeeName Department.x Salary Department.y DepartmentName ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Alice 11 800 11 Production ## 2 2 Bob 11 600 NA &lt;NA&gt; ## 3 3 Carla 12 900 NA &lt;NA&gt; ## 4 4 Daniel 12 1000 12 Sales ## 5 5 Evelyn 13 800 13 Marketing ## 6 6 Ferdinand 21 700 NA &lt;NA&gt; A escolha entre right join e left join depende completamente da ordem em que você escolher realizar as operações. Via de regra, um pode ser substituído pelo outro, desde que a posição dos data frames se ajuste na sequência das manipulações. 6.2.4 Full Outer Join Existem, ainda, as situações em que é necessário preservar todos os registros de ambos os conjuntos de dados. O full join tem essa característica. Nenhum dos conjuntos de dados perderá registros no resultado final, isto é, quando as chaves forem iguais, todos os campos estarão preenchidos. Quando não houver ocorrência das chaves em ambos os lados, será informado NA em qualquer um deles. band_members %&gt;% full_join(band_instruments2, by = c(&#39;name&#39; = &#39;artist&#39;)) ## # A tibble: 4 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass ## 4 Keith &lt;NA&gt; guitar Reparem que, dessa vez, não perdemos nenhum registro, de nenhum conjunto de dados, apenas teremos NA quando a ocorrência da chave não acontecer em alguns dos conjuntos. O full join funciona da seguinte forma: Figura 6.5: Cruzamento de tabelas final4 &lt;- departamentos %&gt;% full_join(empregados, by = c(&#39;Manager&#39;=&#39;Employee&#39;)) final4 ## # A tibble: 7 x 6 ## Department.x DepartmentName Manager EmployeeName Department.y Salary ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 Production 1 Alice 11 800 ## 2 12 Sales 4 Daniel 12 1000 ## 3 13 Marketing 5 Evelyn 13 800 ## 4 14 Research NA &lt;NA&gt; NA NA ## 5 NA &lt;NA&gt; 2 Bob 11 600 ## 6 NA &lt;NA&gt; 3 Carla 12 900 ## 7 NA &lt;NA&gt; 6 Ferdinand 21 700 Do resultado desse full join, por exemplo, podemos concluir que não tem nenhum Manager no departamento Resarch, da mesma forma, os empregados Bob, Carla e Ferdinand não são managers de departamento nenhum. 6.3 Exercícios Utilizando as bases de dados do pacote nycflights13, encontre a tabela abaixo que mostra quais aeroportos (origem e destino) tiveram mais voos. Será necessário utilizar o dataframe flights e airports. Dica: primeiro descubra as chaves. ## `summarise()` regrouping output by &#39;Origem&#39; (override with `.groups` argument) ## # A tibble: 217 x 3 ## # Groups: Origem [3] ## Origem Destino qtd ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 John F Kennedy Intl Los Angeles Intl 11262 ## 2 La Guardia Hartsfield Jackson Atlanta Intl 10263 ## 3 La Guardia Chicago Ohare Intl 8857 ## 4 John F Kennedy Intl San Francisco Intl 8204 ## 5 La Guardia Charlotte Douglas Intl 6168 ## 6 Newark Liberty Intl Chicago Ohare Intl 6100 ## 7 John F Kennedy Intl General Edward Lawrence Logan Intl 5898 ## 8 La Guardia Miami Intl 5781 ## 9 John F Kennedy Intl Orlando Intl 5464 ## 10 Newark Liberty Intl General Edward Lawrence Logan Intl 5327 ## # … with 207 more rows Utilizando os dataframes abaixo, chegue no resultado a seguir: participantes &lt;- data.frame( Nome = c(&#39;Carlos&#39;, &#39;Maurício&#39;, &#39;Ana Maria&#39;, &#39;Rebeca&#39;, &#39;Patrícia&#39;), Estado = c(&#39;Brasília&#39;, &#39;Minas Gerais&#39;, &#39;Goiás&#39;, &#39;São Paulo&#39;, &#39;Ceará&#39;), Idade = c(23, 24, 22, 29, 28) ) aprovados &lt;- data.frame( Nome = c(&#39;Carlos&#39;, &#39;Patrícia&#39;), Pontuacao = c(61, 62) ) eliminados &lt;- data.frame( Nome = c(&#39;Maurício&#39;, &#39;Ana Maria&#39;, &#39;Rebeca&#39;), Pontuacao = c(49, 48, 48) ) participantes ## Nome Estado Idade ## 1 Carlos Brasília 23 ## 2 Maurício Minas Gerais 24 ## 3 Ana Maria Goiás 22 ## 4 Rebeca São Paulo 29 ## 5 Patrícia Ceará 28 aprovados ## Nome Pontuacao ## 1 Carlos 61 ## 2 Patrícia 62 eliminados ## Nome Pontuacao ## 1 Maurício 49 ## 2 Ana Maria 48 ## 3 Rebeca 48 ## Nome Estado Idade Pontuacao Resultado ## 1 Carlos Brasília 23 61 Aprovado ## 2 Maurício Minas Gerais 24 49 Eliminado ## 3 Ana Maria Goiás 22 48 Eliminado ## 4 Rebeca São Paulo 29 48 Eliminado ## 5 Patrícia Ceará 28 62 Aprovado 6.4 Exercícios gerais do Tidyverse Para fazer as questões abaixo será necessário usar funções também dos capítulos anteriores. Carregue os pacotes tidyverse e janitor. Baixe o dataset de Super Heróis do Kaggle. Descompacte o arquivo e importe os dois arquivos para o R: salve o arquivo super_hero_powers.csv no objeto hero_powers e o arquivo heroes_information.csv no objeto hero_info. Use também na função read_csv o argumento na = c(&quot;&quot;, &quot;-&quot;, &quot;NA&quot;)) para que linhas com traço ou vazias sejam convertidas para NA. Observe as colunas presentes nos datasets usando a função glimpse. Use a função janitor::clean_names() para limpar os nomes das colunas. No caso de hero_info, remova a primeira coluna. Em hero_powers, converta todas as colunas com exceção da primeira para o tipo logical. Em hero_info, na coluna publisher, observe quantas editoras diferentes existem no dataset. Substitua Marvel Comics por Marvel, DC Comics por DC e todas as outras editoras pelo termo “Outros”. Dica: uma das possíveis maneiras de fazer isso é usando uma combinação das funções dplyr::mutate() e dplyr::case_when(). Em hero_info, quais raças (coluna race) são exclusivas de cada editora? Em hero_info, quais cores de olhos (coluna eye_color) são mais comuns para cada sexo (coluna gender)? Filtre o top 3 para cadda sexo. Em hero_powers, calcule o percentual de heróis que possui cada habilidade descrita nas colunas (Dica: é possível calcular a soma ou percentual de um vetor lógico, pois TRUE equivale a 1 e FALSE a 0). Use a função dplyr::summarise_if para aplicar a função em todas as colunas cuja classe é logical. Repita o item anterior, usando uma abordagem mais tidy: converta o formato do dataframe hero_powers para o formato long. Ele passará a possuir apenas 3 colunas: hero_names, poder e possui_poder usando a função tidyr::gather(). Então, calcule a média da coluna possui_poder agrupado pela coluna poder. Junte os dois dataframes em um só, chamado hero. A função a ser usada é inner_join(). Pense bem em qual será a ordem dos dataframes nos argumentos da função e qual será a chave usada no argumento by para unir as duas tabelas. No dataframe hero, calcule o percentual de herois de cada editora que são telepatas. No dataframe hero, selecione as colunas name, publisher, flight e weight, filtre os heróis que podem voar e retorne os 10 de maior peso. Salve o dataframe chamado hero no arquivo herois_completo.csv usando a função readr::write_csv(). "],
["dados-em-strings-texto.html", "7 Dados em strings (texto) 7.1 Pacote stringr 7.2 Regex 7.3 Exercícios", " 7 Dados em strings (texto) Neste capítulo, usaremos estes pacotes: library(stringr) library(literaturaBR) # remotes::install_github(&quot;sillasgonzaga/literaturaBR&quot;) Manipulação de texto também é algo importante em ciência de dados, pois nem tudo são números, existem variáveis categóricas que são baseadas em texto. Mais uma vez, esse tipo de manipulação depende do tipo de arquivo que você receber. a &lt;- &#39;texto 1&#39; b &lt;- &#39;texto 2&#39; c &lt;- &#39;texto 3&#39; paste(a, b, c) ## [1] &quot;texto 1 texto 2 texto 3&quot; O paste() é a função mais básica para manipulação de textos usando o R base. Ela concatena todas as variáveis textuais que você informar. Existe um parâmetro extra (sep) cujo valor padrão é espaço . paste(a, b, c, sep = &#39;-&#39;) ## [1] &quot;texto 1-texto 2-texto 3&quot; paste(a, b, c, sep = &#39;;&#39;) ## [1] &quot;texto 1;texto 2;texto 3&quot; paste(a, b, c, sep = &#39;---%---&#39;) ## [1] &quot;texto 1---%---texto 2---%---texto 3&quot; 7.1 Pacote stringr Texto no R é sempre do tipo character. No universo da computação, também se referem a texto como string. E é daí que vem o nome desse pacote, também criado por Hadley Wickham. Por acaso, este pacote não está incluído no tidyverse. library(stringr) ?stringr Referências: Site do pacote stringr 7.1.1 Extrair parte de uma string Começaremos pela função str_sub(), que extrai apenas parte de um texto. cnae.texto &lt;- c(&#39;10 Fabricação de produtos alimentícios&#39;, &#39;11 Fabricação de bebidas&#39;, &#39;12 Fabricação de produtos do fumo&#39;, &#39;13 Fabricação de produtos têxteis&#39;, &#39;14 Confecção de artigos do vestuário e acessórios&#39;, &#39;15 Preparação de couros e fabricação de artefatos de couro, artigos para viagem e calçados&#39;, &#39;16 Fabricação de produtos de madeira&#39;, &#39;17 Fabricação de celulose, papel e produtos de papel&#39;) cnae &lt;- str_sub(cnae.texto, 0, 2) texto &lt;- str_sub(cnae.texto, 4) cnae ## [1] &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; texto ## [1] &quot;Fabricação de produtos alimentícios&quot; ## [2] &quot;Fabricação de bebidas&quot; ## [3] &quot;Fabricação de produtos do fumo&quot; ## [4] &quot;Fabricação de produtos têxteis&quot; ## [5] &quot;Confecção de artigos do vestuário e acessórios&quot; ## [6] &quot;Preparação de couros e fabricação de artefatos de couro, artigos para viagem e calçados&quot; ## [7] &quot;Fabricação de produtos de madeira&quot; ## [8] &quot;Fabricação de celulose, papel e produtos de papel&quot; Referências: Documentação da função str_sub() 7.1.2 Substituir caracteres em um string Temos também a função str_replace() e str_replace_all(), que substituem determinados caracteres por outros. Tal como no exemplo a seguir: telefones &lt;- c(&#39;9931-9572&#39;, &#39;8591-5772&#39;, &#39;8562-1923&#39;) str_replace(telefones, &#39;-&#39;, &#39;&#39;) ## [1] &quot;99319572&quot; &quot;85915772&quot; &quot;85621923&quot; cnpj &lt;- c(&#39;19.702.231/9999-98&#39;, &#39;19.498.482/9999-05&#39;, &#39;19.499.583/9999-50&#39;, &#39;19.500.999/9999-46&#39;, &#39;19.501.139/9999-90&#39;) str_replace_all(cnpj, &#39;\\\\.|/|-&#39;, &#39;&#39;) ## [1] &quot;19702231999998&quot; &quot;19498482999905&quot; &quot;19499583999950&quot; &quot;19500999999946&quot; &quot;19501139999990&quot; O que são esses símbolos no segundo exemplo? São símbolos especiais utilizados em funções textuais para reconhecimento de padrão. Esses símbolos são conhecidos como Expressões Regulares ou o famoso Regex, que veremos logo a seguir. Uma função mais generalizada que str_replace() é a str_glue(): meu_nome &lt;- &quot;Fulano&quot; x &lt;- c(&quot;Prazer, sou o {meu_nome}&quot;) print(x) ## [1] &quot;Prazer, sou o {meu_nome}&quot; str_glue(x) ## Prazer, sou o Fulano Referências: Documentação da função str_replace() Documentação da função str_glue() 7.1.3 Buscar correspondências em um string A função str_count() pode ser usada para esse objetivo: str_count(telefones, &quot;7&quot;) ## [1] 1 2 0 Para saber se um string contem um determinado padrão, basta usar str_detect(): str_detect(telefones, &quot;7&quot;) ## [1] TRUE TRUE FALSE # isso é equivalente a str_count(telefones, &quot;7&quot;) &gt; 0 ## [1] TRUE TRUE FALSE Para correspondências mais específicas, como no início ou no final, pode-se usar as funções str_starts() e str_ends(): telefones ## [1] &quot;9931-9572&quot; &quot;8591-5772&quot; &quot;8562-1923&quot; str_starts(telefones, &quot;9&quot;) ## [1] TRUE FALSE FALSE str_ends(telefones, &quot;0&quot;) ## [1] FALSE FALSE FALSE Referências: Documentação da função str_count() Documentação da função str_detect() 7.1.4 Complementar uma string Isso é essencialmente útil para transformar números em string sem perder a ordem alfabética. str_pad() adicionar um determinado character no início (ou no final, isso pode ser especificado pelo usuário) até que um string atinja uma determinada quantidade de caracteres. Por exemplo, sabe-se que um CPF, contando apenas os algarismos, contem 11 caracteres. Contudo, o que fazer quando você recebe um dado numérico, sem zeros a esquerda? Veja o exemplo abaixo: cpfs &lt;- c(1234, 01833827570, 45614814570, 4, 4000001111) Basta usar a função str_pad() para complementar a string acrescentando zeros a esquerda até cada string conter 11 caracteres: str_pad(cpfs, width = 11, pad = &quot;0&quot;) ## [1] &quot;00000001234&quot; &quot;01833827570&quot; &quot;45614814570&quot; &quot;00000000004&quot; &quot;04000001111&quot; Veja que o terceiro elemento do vetor, que já continha 11 caracteres, não foi alterado. Referências: Documentação da função str_pad() 7.1.5 Remover espaços em branco desnecessários Quando se lida com texto, é comum recebermos dados com excesso de espaço em branco, como nestes exemplos: x &lt;- c(&quot; inicio&quot;, &quot;final &quot;, &quot; ambos &quot;, &quot; no meio &quot;) x ## [1] &quot; inicio&quot; &quot;final &quot; &quot; ambos &quot; ## [4] &quot; no meio &quot; # conferindo o tamanho dos strings str_length(x) ## [1] 12 11 17 25 Para isso, existe a função str_trim(), que remove espaços em branco seguidos no início e no final do string: x2 &lt;-str_trim(x) x2 ## [1] &quot;inicio&quot; &quot;final&quot; &quot;ambos&quot; &quot;no meio&quot; # conferindo o tamanho do vetor limp str_length(x2) ## [1] 6 5 5 13 A função não limpou os espaços em branco seguidos no último elemento. Para isso, você pode usar uma função mais generalizada, chamada str_squish(): x2b &lt;- str_squish(x) x2b ## [1] &quot;inicio&quot; &quot;final&quot; &quot;ambos&quot; &quot;no meio&quot; str_length(x2b) ## [1] 6 5 5 7 7.2 Regex Trata-se de um assunto bastante complexo e avançado. Não é fácil dominar regex e provavelmente você vai precisar sempre consultar e experimentar a montagem dos padrões de regex. Infelizmente não é possível aprender regex rápido e de um jeito fácil, só existe o jeito difícil: errando muito, com muita prática e experiências reais. A seguir, uma lista dos principais mecanismos de regex: regex correspondência ^ começa do string (ou uma negação) . qualquer caractere $ fim da linha [maça] procura os caracteres m, a, ç maça maça [0-9] números [A-Z] qualquer letra maiúscula \\\\w uma palavra \\\\W não é palavra (pontuação, espaço etc.) \\\\s um espaço (tab, newline, space) Vamos então aplicar as regex acima em um conjunto de strings: textos &lt;- c(&quot;Fulano&quot;, &quot;fulano&quot;, &quot;abcdeF&quot;, &quot;01584&quot;, &quot;abc456&quot;, &quot;123def&quot;, &quot;OI&quot;, &quot;meuemail@gmail.com&quot;, &quot;www.google.com&quot;, &quot;Meu nome é Fulano&quot;) # detectar strings que contem F maiusculo str_detect(textos, &quot;F&quot;) ## [1] TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE # detectar strings que começam com F maiúsculo str_detect(textos, &quot;^F&quot;) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE # detectar strings que começam com F, independente se maiúsculo ou minúsculo str_detect(textos, regex(&quot;^F&quot;, ignore_case = TRUE)) ## [1] TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE str_subset() é uma generalização de str_detect() que filtra os elementos em que str_detect() retorna TRUE: # filtrar strings que terminam com o str_subset(textos, &quot;o$&quot;) ## [1] &quot;Fulano&quot; &quot;fulano&quot; &quot;Meu nome é Fulano&quot; # strings que contem um algarismo str_subset(textos, &quot;\\\\d&quot;) ## [1] &quot;01584&quot; &quot;abc456&quot; &quot;123def&quot; str_subset(textos, &quot;[0-9]&quot;) ## [1] &quot;01584&quot; &quot;abc456&quot; &quot;123def&quot; # strings que terminam com um algarismo str_subset(textos, &quot;\\\\d$&quot;) ## [1] &quot;01584&quot; &quot;abc456&quot; # strings que nao contem algarismo str_subset(textos, &quot;\\\\d&quot;, negate = TRUE) ## [1] &quot;Fulano&quot; &quot;fulano&quot; &quot;abcdeF&quot; &quot;OI&quot; &quot;meuemail@gmail.com&quot; ## [6] &quot;www.google.com&quot; &quot;Meu nome é Fulano&quot; # strings que contem um ponto str_subset(textos, &quot;\\\\.&quot;) ## [1] &quot;meuemail@gmail.com&quot; &quot;www.google.com&quot; # strings que contem um espaço str_subset(textos, &quot;\\\\s&quot;) ## [1] &quot;Meu nome é Fulano&quot; A seguir, alguns bons sites para aprender mais sobre regex. É um assunto interessante e bastante utilizado para tratamento textual. http://turing.com.br/material/regex/introducao.html https://regexone.com/ 7.3 Exercícios Utilizando o dataframe abaixo, obtenha o resultado a seguir: Dica: separate(), str_replace_all(), str_trim(), str_sub() cadastros &lt;- data.frame( email = c(&#39;joaodasilva@gmail.com&#39;, &#39;rafael@hotmail.com&#39;, &#39;maria@uol.com.br&#39;, &#39;juliana.morais@outlook.com&#39;), telefone = c(&#39;(61)99831-9482&#39;, &#39;32 8976 2913&#39;, &#39;62-9661-1234&#39;, &#39;15-40192.5812&#39;) ) cadastros ## email telefone ## 1 joaodasilva@gmail.com (61)99831-9482 ## 2 rafael@hotmail.com 32 8976 2913 ## 3 maria@uol.com.br 62-9661-1234 ## 4 juliana.morais@outlook.com 15-40192.5812 ## login dominio telefone dd ## 1 joaodasilva gmail 99831-9482 61 ## 2 rafael hotmail 8976-2913 32 ## 3 maria uol 9661-1234 62 ## 4 juliana.morais outlook 40192-5812 15 Baixe o pacote literaturaBR. Como ele não está no CRAN, é necessário usar outra função: remotes::install_github(&quot;sillasgonzaga/literaturaBR&quot;) Importe o dataframe com os livros: library(literaturaBR) df_livros &lt;- literaturaBR::load_all_books() head(df_livros) ## book_name chapter_name url paragraph_number ## alienista.1 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 1 ## alienista.2 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 2 ## alienista.3 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 3 ## alienista.4 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 4 ## alienista.5 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 5 ## alienista.6 O Alienista Capítulo I https://pt.wikisource.org/wiki/O_Alienista/I 6 ## text ## alienista.1 As crônicas da vila de Itaguaí dizem que em tempos remotos vivera ali um certo médico, o Dr. Simão Bacamarte, filho da nobreza da terra e o maior dos médicos do Brasil, de Portugal e das Espanhas. Estudara em Coimbra e Pádua. Aos trinta e quatro anos regressou ao Brasil, não podendo el-rei alcançar dele que ficasse em Coimbra, regendo a universidade, ou em Lisboa, expedindo os negócios da monarquia. ## alienista.2 —A ciência, disse ele a Sua Majestade, é o meu emprego único; Itaguaí é o meu universo. ## alienista.3 Dito isso, meteu-se em Itaguaí, e entregou-se de corpo e alma ao estudo da ciência, alternando as curas com as leituras, e demonstrando os teoremas com cataplasmas. Aos quarenta anos casou com D. Evarista da Costa e Mascarenhas, senhora de vinte e cinco anos, viúva de um juiz de fora, e não bonita nem simpática. Um dos tios dele, caçador de pacas perante o Eterno, e não menos franco, admirou-se de semelhante escolha e disse-lho. Simão Bacamarte explicou-lhe que D. Evarista reunia condições fisiológicas e anatômicas de primeira ordem, digeria com facilidade, dormia regularmente, tinha bom pulso e excelente vista; estava assim apta para dar-lhe filhos robustos, sãos e inteligentes. Se além dessas prendas,—únicas dignas da preocupação de um sábio, —D. Evarista era mal composta de feições, longe de lastimá-lo, agradecia-o a Deus, porquanto não corria o risco de preterir os interesses da ciência na contemplação exclusiva, miúda e vulgar da consorte. ## alienista.4 D. Evarista mentiu às esperanças do Dr. Bacamarte, não lhe deu filhos robustos nem mofinos. A índole natural da ciência é a longanimidade; o nosso médico esperou três anos, depois quatro, depois cinco. Ao cabo desse tempo fez um estudo profundo da matéria, releu todos os escritores árabes e outros, que trouxera para Itaguaí, enviou consultas às universidades italianas e alemãs, e acabou por aconselhar à mulher um regímen alimentício especial. A ilustre dama, nutrida exclusivamente com a bela carne de porco de Itaguaí, não atendeu às admoestações do esposo; e à sua resistência,—explicável, mas inqualificável,— devemos a total extinção da dinastia dos Bacamartes. ## alienista.5 Mas a ciência tem o inefável dom de curar todas as mágoas; o nosso médico mergulhou inteiramente no estudo e na prática da medicina. Foi então que um dos recantos desta lhe chamou especialmente a atenção,—o recanto psíquico, o exame de patologia cerebral. Não havia na colônia, e ainda no reino, uma só autoridade em semelhante matéria, mal explorada, ou quase inexplorada. Simão Bacamarte compreendeu que a ciência lusitana, e particularmente a brasileira, podia cobrir-se de &quot;louros imarcescíveis&quot;, — expressão usada por ele mesmo, mas em um arroubo de intimidade doméstica; exteriormente era modesto, segundo convém aos sabedores. ## alienista.6 —A saúde da alma, bradou ele, é a ocupação mais digna do médico. Quebre cada linha da coluna text em varias, tendo uma palavra por linha, usando separate_rows(), e filtre as linhas da nova coluna que contem apenas letras. Salve em um novo dataframe chamado df_livros_sep. Calcule o numero de palavras distintas em proporção à quantidade total de palavras por livro Calcule a proporção de palavras que contem a letra a por livro. "],
["trabalhando-com-datas.html", "8 Trabalhando com datas 8.1 Gerar um vetor sequencial de datas 8.2 ‘Parsear’ datas e horários 8.3 Extrair componentes de uma data 8.4 Operações matemáticas com datas", " 8 Trabalhando com datas Datas são um caso a parte no R. Existe uma própria classe para objetos desse tipo, chamada Date, com D maiúsculo. O R lida com datas no formato AAAA-MM-DD (Ano, Mês e Dia). Abaixo, definimos um vetor com datas x &lt;- c(&quot;2014-07-15&quot;, &quot;2018/03/20&quot;, &quot;2019-12-31&quot;, &quot;20170511&quot;) as.Date(x) ## [1] &quot;2014-07-15&quot; NA &quot;2019-12-31&quot; NA class(as.Date(x)) ## [1] &quot;Date&quot; Perceba que o R nativamente não aceita qualquer separador entre o ano, o mês e o dia, apenas o traço. O pacote lubridate, que faz parte da família tidyverse, possui uma versão mais generalizável para isso: library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union lubridate::as_date(x) ## [1] &quot;2014-07-15&quot; &quot;2018-03-20&quot; &quot;2019-12-31&quot; &quot;2017-05-11&quot; A propósito, dominar o pacote lubridate, que possui funções muito simples de usar, é a única coisa necessária para saber lidar com datas no R. Por isso, este capítulo se dedica a mostrar as principais funções do pacote. 8.1 Gerar um vetor sequencial de datas Essa tarefa é feita usando uma função nativa do R chamada seq.Date(), que possui quatro argumentos principais, sendo que três deles precisam ser especificados. args(seq.Date) ## function (from, to, by, length.out = NULL, along.with = NULL, ## ...) ## NULL # gerar vetor de datas separadas por mes seq.Date(from = as_date(&quot;2020-01-01&quot;), to = as_date(&quot;2020-12-01&quot;), by = &quot;1 month&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-02-01&quot; &quot;2020-03-01&quot; &quot;2020-04-01&quot; &quot;2020-05-01&quot; &quot;2020-06-01&quot; &quot;2020-07-01&quot; &quot;2020-08-01&quot; ## [9] &quot;2020-09-01&quot; &quot;2020-10-01&quot; &quot;2020-11-01&quot; &quot;2020-12-01&quot; # gerar vetor de datas separadas por dia seq.Date(from = as_date(&quot;2020-01-01&quot;), to = as_date(&quot;2020-01-20&quot;), by = &quot;1 day&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-01-02&quot; &quot;2020-01-03&quot; &quot;2020-01-04&quot; &quot;2020-01-05&quot; &quot;2020-01-06&quot; &quot;2020-01-07&quot; &quot;2020-01-08&quot; ## [9] &quot;2020-01-09&quot; &quot;2020-01-10&quot; &quot;2020-01-11&quot; &quot;2020-01-12&quot; &quot;2020-01-13&quot; &quot;2020-01-14&quot; &quot;2020-01-15&quot; &quot;2020-01-16&quot; ## [17] &quot;2020-01-17&quot; &quot;2020-01-18&quot; &quot;2020-01-19&quot; &quot;2020-01-20&quot; # gerar vetor de datas separadas por 3 dias seq.Date(from = as_date(&quot;2020-01-01&quot;), to = as_date(&quot;2020-01-20&quot;), by = &quot;3 day&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-01-04&quot; &quot;2020-01-07&quot; &quot;2020-01-10&quot; &quot;2020-01-13&quot; &quot;2020-01-16&quot; &quot;2020-01-19&quot; # gerar um vetor de 7 semanas separados por 1 semana seq.Date(from = as_date(&quot;2020-01-01&quot;), length.out = 7, by = &quot;1 week&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-01-08&quot; &quot;2020-01-15&quot; &quot;2020-01-22&quot; &quot;2020-01-29&quot; &quot;2020-02-05&quot; &quot;2020-02-12&quot; 8.2 ‘Parsear’ datas e horários Para fazer o R converter (ou parsear na linguagem de programação) um string em data, basta usar as funções correspondentes do lubridate. Por exemplo, no vetor de exemplo x, definido acima, as datas já estavam definidas no formato correto: AAAA-MM-DD. Aqui no Brasil usamos outro formato: DD/MM/AAAA. O lubridate possui uma função pronta para essa situação: # observer como usamos diferentes separadores datas_brasil &lt;- c(&quot;01/12/2019&quot;, &quot;20/11/2018&quot;, &quot;30011990&quot;, &quot;17-03-2000&quot;) # parseando o vetor acima para Data dmy(datas_brasil) ## [1] &quot;2019-12-01&quot; &quot;2018-11-20&quot; &quot;1990-01-30&quot; &quot;2000-03-17&quot; Caso o vetor também contenha dados de horário, basta incluir o sufixo referente a hora, minuto e segundo: dmy_hms(&quot;30-09-2019 14:51:39&quot;) ## [1] &quot;2019-09-30 14:51:39 UTC&quot; # sem o segundo dmy_hm(&quot;30-09-2019 14:15&quot;) ## [1] &quot;2019-09-30 14:15:00 UTC&quot; # apenas a hora dmy_h(&quot;30-09-2019 15&quot;) ## [1] &quot;2019-09-30 15:00:00 UTC&quot; 8.3 Extrair componentes de uma data É possível extrair qualquer tipo de componente de uma data ou de um vetor de datas com o lubridate. Veja alguns exemplos: datas_brasil &lt;- dmy_hms(c(&quot;01/12/2019 13:51:15&quot;, &quot;20/11/2018 00:00:00&quot;, &quot;30011990 080000&quot;, &quot;17-03-2000 203000&quot;)) datas_brasil ## [1] &quot;2019-12-01 13:51:15 UTC&quot; &quot;2018-11-20 00:00:00 UTC&quot; &quot;1990-01-30 08:00:00 UTC&quot; &quot;2000-03-17 20:30:00 UTC&quot; # extrair componentes da data: # ano year(datas_brasil) ## [1] 2019 2018 1990 2000 # mes month(datas_brasil) ## [1] 12 11 1 3 # dia day(datas_brasil) ## [1] 1 20 30 17 # semana do ano week(datas_brasil) ## [1] 48 47 5 11 # dia da semana wday(datas_brasil, label = TRUE) ## [1] dom ter ter sex ## Levels: dom &lt; seg &lt; ter &lt; qua &lt; qui &lt; sex &lt; sáb # trimestre quarter(datas_brasil) ## [1] 4 4 1 1 # hora hour(datas_brasil) ## [1] 13 0 8 20 8.4 Operações matemáticas com datas Geralmente se está interessado em fazer três tipos de operações matemáticas com datas: Adicionar uma quantidade N de dias/meses/anos/etc em uma data: # adicionar 1 semana nas datas datas_brasil + ddays(7) ## [1] &quot;2019-12-08 13:51:15 UTC&quot; &quot;2018-11-27 00:00:00 UTC&quot; &quot;1990-02-06 08:00:00 UTC&quot; &quot;2000-03-24 20:30:00 UTC&quot; # adicionar 3 meses datas_brasil + ddays(90) ## [1] &quot;2020-02-29 13:51:15 UTC&quot; &quot;2019-02-18 00:00:00 UTC&quot; &quot;1990-04-30 08:00:00 UTC&quot; &quot;2000-06-15 20:30:00 UTC&quot; # adicionar 1 ano datas_brasil + dyears(1) ## [1] &quot;2020-11-30 19:51:15 UTC&quot; &quot;2019-11-20 06:00:00 UTC&quot; &quot;1991-01-30 14:00:00 UTC&quot; &quot;2001-03-18 02:30:00 UTC&quot; Calcular a diferença de tempo entre duas datas: No R, subtrair datas segue a mesma sintaxe de subtrair números: data1 &lt;- dmy_hms(&quot;01/09/1993 20:00:00&quot;) data2 &lt;- dmy_hms(&quot;24-06-2018 17:00:00&quot;) dif &lt;- data2 - data1 dif ## Time difference of 9061.875 days Por padrão, o R retorna a diferença em dias, mas em um objeto de classe difftime. class(dif) ## [1] &quot;difftime&quot; Recomenda-se então converter o output para a classe numeric: as.numeric(dif) ## [1] 9061.875 Caso se deseje calcular essa diferença em outras unidades de tempo, como meses ou semanas, basta fazer a divisão correspondente: # conveter para semanas as.numeric(dif) / 7 ## [1] 1294.554 # converter para meses as.numeric(dif) / 30 ## [1] 302.0625 # converter para anos as.numeric(dif) / 365 ## [1] 24.82705 Arredondar datas: Para arredondar uma data, por exemplo, retornar o primeiro ou último dia da semana/mês/trimestre/etc de uma data de referência, usa-se as funções ceiling_date() (arredondar para cima) e floor_date() (para baixo): # retornar a primeira data da semana: floor_date(datas_brasil, &quot;week&quot;) ## [1] &quot;2019-12-01 UTC&quot; &quot;2018-11-18 UTC&quot; &quot;1990-01-28 UTC&quot; &quot;2000-03-12 UTC&quot; # retornar a ultima data do mês # por padrao, ceiling_date retorna a primeira data do próximo mês, # por isso é necessario subtrair o resultado por 1 ceiling_date(datas_brasil, &quot;month&quot;) - 1 ## [1] &quot;2019-12-31 23:59:59 UTC&quot; &quot;2018-11-30 23:59:59 UTC&quot; &quot;1990-01-31 23:59:59 UTC&quot; &quot;2000-03-31 23:59:59 UTC&quot; # arredondar usando a hora como referencia floor_date(datas_brasil, &quot;hour&quot;) ## [1] &quot;2019-12-01 13:00:00 UTC&quot; &quot;2018-11-20 00:00:00 UTC&quot; &quot;1990-01-30 08:00:00 UTC&quot; &quot;2000-03-17 20:00:00 UTC&quot; "],
["escrevendo-dados.html", "9 Escrevendo dados 9.1 Escrevendo csv 9.2 Rds 9.3 Escrevendo outros tipos de arquivos 9.4 Exercícios", " 9 Escrevendo dados Já na fase final da sua análise, pode ser que apareça a necessidade de gerar-se arquivos: gráficos, relatórios, planilhas, pdf, arquivos de dados etc. Da mesma forma que você consome dados e relatórios, talvez você precise produzir e divulgar dados e relatórios para outras pessoas analisarem, ou mesmo para publicação. 9.1 Escrevendo csv O formato mais básico e mais utilizado, mundialmente, para envio e recebimento de dados entre instituições é o csv. Escrever um arquivo de dados em csv é muito simples. Dentre as opções, recomenda-se usar as funções de escrever dados do pacote readr. A diferença as funções read_csv() ou write_csv() e read_csv2() e write_csv2() é que as primeiras usam vírgula como delimitador de colunas e ponto como separador de decimais, já as duas últimas usam ponto e vírgula e vírgula, respectivamente. data(iris) readr::write_csv(iris, &quot;iris.csv&quot;) readr::write_csv2(iris, &quot;iris2.csv&quot;) 9.2 Rds Objetos rds são arquivos próprios do R e servem para salvar em arquivo local qualquer tipo de estrutura de dados, mantendo sempre todas as propriedades do objeto original. Arquivos rds podem ser salvos com a função write_rds(), do pacote readr. Para importar um arquivo rds, basta usar readr::read_rds(). participantes &lt;- tibble( Nome = c(&#39;Carlos&#39;, &#39;Maurício&#39;, &#39;Ana Maria&#39;, &#39;Rebeca&#39;, &#39;Patrícia&#39;), Estado = c(&#39;Brasília&#39;, &#39;Minas Gerais&#39;, &#39;Goiás&#39;, &#39;São Paulo&#39;, &#39;Ceará&#39;), Idade = c(23, 24, 22, 29, 28) ) readr::write_rds(participantes, &quot;participantes.rds&quot;) # salvando um vetor meu_vetor &lt;- c(1, 3, 5) write_rds(meu_vetor, &quot;vetor.rds&quot;) 9.3 Escrevendo outros tipos de arquivos Outra forma bastante importante de escrever dados é em planilhas: o famoso Excel. Recomendamos o conhecimento do pacote openxlsx. É um pacote que lê e escreve arquivos Excel sem nenhuma dependência de Java, que pode acabar dando muita dor de cabeça para manter e normalmente consome bastante memória. Para Windows, o openxlsx precisa do Rtools: https://cran.r-project.org/bin/windows/Rtools/. Recomendamos a experiência com este pacote, pois com ele é possível a criação de planilhas bem acabadas, com cores e formatações complexas. Um outro pacote para escrever arquivos em Excel, mais simples que o openxlsx, é o writexl: writexl::write_xlsx(iris, &quot;iris.xlsx&quot;) Outra forma de escrita de dados é utilizando o RMarkdown, mas este formato merece um capítulo específico para detalhar seu uso. 9.4 Exercícios Escolha qualquer dataframe já trabalhado até agora e escreva-o em csv. "],
["obtendo-dados.html", "10 Obtendo dados 10.1 API 10.2 Web Scrapping", " 10 Obtendo dados A base da ciência de dados é, obviamente, o DADO. Portanto, é fundamental sempre ter boas fontes de dados. Se você der sorte, conseguirá dados estruturados para iniciar sua análise. Porém, eventualmente precisará recorrer a fontes de dados não estruturados ou semiestruturados. Muito provavelmente você algum dia precisará recorrer a uma Application Programming Interface (API) de dados, ou até mesmo precisará utilizar técnicas de Web Scrapping para obter dados diretamente em um próprio site. 10.1 API API é uma forma de comunicação de dados mais apropriada para as trocas de informações entre softwares. Normalmente APIs trocam dados em formato hierárquico. Os dois formatos hierárquicos mais comuns são Javascript Object Notation (JSON) e eXtensible Markup Language (XML). Para obter-se e utilizar-se dados de API em R recomendamos a utilização do pacote jsonlite. library(jsonlite) A seguir apresentaremos alguns exemplos de APIs e seu uso. Existem diversas APIs e formas de consumi-las, portanto não iremos exaurir nesse texto todas as possibilidades de uso de APIs. O principal aqui é entender-se APIs como uma fonte rica de dados que pode ser explorada em suas análises. No exemplo a seguir utilizamos a API do github (portal para repositórios) e veremos quais os repositórios do Hadley Wickham: hadley.rep &lt;- jsonlite::fromJSON(&quot;https://api.github.com/users/hadley/repos&quot;) dim(hadley.rep) ## [1] 30 73 head(hadley.rep[,c(&#39;name&#39;, &#39;description&#39;)], 15) ## name ## 1 15-state-of-the-union ## 2 15-student-papers ## 3 500lines ## 4 adv-r ## 5 amt ## 6 appdirs ## 7 arrow ## 8 assertthat ## 9 babynames ## 10 bayesplot ## 11 beautiful-data ## 12 bench ## 13 bigvis ## 14 bigvis-infovis ## 15 BiocStickers ## description ## 1 &lt;NA&gt; ## 2 Graphics &amp; computing student paper winners @ JSM 2015 ## 3 500 Lines or Less ## 4 Advanced R: a book ## 5 &lt;NA&gt; ## 6 A small Python module for determining appropriate platform-specific dirs, e.g. a &quot;user data dir&quot;. ## 7 Apache Arrow is a cross-language development platform for in-memory data. It specifies a standardized language-independent columnar memory format for flat and hierarchical data, organized for efficient analytic operations on modern hardware. It also provides computational libraries and zero-copy streaming messaging and interprocess communication. Languages currently supported include C, C++, Java, JavaScript, Python, and Ruby. ## 8 User friendly assertions for R ## 9 An R package containing US baby names from the SSA ## 10 bayesplot R package for plotting Bayesian models ## 11 Book chapter for beautiful data ## 12 Bechmarking tools for R ## 13 Exploratory data analysis for large datasets (10-100 million observations) ## 14 Paper describing the bigvis package and framework submitted to Infovis 2013 ## 15 Stickers for some Bioconductor packages - feel free to contribute and/or modify. Outro exemplo de API muito interessante é o portal de dados abertos da Câmara dos Deputados. Eles possuem diversas APIs para consultar os dados do processo legislativo. Veja o exemplo a seguir, que resgata as proposições utilizando API: proposicoes &lt;- jsonlite::fromJSON(&quot;https://dadosabertos.camara.leg.br/api/v2/proposicoes&quot;) head(proposicoes$dados %&gt;% select(siglaTipo, numero, ano, ementa)) ## siglaTipo numero ano ## 1 PL 3968 1997 ## 2 PL 3351 2004 ## 3 PL 4811 2005 ## 4 PL 6229 2005 ## 5 PL 1550 2007 ## 6 REC 108 2011 ## ementa ## 1 Isenta os órgãos públicos e as entidades filantrópicas do pagamento de direitos autorais pelo uso de obras musicais e lítero-musicais em eventos por eles promovidos. ## 2 Altera o art. 1.361 da Lei nº 10.406, de 10 de janeiro de 2002, Código Civil, e dá outras providências. ## 3 Modifica a Lei nº 9.610, de 19 de fevereiro de 1998, isentando as emissoras de radiodifusão educativa e comunitária do pagamento de direitos autorais de obras musicais e litero-musicais. ## 4 Altera o § 7º do art. 6º da Lei nº 11.101, de 9 de fevereiro de 2005, que &quot;Regula a recuperação judicial, a extrajudicial e a falência do empresário e da sociedade empresária&quot;, para submeter todos os créditos tributários à recuperação judicial. ## 5 Altera a Lei nº 9.610, de 1998, isentando do pagamento de direitos autorais as apresentações teatrais e musicais beneficentes e as organizadas por igrejas. ## 6 Recorre contra parecer terminativo da Comissão de Finanças e Tributação ao Projeto de Lei nº 3.776/2008 que &quot;altera a Lei nº 11.738, de 16 de julho de 2008, que regulamenta a alínea &quot;e&quot; do inciso III do caput do art. 60 do Ato das Disposições Constitucionais Transitórias para instituir o piso salarial profissional nacional para os profissionais do magistério público da educação básica. Hoje em dia, todas as redes sociais possuem APIs para consumir os dados dos usuários e postagens. Normalmente essas APIs pedem um cadastro anterior (apesar de gratuitas, em sua maior parte). O R possui diversos pacotes para consumir APIs interessantes: Quandl: pacote que fornece diversos dados econômicos de diversos países; Rfacebook: pacote que facilita o uso da API do facebook (requer cadastro prévio); twitterR: pacote que facilita o uso da API do twitter (requer cadastro prévio); ggmap: pacote que facilita o uso da API do google maps. Sempre procure por APIs para obter dados que possam enriquecer suas análises. 10.2 Web Scrapping Eventualmente você não terá dados estruturados de forma fácil e nem terá uma API com os dados que procura. Nesses casos pode ser que um próprio site da internet seja sua fonte de dados. Para isso utiliza-se técnicas chamadas de Web Scrapping. Sites da internet são construídos utilizando-se uma linguagem que é interpretada pelos browsers: HyperText Markup Language (HTML). Esta é uma linguagem que trabalha com tags de forma hierárquica. Nesse site você pode aprender um pouco mais sobre o que é HTML: http://www.w3schools.com/html/tryit.asp?filename=tryhtml_basic_document Existe um pacote em R que facilita muito o cosumo de dados em HTML: rvest, criado também por Hadley Wickham. O rvest mapeia os elementos HTML (tags) de uma página web e facilita a “navegação” do R por esses nós da árvore do HTML. O pacote funciona da seguinte forma: Um string que contem o link é usado como input da função read_html(). A partir daí as funções do pacote rvest podem ser usadas para extrair dados da página. html_table(), por exemplo, extrai dados tabulares da página. Algo que torna o Web Scraping muito complexo é que essa tarefa é muito dependente do código-fonte da página. Caso ela sofra mudanças, o código provavelmente não irá mais funcionar. Um exemplo é o que se vê neste post sobre Web Scraping do OLX, que não funciona mais. Devido a isso, este material opta por não entrar a fundo no assunto além de mostrar um exemplo superficial abaixo de scraping de uma tabela da Wikipedia: library(rvest) url &lt;- &quot;https://pt.wikipedia.org/wiki/Campeonato_Brasileiro_de_Futebol_de_2018_-_Série_A&quot; %&gt;% read_html() tb &lt;- html_table(url, fill = TRUE) tb &lt;- tb[[6]] tb %&gt;% as_tibble() %&gt;% mutate(SG = ifelse(str_detect(SG,&quot;\\\\+&quot;), readr::parse_number(SG), -1 * readr::parse_number(SG))) "],
["estruturas-complexas-de-dados.html", "11 Estruturas complexas de dados 11.1 Introdução a listas 11.2 Introdução ao pacote purrr 11.3 Ideia de projeto: Aplicando uma série de funções a uma lista de arquivos 11.4 Referências", " 11 Estruturas complexas de dados 11.1 Introdução a listas Nós já falamos sobre vetores, que são as principais estruturas unidimensionais de dados e que só aceitam elementos da mesma classe: a &lt;- c(1, 2, &quot;c&quot;, 4) class(a) ## [1] &quot;character&quot; O R também possui uma estrutura de dados que pode armazenar, literalmente, qualquer tipo de objeto: as listas, criadas com a função list(). No exemplo abaixo uma série de objetos de classes diferentes são armazenadas: data_frame &lt;- head(iris) elemento_unico_inteiro &lt;- 1 um_na &lt;- NA vetor_string &lt;- letters[1:5] modelo_regressao &lt;- lm(mpg ~ wt, data = mtcars) minha_lista &lt;- list(data_frame = data_frame, elemento_unico_inteiro = elemento_unico_inteiro, # este elemento abaixo não vai possuir um nome um_na, vetor_string = vetor_string, modelo_regressao = modelo_regressao) # Conferindo o output: minha_lista ## $data_frame ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## ## $elemento_unico_inteiro ## [1] 1 ## ## [[3]] ## [1] NA ## ## $vetor_string ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## ## $modelo_regressao ## ## Call: ## lm(formula = mpg ~ wt, data = mtcars) ## ## Coefficients: ## (Intercept) wt ## 37.285 -5.344 Pelo output já percebemos que a maneira como extraímos um elemento de um vetor é diferente da de uma lista. No primeiro, usamos um par de colchetes ([]), no segundo usamos dois pares ([[]]) ou também cifrão ($), que só funciona caso o elemento da lista possua um nome. minha_lista[[2]] ## [1] 1 minha_lista$vetor_string ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; # o comando abaixo retorna NULL pq &quot;um_na&quot; não é um nome de # nenhum elemento da lista minha_lista$um_na ## NULL Vetores podem ser transformandos em listas usando a função de coerção as.list(): as.list(vetor_string) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; ## ## [[3]] ## [1] &quot;c&quot; ## ## [[4]] ## [1] &quot;d&quot; ## ## [[5]] ## [1] &quot;e&quot; Inserir um nome em uma lista é simples com o uso da função names(), que pode alterar os nomes da lista inteira ou de apenas um elemento, como no exemplo abaixo: names(minha_lista)[3] &lt;- &quot;meu_na&quot; names(minha_lista) ## [1] &quot;data_frame&quot; &quot;elemento_unico_inteiro&quot; &quot;meu_na&quot; &quot;vetor_string&quot; ## [5] &quot;modelo_regressao&quot; A função str() pode user usada para inspecionar a estrutura da lista: str(minha_lista) ## List of 5 ## $ data_frame :&#39;data.frame&#39;: 6 obs. of 5 variables: ## ..$ Sepal.Length: num [1:6] 5.1 4.9 4.7 4.6 5 5.4 ## ..$ Sepal.Width : num [1:6] 3.5 3 3.2 3.1 3.6 3.9 ## ..$ Petal.Length: num [1:6] 1.4 1.4 1.3 1.5 1.4 1.7 ## ..$ Petal.Width : num [1:6] 0.2 0.2 0.2 0.2 0.2 0.4 ## ..$ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 ## $ elemento_unico_inteiro: num 1 ## $ meu_na : logi NA ## $ vetor_string : chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ modelo_regressao :List of 12 ## ..$ coefficients : Named num [1:2] 37.29 -5.34 ## .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;wt&quot; ## ..$ residuals : Named num [1:32] -2.28 -0.92 -2.09 1.3 -0.2 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ... ## ..$ effects : Named num [1:32] -113.65 -29.116 -1.661 1.631 0.111 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:32] &quot;(Intercept)&quot; &quot;wt&quot; &quot;&quot; &quot;&quot; ... ## ..$ rank : int 2 ## ..$ fitted.values: Named num [1:32] 23.3 21.9 24.9 20.1 18.9 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ... ## ..$ assign : int [1:2] 0 1 ## ..$ qr :List of 5 ## .. ..$ qr : num [1:32, 1:2] -5.657 0.177 0.177 0.177 0.177 ... ## .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. ..$ : chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ... ## .. .. .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;wt&quot; ## .. .. ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1 ## .. ..$ qraux: num [1:2] 1.18 1.05 ## .. ..$ pivot: int [1:2] 1 2 ## .. ..$ tol : num 1e-07 ## .. ..$ rank : int 2 ## .. ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; ## ..$ df.residual : int 30 ## ..$ xlevels : Named list() ## ..$ call : language lm(formula = mpg ~ wt, data = mtcars) ## ..$ terms :Classes &#39;terms&#39;, &#39;formula&#39; language mpg ~ wt ## .. .. ..- attr(*, &quot;variables&quot;)= language list(mpg, wt) ## .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. ..$ : chr [1:2] &quot;mpg&quot; &quot;wt&quot; ## .. .. .. .. ..$ : chr &quot;wt&quot; ## .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;wt&quot; ## .. .. ..- attr(*, &quot;order&quot;)= int 1 ## .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. .. ..- attr(*, &quot;predvars&quot;)= language list(mpg, wt) ## .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;mpg&quot; &quot;wt&quot; ## ..$ model :&#39;data.frame&#39;: 32 obs. of 2 variables: ## .. ..$ mpg: num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## .. ..$ wt : num [1:32] 2.62 2.88 2.32 3.21 3.44 ... ## .. ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language mpg ~ wt ## .. .. .. ..- attr(*, &quot;variables&quot;)= language list(mpg, wt) ## .. .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. .. ..$ : chr [1:2] &quot;mpg&quot; &quot;wt&quot; ## .. .. .. .. .. ..$ : chr &quot;wt&quot; ## .. .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;wt&quot; ## .. .. .. ..- attr(*, &quot;order&quot;)= int 1 ## .. .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. .. .. ..- attr(*, &quot;predvars&quot;)= language list(mpg, wt) ## .. .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;mpg&quot; &quot;wt&quot; ## ..- attr(*, &quot;class&quot;)= chr &quot;lm&quot; A maneira mais produtiva de se usar listas em seus projetos é para automatizar a aplicação de uma determinada função (ou funções) para todos os elementos de uma lista. Suponha, por exemplo, que você precise importar dezenas de arquivos csv, fazer algumas limpezas e manipulações de dados, construir modelos de Machine Learning e depois salvar os resultados no computador. Seria muito tedioso fazer isso manualmente, mas é para esse tipo de operação que listas se tornam muito úteis. O pacote purrr possui uma série de comandos para aplicar funções a elementos de uma lista. O R base até possui as funções da família apply (apply(), tapply(), lapply(), etc), mas estas estão entrando em desuso devido à adoção do purrr. 11.2 Introdução ao pacote purrr 11.2.1 map() Nós já vimos que o R aplica uma função a cada elemento de um vetor de uma forma muito simples: meu_vetor &lt;- c(1, -3, 5, -10) # extrair o modulo de cada elemento do vetor acima abs(meu_vetor) ## [1] 1 3 5 10 No caso de listas, não é bem assim que funciona: minha_lista &lt;- list(1, 3, 5, 10) abs(minha_lista) ## Error in abs(minha_lista): non-numeric argument to mathematical function É necessário usar uma outra função para aplicar uma função a cada elemento da lista. É aqui que introduzimos a função map(), do pacote purrr. O primeiro argumento é a estrutura de dados sobre a qual se deseja iterar e o segundo é a função que será aplicada a cada elemento. O pacote purrr faz parte do tidyverse. library(tidyverse) library(purrr) map(minha_lista, abs) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 3 ## ## [[3]] ## [1] 5 ## ## [[4]] ## [1] 10 Veja a diferença no output: class(minha_lista) ## [1] &quot;list&quot; map(minha_lista, class) ## [[1]] ## [1] &quot;numeric&quot; ## ## [[2]] ## [1] &quot;numeric&quot; ## ## [[3]] ## [1] &quot;numeric&quot; ## ## [[4]] ## [1] &quot;numeric&quot; De maneira genérica, é assim que são usados os parâmetros de map(): map(.x, .f, ...) # ou map(VETOR_OU_LISTA, FUNCAO_PARA_APLICAR, ARGUMENTOS_OPCIONAIS) # que é equivalente a VETOR_OU_LISTA %&gt;% map(FUNCAO_PARA_APLICAR, ARGUMENTOS_OPCIONAIS) Existem três maneiras de especificar a função para usar no map(): Uma função existente # definir uma lista composta por vetores v &lt;- list(v1 = c(1, 3, 5), v2 = c(2, 4, 6), v3 = c(7, 8, 9)) # aplicar a raiz quadrada a todos os vetores map(v, sqrt) ## $v1 ## [1] 1.000000 1.732051 2.236068 ## ## $v2 ## [1] 1.414214 2.000000 2.449490 ## ## $v3 ## [1] 2.645751 2.828427 3.000000 # calcular a soma dos elementos de cada vetor map(v, sum) ## $v1 ## [1] 9 ## ## $v2 ## [1] 12 ## ## $v3 ## [1] 24 Uma função “anônima”, definida dentro da própria map(). Veja que, em function(x) abaixo, x é como se fosse uma representação genérica de cada elemento da lista v. Em inglês isso se chama placeholder. # elevar cada elemento de cada vetor ao quadrado map(v, function(x) x^2) ## $v1 ## [1] 1 9 25 ## ## $v2 ## [1] 4 16 36 ## ## $v3 ## [1] 49 64 81 # elevar a soma dos elementos do vetor ao quadrado map(v, function(x) sum(x)^2) ## $v1 ## [1] 81 ## ## $v2 ## [1] 144 ## ## $v3 ## [1] 576 Uma fórmula. Deve-se começar com o símbolo ~ para iniciar uma função e .x para se referir ao seu input, que corresponde a cada elemento da lista especificada no primeiro argumento de map(). Traduzindo os dois comandos anteriores para esta sintaxe, ficaria assim: map(v, ~ .x^2) ## $v1 ## [1] 1 9 25 ## ## $v2 ## [1] 4 16 36 ## ## $v3 ## [1] 49 64 81 map(v, ~ sum(.x)^2) ## $v1 ## [1] 81 ## ## $v2 ## [1] 144 ## ## $v3 ## [1] 576 11.2.2 Funções derivadas de map() A função map() retorna uma lista. Contudo, se você sabe que sua função deve retornar um resultado em que todos os elementos pertencem a uma mesma classe, é possível usar as funções derivadas de map, como map_chr() (character) e map_dbl() (numérico): map_chr(v, class) ## v1 v2 v3 ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; map_dbl(v, ~ sum(.x)^2) ## v1 v2 v3 ## 81 144 576 Dá até para garantir que o resultado de map() seja um dataframe com map_dfr() ou map_dfc(): map_dfc(v, function(x) x * 2) ## # A tibble: 3 x 3 ## v1 v2 v3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 4 14 ## 2 6 8 16 ## 3 10 12 18 É possível e simples encadear uma sequência de comandos map() com o pipe: v %&gt;% map(~ .x * 2) %&gt;% map_dbl(sum) ## v1 v2 v3 ## 18 24 48 11.3 Ideia de projeto: Aplicando uma série de funções a uma lista de arquivos Este dataset no Kaggle traz o consumo médio de energia elétrica por região nos Estados Unidos. A página disponibiliza 13 arquivos csv, um para cada região. Suponha que, para cada região, desejamos ler o arquivo, padronizar os nomes das duas colunas, acrescentar uma coluna identificando a região do arquivo, calcular o consumo médio por mês do ano e juntar os dataframes. Seria tortuoso fazer isso para cada arquivo manualmente, por isso nos valemos do pacote purrr para sistematizar esse processo. Baixe o dataset e salve em uma pasta chamada “dados”. Descompacte o arquivo zip e uma nova pasta será criada. # listar os arquivos contidos na pasta baixada arquivos &lt;- dir(&quot;dados/hourly-energy-consumption/&quot;, # listar apenas arquivos que contem o padrao abaixo pattern = &quot;_hourly.csv&quot;, full.names = TRUE) Para fins de demonstração, o código abaixo mostra como seria executar o processo descrito acima para apenas um dos arquivos: df1 &lt;-read_csv(arquivos[1]) head(df1) ## # A tibble: 6 x 2 ## Datetime AEP_MW ## &lt;dttm&gt; &lt;dbl&gt; ## 1 2004-12-31 01:00:00 13478 ## 2 2004-12-31 02:00:00 12865 ## 3 2004-12-31 03:00:00 12577 ## 4 2004-12-31 04:00:00 12517 ## 5 2004-12-31 05:00:00 12670 ## 6 2004-12-31 06:00:00 13038 Para extrair o nome do arquivo, note que o padrão é NOMEREGIAO_hourly. Por isso, podemos usar str_split() para “quebrar” o string em dois e pegar apenas o primeiro elemento. # basename() retorna apenas o nome do arquivo, sem o diretorio basename(arquivos[1]) ## [1] &quot;AEP_hourly.csv&quot; # str_split() quebra um string em mais de um baseado no separador especificado nome_regiao &lt;- str_split(basename(arquivos[1]), &quot;_&quot;)[[1]][1] df1_mes &lt;- df1 %&gt;% # mudar nome das colunas purrr::set_names(c(&quot;horario&quot;, &quot;consumo&quot;)) %&gt;% # criar uma coluna contendo o mes da data mutate(mes = lubridate::month(horario)) %&gt;% # criar uma coluna contendo o nome da regiao do arquivo mutate(regiao = nome_regiao) %&gt;% # agrupar os dados e calcular a media group_by(regiao, mes) %&gt;% summarise(consumo_medio = mean(consumo)) ## `summarise()` regrouping output by &#39;regiao&#39; (override with `.groups` argument) df1_mes ## # A tibble: 12 x 3 ## # Groups: regiao [1] ## regiao mes consumo_medio ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AEP 1 17431. ## 2 AEP 2 17023. ## 3 AEP 3 15377. ## 4 AEP 4 13824. ## 5 AEP 5 14006. ## 6 AEP 6 15630. ## 7 AEP 7 16350. ## 8 AEP 8 16425. ## 9 AEP 9 14657. ## 10 AEP 10 13939. ## 11 AEP 11 14930. ## 12 AEP 12 16446. A solução para aplicar o código acima para todos os arquivos csv diferentes de maneira elegante no R é o sistematizar, transformando-o em uma função: agregar_dados &lt;- function(arquivo_csv){ # str_split() quebra um string em mais de um baseado no separador especificado nome_regiao &lt;- str_split(basename(arquivo_csv), &quot;_&quot;)[[1]][1] # ler arquivo para um dataframe dframe &lt;- read_csv(arquivo_csv) # criar novo dataframe dframe_mes &lt;- dframe %&gt;% # mudar nome das colunas purrr::set_names(c(&quot;horario&quot;, &quot;consumo&quot;)) %&gt;% # criar uma coluna contendo o mes da data mutate(mes = lubridate::month(horario)) %&gt;% # criar uma coluna contendo o nome da regiao do arquivo mutate(regiao = nome_regiao) %&gt;% # agrupar os dados e calcular a media group_by(regiao, mes) %&gt;% summarise(consumo_medio = mean(consumo)) # retornar novo dataframe dframe_mes } Como sabemos que a função agregar_dados() deve retornar um dataframe, usamos map_dfr() para, além de gerar um dataframe por arquivo, juntá-los em um dataframe só: df_mes_geral &lt;- arquivos %&gt;% map_dfr(agregar_dados) head(df_mes_geral) ## # A tibble: 6 x 3 ## # Groups: regiao [1] ## regiao mes consumo_medio ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AEP 1 17431. ## 2 AEP 2 17023. ## 3 AEP 3 15377. ## 4 AEP 4 13824. ## 5 AEP 5 14006. ## 6 AEP 6 15630. 11.4 Referências Tutorial da Jenny Brian sobre purrr Tutorial completo do Caio Lente sobre purrr em português "],
["ggplot2.html", "12 Visualizações de dados (ggplot2) 12.1 Dataset do módulo 12.2 Mapeamento Estético 12.3 Objetos geométricos e tipos de gráficos 12.4 Escalas 12.5 Subplots (facet) 12.6 Temas 12.7 Legendas 12.8 Mapas: plotando polígonos 12.9 Salvando Gráficos 12.10 Extensões do ggplot2 12.11 Exercícios", " 12 Visualizações de dados (ggplot2) Pacotes deste capítulo: library(readxl) library(tidyverse) library(ISLR) library(RColorBrewer) library(ggthemes) library(hrbrthemes) library(treemapify) library(gapminder) library(sf) library(geobr) library(readxl) library(janitor) # novos: library(ggrepel) library(countrycode) library(patchwork) library(wpp2019) library(rbcb) # remotes::install_github(&#39;wilsonfreitas/rbcb&#39;) O ggplot2 é mais um pacote desenvolvido por Hadley Wickham, o criador, por exemplo, do tidyr e do dplyr. A ideia do pacote, ainda que com algumas modificações, vem de uma obra chamada The Grammar of Graphics, que é uma maneira de descrever um gráfico a partir dos seus componentes. Dessa forma, teoricamente, ficaria mais fácil entender a construção de gráficos mais complexos. Esse pacote é estruturado de forma que a “gramática” seja utilizada para um gráfico a partir de múltiplas camadas. As camadas serão formadas por dados, mapeamentos estéticos, transformações estatísticas dos dados, objetos geométricos (pontos, linhas, barras etc.) e ajuste de posicionamento. Além disso, existem outros componentes, como os sistemas de coordenadas (cartesiano, polar, mapa etc.) e, se for o caso, divisões do gráfico em subplots (facet). Um simples exemplo de múltiplas camadas seria um gráfico de pontos adicionado de uma curva de ajustamento. Uma forma geral (template) para entender-se a estrutura do ggplot2, segundo o próprio Hadley Wickhan, no livro R for Data Science, é a seguinte: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; # dividir o gráfico em subplots A ideia é que todo gráfico pode ser representado por essa forma. No entanto, na criação de um gráfico, não é necessário especificar-se todas as partes acima. O ggplot2 já oferece um padrão para o sistema de coordenadas, para o stat e position. O facet (subplot) só será utilizado quando necessário. Além disso, existem as escalas que são utilizadas para controlar o mapeamento dos dados em relação aos atributos estéticos do gráfico. Por exemplo: suponha que no seu gráfico exista uma coluna que é uma variável categórica com três classes possíveis e as cores do objeto geométrico estejam associadas a essa variável. Automaticamente, o ggplot2 definirá uma cor pra cada classe. No entanto, você pode alterar a escala de cores para ter controle sobre elas. O mesmo vale para os valores apresentados nos eixos x e y. Uma observação importante é que apesar dos dados estarem na função ggplot() (&lt;DATA&gt;), eles também podem ser incluídos diretamente em cada objeto geométrico. Isto será útil quando for necessário criar-se uma nova camada a partir de dados diferentes daqueles que estão inicialmente nos gráficos. Dessa forma, incorporando essas observações, um template estendido seria o abaixo: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt;, data = &lt;DATA&gt; # pode receber os dados diretamente ) + &lt;SCALE_FUNCTION&gt; + # uma para cada elemento estético &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; # dividir o gráfico em subplots Também é importante ressaltar-se que, como todo sistema de gráficos, é possível alterar-se todos os títulos e rótulos do gráfico, além do controle sobre as características do tema do gráfico (cor do fundo, estilo da fonte, tamanho da fonte etc). 12.1 Dataset do módulo Para este módulo, usaremos o dataset World Happiness Report, ou o Relatório Mundial da Felicidade, que é uma medição da felicidade publicado pela Rede de Soluções para o Desenvolvimento Sustentável da ONU (SDSN, na sigla em inglês). Leia o artigo na Wikipedia para mais informações. # baixe o arquivo do endereco: download.file(&quot;https://s3.amazonaws.com/happiness-report/2018/WHR2018Chapter2OnlineData.xls&quot;, destfile = &quot;felicidade.xls&quot;) # importar a planilha df_feliz &lt;- read_excel(&quot;felicidade.xls&quot;, sheet = 1) # limpar o nome das colunas df_feliz &lt;- janitor::clean_names(df_feliz) # renomear algumas colunas df_feliz &lt;- df_feliz %&gt;% rename(life_expec = healthy_life_expectancy_at_birth) # olhar dados glimpse(df_feliz) ## Rows: 1,562 ## Columns: 19 ## $ country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;,… ## $ year &lt;dbl&gt; 2008, 2009, 2010, 2011, 2012, 2013, 2014, 20… ## $ life_ladder &lt;dbl&gt; 3.723590, 4.401778, 4.758381, 3.831719, 3.78… ## $ log_gdp_per_capita &lt;dbl&gt; 7.168690, 7.333790, 7.386629, 7.415019, 7.51… ## $ social_support &lt;dbl&gt; 0.4506623, 0.5523084, 0.5390752, 0.5211036, … ## $ life_expec &lt;dbl&gt; 49.20966, 49.62443, 50.00896, 50.36730, 50.7… ## $ freedom_to_make_life_choices &lt;dbl&gt; 0.7181143, 0.6788964, 0.6001272, 0.4959014, … ## $ generosity &lt;dbl&gt; 0.18181947, 0.20361446, 0.13763019, 0.175329… ## $ perceptions_of_corruption &lt;dbl&gt; 0.8816863, 0.8500354, 0.7067661, 0.7311085, … ## $ positive_affect &lt;dbl&gt; 0.5176372, 0.5839256, 0.6182655, 0.6113873, … ## $ negative_affect &lt;dbl&gt; 0.2581955, 0.2370924, 0.2753238, 0.2671747, … ## $ confidence_in_national_government &lt;dbl&gt; 0.6120721, 0.6115452, 0.2993574, 0.3073857, … ## $ democratic_quality &lt;dbl&gt; -1.92968953, -2.04409266, -1.99180996, -1.91… ## $ delivery_quality &lt;dbl&gt; -1.6550844, -1.6350248, -1.6171761, -1.61622… ## $ standard_deviation_of_ladder_by_country_year &lt;dbl&gt; 1.774662, 1.722688, 1.878622, 1.785360, 1.79… ## $ standard_deviation_mean_of_ladder_by_country_year &lt;dbl&gt; 0.4765997, 0.3913617, 0.3948027, 0.4659422, … ## $ gini_index_world_bank_estimate &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ gini_index_world_bank_estimate_average_2000_15 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.30… ## $ gini_of_household_income_reported_in_gallup_by_wp5_year &lt;dbl&gt; NA, 0.4419058, 0.3273182, 0.3367642, 0.34453… Sentiram falta de uma coluna com o nome do continente? Vamos também importar um dataset que contém o continente de cada país, fornecido pelo pacote countrycode. # consertar manualmente os nomes de certos paises df_feliz$country[df_feliz$country == &quot;Bosnia and Herzegovina&quot;] &lt;- &quot;Bosnia &amp; Herzegovina&quot; df_feliz$country[df_feliz$country == &quot;Czech Republic&quot;] &lt;- &quot;Czechia&quot; df_feliz$country[df_feliz$country == &quot;Hong Kong S.A.R. of China&quot;] &lt;- &quot;Czechia&quot; df_feliz$country[df_feliz$country == &quot;Taiwan Province of China&quot;] &lt;- &quot;Taiwan&quot; # consulte a documentação do dataset # ?countrycode::codelist df_continente &lt;- countrycode::codelist %&gt;% # selecionar colunas importantes select(country = country.name.en, continent, country_code = iso3n) %&gt;% # filtrar fora os paises sem continentes filter(!is.na(continent)) # criar dataframe com juncao dos dois df_feliz &lt;- inner_join(df_feliz, df_continente, by = &quot;country&quot;) # coletar dados de populacao a partir de outro dataset, do pacote wpp2019 data(pop) df_populacao &lt;- pop %&gt;% select(country_code, `2020`) %&gt;% rename(populacao_2020 = 2) df_feliz &lt;- df_feliz %&gt;% left_join(df_populacao, by = &#39;country_code&#39;) # criar dataset apenas para o ano mais recente df_2017 &lt;- df_feliz %&gt;% filter(year == max(year)) Para quebrar-se a barreira inicial, vamos criar um exemplo por partes de um gráfico do PIB per capita e da expectativa de vida dos países em 2017: # Inicia o plot g &lt;- ggplot(df_2017) # Adicionar pontos (geom_point) e # vamos mapear variáveis a elementos estéticos dos pontos # Size = 3 define o tamanho de todos os pontos g &lt;- g + geom_point(aes(x = log_gdp_per_capita, y = life_expec, color = continent), size = 3) # Rótulos (títulos) g &lt;- g + labs(title = &#39;Relação entre PIB per capita e expectativa de vida&#39;, y = &#39;Anos&#39;, x = &#39;USD/pessoa&#39;) g ## Warning: Removed 6 rows containing missing values (geom_point). Detalharemos cada parte do gráfico, mas vale falar-se rapidamente sobre o código acima. Primeiramente, passamos um conjunto de dados para o ggplot. Depois, adicionamos uma camada de pontos, mapeando as variáveis log_gdp_per_capita e life_expec para as posições de cada ponto nos eixos x e y, respectivamente, e a variável continent para a cor de cada ponto. Em seguida, alteramos a escala de cor, definindo seu título, os rótulos (labels) e os valores (values) para as cores. Por fim, definimos os títulos/rótulos do gráfico. Nas próximas seções, falaremos com mais detalhes sobre cada componente, começando pelo mapeamento estético. 12.2 Mapeamento Estético O mapeamento estético é o mapeamento das variáveis dos dados para as características visuais dos objetos geométricos (pontos, barras, linhas etc.). Isto é feito a partir da função aes(). E quais são as características visuais de um objeto geométrico? Abaixo segue uma lista não exaustiva: Posição (x e y); Cor (color); Tamanho (size); Preenchimento (fill); Transparência (alpha); Texto (label). Como vimos no exemplo acima, mapeamos três variáveis para três características visuais de cada ponto: posição x, posição y e cor. Nos próximos exemplos, outros elementos estéticos serão utilizados, conforme o objeto geométrico selecionado. 12.3 Objetos geométricos e tipos de gráficos Os objetos geométricos começam com a expressão geom_ e são seguidos pelo tipo de objeto. Por exemplo, geom_point() para pontos e geom_bar() para barras. A tabela abaixo apresenta os tipos de objetos geométricos utilizados para criar-se alguns tipos de gráficos populares. Tipo Objeto Geométrico Dispersão (scatterplot) geom_point() Gráfico de bolhas geom_point() Gráfico de barras geom_col() e geom_bar() Histograma geom_histogram() Boxplot geom_boxplot() Densidade geom_density() Gráfico de linhas geom_line() Nesse material, os principais tipos de objetos geométricos serão demonstrados a partir de exemplos. A lista completa de objetos geométricos e as descrições dos argumentos estão na documentação do ggplot2. É importante saber-se que um gráfico do ggplot2 pode ter mais de um objeto geométrico, cada um formando uma camada. Por exemplo, uma camada de pontos e outra de linhas que conectam os pontos. Vamos, primeiramente, criar um gráfico com pontos: ggplot(df_2017, aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() Note que o aes() está sendo usado diretamente na função ggplot() e não no objeto geométrico. O que isto significa? Que o mapeamento estético definido na função ggplot() é global. Ou seja, é aplicado para todos os objetos geométricos daquele gráfico, a menos que seja explicitado novamente em alguma camada. Para finalizarmos essa breve introdução a objetos geométricos, adicionemos mais uma camada ao gráfico: ggplot(df_2017, aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() + geom_smooth(method = &quot;lm&quot;) No exemplo acima, também não foi necessário definir os mapeamentos estéticos da camada geom_smooth(), pois eles foram herdados das definições da camada principal, a ggplot(). O que aconteceria, no entanto, caso fosse desejado pintar as cores de cada ponto de acordo com alguma variável, como o continente do país? ggplot(df_2017, aes(x = log_gdp_per_capita, y = life_expec, color = continent)) + geom_point() + geom_smooth(method = &quot;lm&quot;) Note que a camada geom_smooth() herdou o mapeamento color, de forma que foi criada uma reta de ajuste para cada continente. Isso pode até ser desejável, mas e se o objetivo for destacar a cor apenas dos pontos, mantendo apenas uma reta de ajuste para todos os continentes? Seria necessário então alterar o atributor color apenas da camada alvo. ggplot(df_2017, aes(x = log_gdp_per_capita, y = life_expec)) + geom_point(aes(color = continent)) + geom_smooth(method = &quot;lm&quot;) 12.3.1 Escolhendo o tipo de gráfico Antes de decidir qual gráfico você utilizará, é preciso saber o que se deseja representar. O objetivo guiará o tipo de gráfico mais adequado. A imagem abaixo apresenta uma lista bastante completa de possibilidades de gráficos, dos mais simples aos mais complexos: Entre neste link para visualizar a imagem com zoom. 12.3.2 Gráfico de Dispersão (geom_point()) geom_point(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) O gráfico de dispersão é bastante usado para verificar-se relações entre duas variáveis quantitativas. Como queremos um gráfico de pontos, o objeto geométrico natural é o geom_point(). Esse objeto geométrico tem os seguintes elementos estéticos: Os parâmetros estéticos (aes) são: x y alpha colour fill shape size stroke ggplot(df_2017, aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() ## Warning: Removed 6 rows containing missing values (geom_point). Vamos mapear a variável continent ao elemento estético color e shape: ggplot(df_2017, aes(x = log_gdp_per_capita, y = life_expec)) + geom_point(aes(color = continent, shape = continent)) ## Warning: Removed 6 rows containing missing values (geom_point). Automaticamente o ggplot2 criou uma escala para as cores e formatos dos pontos. O usuário pode alterar este mapeamento utilizando as funções scale_*_*. Por fim, fica aqui a lista com os tipos de shapes: Perceba que os formatos de 21 a 24 possuem preenchimento (fill). Assim, no código abaixo definiremos o preenchimento, o tamanho do ponto e a espessura para aqueles formatos que possuem contornos. ggplot(df_2017, aes(x = log_gdp_per_capita, y = life_expec)) + geom_point(aes(color = continent, shape = continent, fill = continent)) + #scale_color_discrete(&quot;Continente&quot;) + scale_shape_manual(&quot;Continente&quot;, values = c(19, 21, 22, 23, 24)) + labs(title = &quot;Relação entre Renda per Capita e Expectativa de Vida - 2007&quot;, x = &quot;Renda per Capita (escala log 10)&quot;, y = &quot;Expectativa de Vida&quot;) ## Warning: Removed 6 rows containing missing values (geom_point). 12.3.3 Gráficos de Bolhas O gráfico de bolha é uma extensão natural do gráfico de pontos. Ele permite observar-se possíveis relações entre as três variáveis. Para este tipo de gráfico, são necessárias três variáveis: duas para indicarem as posições x e y e uma terceira para definir o tamanho do ponto (size). Vamos utilizar a variável populacao_2020 (população): glimpse(df_2017) ## Rows: 134 ## Columns: 22 ## $ country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Algeria&quot;, &quot;Argent… ## $ year &lt;dbl&gt; 2017, 2017, 2017, 2017, 2017, 2017, 2017, 20… ## $ life_ladder &lt;dbl&gt; 2.661718, 4.639548, 5.248912, 6.039330, 4.28… ## $ log_gdp_per_capita &lt;dbl&gt; 7.460144, 9.373718, 9.540244, 9.843519, 9.03… ## $ social_support &lt;dbl&gt; 0.4908801, 0.6376983, 0.8067539, 0.9066991, … ## $ life_expec &lt;dbl&gt; 52.33953, 69.05166, 65.69919, 67.53870, 65.1… ## $ freedom_to_make_life_choices &lt;dbl&gt; 0.4270109, 0.7496110, 0.4366705, 0.8319662, … ## $ generosity &lt;dbl&gt; -0.106340349, -0.035140377, -0.194670126, -0… ## $ perceptions_of_corruption &lt;dbl&gt; 0.9543926, 0.8761346, 0.6997742, 0.8410525, … ## $ positive_affect &lt;dbl&gt; 0.4963486, 0.6692409, 0.6419796, 0.8094226, … ## $ negative_affect &lt;dbl&gt; 0.3713262, 0.3338841, 0.2887100, 0.2917173, … ## $ confidence_in_national_government &lt;dbl&gt; 0.2611785, 0.4577375, NA, 0.3054303, 0.24690… ## $ democratic_quality &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ delivery_quality &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ standard_deviation_of_ladder_by_country_year &lt;dbl&gt; 1.454051, 2.682105, 2.039765, 2.409329, 2.32… ## $ standard_deviation_mean_of_ladder_by_country_year &lt;dbl&gt; 0.5462828, 0.5780961, 0.3886071, 0.3989398, … ## $ gini_index_world_bank_estimate &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ gini_index_world_bank_estimate_average_2000_15 &lt;dbl&gt; NA, 0.3032500, 0.2760000, 0.4760667, 0.32506… ## $ gini_of_household_income_reported_in_gallup_by_wp5_year &lt;dbl&gt; 0.2865989, 0.4104880, 0.5275558, 0.3941758, … ## $ continent &lt;chr&gt; &quot;Asia&quot;, &quot;Europe&quot;, &quot;Africa&quot;, &quot;Americas&quot;, &quot;Asi… ## $ country_code &lt;dbl&gt; 4, 8, 12, 32, 51, 36, 40, 31, 48, 50, 112, 5… ## $ populacao_2020 &lt;dbl&gt; 38928.341, 2877.800, 43851.043, 45195.777, 2… df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = life_expec, size = populacao_2020)) + geom_point() + labs(title = &quot;Relação entre Renda per Capita e Expectativa de Vida - 2007&quot;, x = &quot;Renda per Capita (escala log 10)&quot;, y = &quot;Expectativa de Vida&quot;) ## Warning: Removed 6 rows containing missing values (geom_point). 12.3.4 Gráficos de Barras Os gráficos de barras/colunas são geralmente utilizados para comparações entre categorias (variáveis qualitativas). No ggplot2 podemos usar dois objetos geométricos distintos: geom_col(mapping = NULL, data = NULL, position = &quot;stack&quot;, ..., width = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) Os parâmetros estéticos (aes) são: x y alpha colour fill linetype size No exemplo do dataset, um gráfico de barras é uma boa opção para calcular a população total por continente: df_feliz %&gt;% group_by(continent) %&gt;% summarise(pop_total = sum(populacao_2020)) %&gt;% ggplot(aes(x = continent, y = pop_total)) + geom_col() ## `summarise()` ungrouping output (override with `.groups` argument) Uma pergunta recorrente é: Como ordenar as barras em ordem crescente/decrescente? Para isso, pode-se utilizar a função fct_reorder() no momento do mapeamento. Fica mais claro com um exemplo: df_feliz %&gt;% group_by(continent) %&gt;% summarise(pop_total = sum(populacao_2020)) %&gt;% ggplot(aes(x = fct_reorder(continent, pop_total), y = pop_total)) + geom_col() ## `summarise()` ungrouping output (override with `.groups` argument) Vamos, agora, criar um gráfico em que se compara a expectativa de vida média por continente em no menor e no maior ano da série temporal: df_feliz %&gt;% filter(year %in% c(2010, 2017)) %&gt;% # Converte o ano para factor - será categoria no gráfico mutate(year = as.character(year)) %&gt;% group_by(continent, year) %&gt;% summarise(life_expec_media = mean(life_expec)) %&gt;% ggplot(aes(x = continent, y = life_expec_media, fill = year)) + geom_col() ## `summarise()` regrouping output by &#39;continent&#39; (override with `.groups` argument) Para continente, o gráfico empilhou as barras. Isto se deve ao argumento position = stack. Para colocar as barras lado a lado, utilizamos o valor “dodge”: df_feliz %&gt;% filter(year %in% c(2010, 2017)) %&gt;% # Converte o ano para factor - será categoria no gráfico mutate(year = as.character(year)) %&gt;% group_by(continent, year) %&gt;% summarise(life_expec_media = mean(life_expec)) %&gt;% ggplot(aes(x = continent, y = life_expec_media, fill = year)) + geom_col(position = &quot;dodge&quot;) ## `summarise()` regrouping output by &#39;continent&#39; (override with `.groups` argument) 12.3.5 Gráficos de linhas Os gráficos de linhas são, geralmente, utilizados para apresentar-se a evolução de uma variável quantitativa em um intervalo de tempo. geom_line(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, ...) Os parâmetros estéticos (aes) são: x y alpha colour linetype size Série temporal é definida como uma variável contínua mensurada em intervalos regulares de tempo. A melhor representação visual para dados desse tipo são gráficos de linha, que são úteis para mostrar o comportamento de uma variável ao longo do tempo. Como exemplo para gráficos de linha, vamos plotar a evolução de dois importantes indicadores econômicos brasileiros: a taxa SELIC e o índice IPCA, ambos mensalizados. Para obter esses indicadores, usamos o pacote rbcb: # Importar para o R dados das series. lista_datasets &lt;- rbcb::get_series(code = c(ipca = 433, selic = 4390)) # O objeto retornado é uma lista de dois dataframes: str(lista_datasets) ## List of 2 ## $ ipca : tibble [486 × 2] (S3: tbl_df/tbl/data.frame) ## ..$ date: Date[1:486], format: &quot;1980-01-01&quot; &quot;1980-02-01&quot; &quot;1980-03-01&quot; ... ## ..$ ipca: num [1:486] 6.62 4.62 6.04 5.29 5.7 5.31 5.55 4.95 4.23 9.48 ... ## $ selic: tibble [411 × 2] (S3: tbl_df/tbl/data.frame) ## ..$ date : Date[1:411], format: &quot;1986-06-01&quot; &quot;1986-07-01&quot; &quot;1986-08-01&quot; ... ## ..$ selic: num [1:411] 1.27 1.95 2.57 2.94 1.96 ... # Voce pode acessar cada dataframe usando a sintaxe NOME_DA_LISTA$NOME_DO_OBJETO: str(lista_datasets$selic) ## tibble [411 × 2] (S3: tbl_df/tbl/data.frame) ## $ date : Date[1:411], format: &quot;1986-06-01&quot; &quot;1986-07-01&quot; &quot;1986-08-01&quot; &quot;1986-09-01&quot; ... ## $ selic: num [1:411] 1.27 1.95 2.57 2.94 1.96 ... # Vamos então criar apenas um dataset que corresponde a junção dos dois dataframes df_st &lt;- left_join(lista_datasets$ipca, lista_datasets$selic, by = &quot;date&quot;) # conferindo o novo dataframe criado head(df_st) ## # A tibble: 6 x 3 ## date ipca selic ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1980-01-01 6.62 NA ## 2 1980-02-01 4.62 NA ## 3 1980-03-01 6.04 NA ## 4 1980-04-01 5.29 NA ## 5 1980-05-01 5.7 NA ## 6 1980-06-01 5.31 NA Temos uma coluna de data (date), cuja classe é Date e será usada como eixo x no gráfico de séries temporais: # grafico do ipca ggplot(df_st, aes(x = date, y = ipca)) + geom_line() Adicionar geom_smooth(method = &quot;loess&quot;) ajuda a distinguir movimentos de tendência na série temporal: df_st %&gt;% filter(date &gt;= as.Date(&quot;2008-01-01&quot;)) %&gt;% ggplot(aes(x = date, y = selic)) + geom_line() + geom_smooth(method = &quot;loess&quot;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; É possível incluir no gráfico mais de uma variável no eixo y. Uma das alternativas é simplesmente acrescentar mais uma camada geom_line() com a nova variável: ggplot(df_st, aes(x = date, y = ipca)) + geom_line() + # adicionar mais uma camada de geom_line geom_line(aes(y = selic), color = &quot;blue&quot;) ## Warning: Removed 77 row(s) containing missing values (geom_path). No entanto, a melhor maneira de se fazer isso é converter os dados para o formato long (tidy): df_st_tidy &lt;- df_st %&gt;% gather(indicador, valor, ipca:selic) %&gt;% arrange(date) head(df_st_tidy) ## # A tibble: 6 x 3 ## date indicador valor ## &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1980-01-01 ipca 6.62 ## 2 1980-01-01 selic NA ## 3 1980-02-01 ipca 4.62 ## 4 1980-02-01 selic NA ## 5 1980-03-01 ipca 6.04 ## 6 1980-03-01 selic NA # antes de proceder com o restante do exercicio, vamos salvar o dataset para # o usar nos proximos modulos write_rds(df_st_tidy, &quot;series_ipca_selic.rds&quot;) Note que indicador é uma coluna categórica e valor, numérica. Portanto, a primeira será mapeada à aesthetic y e a segunda a color. Agora, a variável indicador é mapeada ao atributo color. df_st_tidy %&gt;% ggplot(aes(x = date, y = valor, color = indicador)) + geom_line() ## Warning: Removed 77 row(s) containing missing values (geom_path). Notou como o período antes de 1995 representava uma realidade muito diferente da atual? Vamos então filtrar os dados a partir desse ano. df_st_pos_1995 &lt;- df_st_tidy %&gt;% filter(date &gt;= as.Date(&quot;1995-01-01&quot;)) df_st_pos_1995 %&gt;% ggplot(aes(x = date, y = valor, color = indicador)) + geom_line() 12.3.6 Histogramas geom_histogram(mapping = NULL, data = NULL, stat = &quot;bin&quot;, position = &quot;stack&quot;, ..., binwidth = NULL, bins = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) Os histogramas são utilizados para representar-se a distribuição de dados de uma variável quantitativa em intervalos contínuos. Esses intervalos são chamados de bins. Para cada bin, será apresentada a quantidade de valores que estão naquele intervalo. df_2017 %&gt;% ggplot(aes(x = life_expec)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. A função geom_histogram(), por padrão, “quebra” a variável em 30 intervalos. É possível mudar esse comportamento especificando o argumento bins: # reduzindo o numero de intervalos df_feliz %&gt;% ggplot(aes(x = life_expec)) + geom_histogram(bins = 10) # aumentando o número de intervalos df_feliz %&gt;% ggplot(aes(x = life_expec)) + geom_histogram(bins = 40) Outra maneira de redefinir os intervalos de um histograma é mudando o argumento binwidth, que controla a largura dos intervalos. Não é possível definir os argumentos bins e binwidth de uma só vez; ou um ou o outro. df_feliz %&gt;% ggplot(aes(x = life_expec)) + geom_histogram(binwidth = 5) No histograma acima, ao definir a largura dos intervalos como 5, o histograma criou intervalos usando como centros os números 45, 50, 55, etc. Portanto, os intervalos são [42,5 - 47,5), [47,5 - 52,5), etc. É possível també definir os limites dos intervalos. Por exemplo, caso você deseje que os intervalos comecem com números que terminem em 5, deve-se alterar o argumento boundary: df_feliz %&gt;% ggplot(aes(x = life_expec)) + geom_histogram(binwidth = 5, boundary = 5) Assim, conseguimos criar uma visualização que mostra que a grande maioria dos países possui uma expectativa de vida maior que 60 anos, e que alguns poucos países possuem uma expectativa de vida menor que 50 anos e maior que 75. Como você já deve ter imaginado, é possível mudar aspectos visuais do histograma alterando suas aesthetics, como mudar a cor do histograma por valores atributos ou mapear alguma variável à cor do histograma. Veja que a cor de um histograma é definida pela propriedade fill, pois color altera apenas a cor das bordas das barras: df_feliz %&gt;% ggplot(aes(x = life_expec)) + geom_histogram(binwidth = 5, boundary = 5, color = &quot;red&quot;, fill = &quot;green&quot;, alpha = 0.5) df_feliz %&gt;% ggplot(aes(x = life_expec)) + geom_histogram(binwidth = 5, boundary = 5, aes(fill = continent)) 12.3.7 Boxplots e violinplots O boxplot é uma representação comum para apresentar-se a distribuição de uma variável a partir de seus quantis. A imagem abaixo detalha como um boxplot é formado. Detalhes sobre o bloxplot O boxplot também pode ser usado para verificar-se a distribuição de variável para um conjunto de valores de uma segunda variável. Por exemplo: qual é a distribuição da expectativa de vida por ano? ggplot(df_2017, aes(x = continent, y = life_expec)) + geom_boxplot() Vemos que existe um possível outlier em 1992. Quando falarmos sobre anotações, voltaremos a este gráfico. Para termos uma visão da distribuição geral dos valores por ano, podemos utilizar o geom_violin(). O violinplot baseia-se na densidade de probabilidade de uma variável contínua. Assim, é possível verificar-se em quais intervalos existe uma maior chance de ocorrência. Isto é representado pela parte mais larga do objeto. ggplot(df_2017, aes(x = continent, y = life_expec)) + geom_violin() 12.3.8 Textos/Rótulos As funções geom_text() e geom_label() servem para acrescentar camadas de texto no gráfico. A única diferença entre as duas é que geom_label() desenha um retângulo no fundo do texto, possivelmente melhorando sua leitura. Ambas funções geom_text() dependem de três aesthetics: x e y, que correspondem às posições dos textos a serem plotados, e label, que é o texto a ser plotado. No exemplo abaixo, não especificamos x e y em geom_text() porque a função herda as definidas na função ggplot(): geom_label(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, ..., parse = FALSE, nudge_x = 0, nudge_y = 0, label.padding = unit(0.25, &quot;lines&quot;), label.r = unit(0.15, &quot;lines&quot;), label.size = 0.25, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) geom_text(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, ..., parse = FALSE, nudge_x = 0, nudge_y = 0, check_overlap = FALSE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) Os parâmetros estéticos (aes) são: label x y alpha angle colour family fontface hjust lineheight size vjust Para adicionar textos ou rótulos, utilizamos, respectivamente, o geom_text() e o geom_label(), que se diferenciam na formatação. Isto ficará mais claro nos exemplos a seguir: df_2017 %&gt;% group_by(continent) %&gt;% summarise(life_expec_media = round(mean(life_expec))) %&gt;% ggplot(aes(x = continent, y = life_expec_media)) + geom_col() + geom_text(aes(label = life_expec_media), vjust = 2) ## `summarise()` ungrouping output (override with `.groups` argument) df_2017 %&gt;% group_by(continent) %&gt;% summarise(life_expec_media = round(mean(life_expec))) %&gt;% ggplot(aes(x = continent, y = life_expec_media)) + geom_col() + geom_label(aes(label = life_expec_media), vjust = 2) ## `summarise()` ungrouping output (override with `.groups` argument) Suponha que no primeiro gráfico de pontos mostrado no material, que mostra a relação entre PIB per capita e expectativa de vida, você deseja também acrescentar os nomes dos países: df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() + geom_text(aes(label = country)) ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_text). Como era de se esperar, o gráfico ficou muito poluído. Vamos então reduzir os pontos que queremos mostrar os nomes dos respectivos países apenas aos países dos continentes americanos. A estrategia, então, consiste em criar um novo dataframe com esses países e mudar o argumento data em geom_text: america &lt;- df_2017 %&gt;% filter(continent == &quot;Americas&quot;) df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() + geom_text(data = america, aes(label = country)) ## Warning: Removed 6 rows containing missing values (geom_point). Melhorou, mas ainda assim ficou poluído. Uma boa solução para esse problema é o pacote ggrepel, que internamente calcula a melhor posição entre os pontos da camada de texto, seja geom_text() ou geom_label(), de forma que não haja conflito de posição entre pontos. A única alteração necessária é mudar geom_text para geom_text_repel: df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() + geom_text_repel(data = america, aes(label = country)) ## Warning: Removed 6 rows containing missing values (geom_point). 12.3.9 Anotações Para criarmos anotações no ggplot2, podemos utilizar a função annotate(). Primeiro, vamos manipular os dados para saber qual é aquele ponto: ggplot(df_2017, aes(x = continent, y = life_expec)) + geom_boxplot() df_2017 %&gt;% filter(continent == &quot;Americas&quot;, life_expec &lt; 60) ## # A tibble: 1 x 22 ## country year life_ladder log_gdp_per_cap… social_support life_expec freedom_to_make… generosity ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Haiti 2017 3.82 7.40 0.647 53.3 0.484 0.385 ## # … with 14 more variables: perceptions_of_corruption &lt;dbl&gt;, positive_affect &lt;dbl&gt;, negative_affect &lt;dbl&gt;, ## # confidence_in_national_government &lt;dbl&gt;, democratic_quality &lt;dbl&gt;, delivery_quality &lt;dbl&gt;, ## # standard_deviation_of_ladder_by_country_year &lt;dbl&gt;, ## # standard_deviation_mean_of_ladder_by_country_year &lt;dbl&gt;, gini_index_world_bank_estimate &lt;dbl&gt;, ## # gini_index_world_bank_estimate_average_2000_15 &lt;dbl&gt;, ## # gini_of_household_income_reported_in_gallup_by_wp5_year &lt;dbl&gt;, continent &lt;chr&gt;, country_code &lt;dbl&gt;, ## # populacao_2020 &lt;dbl&gt; Com essas informações, podemos adicionar uma anotação ao gráfico: ggplot(df_2017, aes(x = continent, y = life_expec)) + geom_boxplot() + annotate(&quot;text&quot;, x = &quot;Americas&quot;, y = 52, label = &quot;Haiti&quot;) Também podemos adicionar segmentos e retângulos com o annotate(). Vamos marcar o período de 1982 a 2002 com um retângulo: df_feliz %&gt;% filter(country == &quot;Brazil&quot;) %&gt;% ggplot(aes(x = year, y = log_gdp_per_capita)) + geom_line() + geom_point() + annotate(&quot;rect&quot;, xmin = 2010, xmax = 2014, ymin = -Inf, ymax = Inf, alpha = 0.2) 12.3.10 Cleveland Dot Plot O cleveland dot plot é uma visualização que pode substituir os gráficos de barras. A ideia é que o gráfico fica menos poluído com os pontos, fazendo com que o leitor foque no que é importante. Vamos criar um gráfico para comparar as expectativas de vida no ano de 2007 para os países das Américas: df_2017 %&gt;% filter(continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = life_expec, y = reorder(country, life_expec))) + geom_point(size = 3, color = &quot;dodgerblue&quot;) Esse tipo de gráfico também pode apresentar mais de um ponto para cada valor da variável categórica (país): df_feliz %&gt;% filter(year %in% c(2010, 2017), continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = log_gdp_per_capita, y = country, color = factor(year))) + geom_point(aes(color = factor(year))) No gráfico acima, vemos dois pontos para cada país, um para representar 1987 e outro para 2007. Para completarmos o gráfico, precisamos adicionar uma linha conectando esses dois pontos. Esse gráfico é chamado de connected dot plot. Um detalhe importante é que queremos criar uma linha por país, assim, usaremos o elemento estético group para obter o resultado esperado: gapminder %&gt;% filter(year %in% c(1987, 2007), continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = lifeExp, y = country)) + geom_line(aes(group = country)) + geom_point(aes(color = factor(year))) + labs(title = &quot;Expectativa de vida por país - 1987 e 2007&quot;, y = &quot;País&quot;, x = &quot;Anos&quot;, color = &quot;Ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(panel.grid.major.y = element_line(linetype = &quot;dashed&quot;)) Para finalizar, vamos ordenar o eixo y pela expectativa de vida: gapminder %&gt;% filter(year %in% c(1987, 2007), continent == &quot;Americas&quot;) %&gt;% ggplot(aes(x = lifeExp, y = reorder(country, lifeExp, max))) + geom_line(aes(group = country), color = &quot;grey50&quot;) + geom_point(aes(color = factor(year))) + labs(title = &quot;Expectativa de vida por país - 1987 e 2007&quot;, y = &quot;País&quot;, x = &quot;Anos&quot;, color = &quot;Ano&quot;) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(panel.grid.major.y = element_line(linetype = &quot;dashed&quot;)) 12.3.11 Mapas de calor Para representar uma relação um pouco mais complexa, a de duas variáveis categóricas e uma numérica, pode-se usar um mapa de calor. Suponha que você deseja plotar a correlação entre todos os possíveis pares de correlação das variáveis de um dataset: # calcular correlacao entre as variaveis numericas do dataset de felicidade df_feliz_num &lt;- df_2017 %&gt;% select(life_ladder, log_gdp_per_capita, social_support, life_expec, perceptions_of_corruption) %&gt;% # removar NAs na.omit() # criar matriz de correlacao matriz_correl &lt;- cor(df_feliz_num) # de uma olhada no objeto criado # matriz_correl # transformar para dataframe matriz_correl &lt;- as.data.frame(matriz_correl) # conveter rownames para uma coluna matriz_correl &lt;- rownames_to_column(matriz_correl, &quot;var1&quot;) # converter dataframe para formato tidy matriz_correl_tidy &lt;- matriz_correl %&gt;% gather(var2, correlacao, -var1) head(matriz_correl_tidy) ## var1 var2 correlacao ## 1 life_ladder life_ladder 1.0000000 ## 2 log_gdp_per_capita life_ladder 0.7531552 ## 3 social_support life_ladder 0.7665324 ## 4 life_expec life_ladder 0.7359065 ## 5 perceptions_of_corruption life_ladder -0.5163756 ## 6 life_ladder log_gdp_per_capita 0.7531552 Assim, no dataframe var1 e var2, temos duas variáveis categóricas (os pares de variáveis) e uma numérica (a correlação entre as duas variáveis). A função do ggplot2 para criar um mapa de calor é geom_tile, que precisa de três aesthetics: os eixos x e y, que são as variáveis categóricas, e fill, que será a variável contínua que definirá a cor dos quadrados: matriz_correl_tidy %&gt;% ggplot(aes(x = var1, y = var2, fill = correlacao)) + geom_tile() Devido ao tamanho dos nomes das variáveis, o eixo x ficou difícil de ler. Uma solução é mudar o ângulo dos nomes, isto é, colocá-los na vertical. A função theme(), que ainda será mostrada em detalhes neste módulo, possui um argumento para fazer isso: matriz_correl_tidy %&gt;% ggplot(aes(x = var1, y = var2, fill = correlacao)) + geom_tile() + theme(axis.text.x = element_text(angle = 90)) 12.4 Escalas O controle sobre as escalas do gráfico é fundamental no ajuste de um gráfico. Em geral, o ggplot2, como outros pacotes gráficos, fornece as escalas automaticamente, não sendo necessário o entendimento de como se controlar este componente. No entanto, se o interesse é ter controle sobre todos os aspectos de um gráfico, esse componente é fundamental. Veja o gráfico abaixo: ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point() Note que a cor está mapeada para a variável Species. O ggplot2, automaticamente, criou a seguinte escala: Species Cor setosa vermelho versicolor verde virginica azul Todavia, é comum haver interesse em alterar-se essas cores, ou seja, alterar-se a escala de cor. Como fazer isso no ggplot2? Podemos usar, por exemplo, a função scale_color_manual(): ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point() + scale_color_manual(values = c(&quot;orange&quot;, &quot;black&quot;, &quot;red&quot;)) Utilizamos a função scale_color_manual() em razão da variável Species ser categórica. Para o ggplot2, dados categóricos são discretos, e a função citada permite criar-se uma escala discreta customizada. No entanto, essa não é a única função para controlar escala de cor. Existem outras como scale_color_discrete(), scale_color_continuous(), scale_color_gradient() etc. A utilização de cada função depende do tipo de dado que se está associando ao elemento estético color. Adiante, entraremos em mais detalhes sobre os tipos de dados. As funções utilizadas para controlar-se as escalas dos elementos de um gráfico do ggplot2 seguem um padrão. Todas iniciam-se com scale_, depois o nome do elemento estético (color, fill, x etc.) e, por fim, o tipo/nome da escala que será aplicada. Abaixo, continuaremos o exemplo anterior, alterando as escalas dos eixos x e y. Note que as variáveis Petal.Length e Petal.Width são variáveis numéricas/contínuas. Dessa forma, utilizaremos as funções scale_x_continuous() e scale_y_continuous(): ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point() + scale_color_manual(values = c(&quot;orange&quot;, &quot;black&quot;, &quot;red&quot;)) + scale_x_continuous(name = &quot;Petal Length&quot;, breaks = 1:7) + scale_y_continuous(name = &quot;Petal Width&quot;, breaks = 0:3, limits = c(0, 3)) No gráfico acima, definimos quais seriam os pontos em que rótulos deveriam ser exibidos em cada eixo. Além disso, no eixo y, definimos que os limites seriam 0 e 3. 12.4.1 Tipos de Variáveis Para melhor uso das escalas, é preciso saber o tipo de variável que foi mapeado para cada elemento estético. Vamos rapidamente montar essa relação: Classe Exemplo Tipo no ggplot2 numeric seq(0, 1, length.out = 10) continuous integer 1L:10L continuous ou discrete character c(“Sim”, “Não”) discrete factor factor(c(“Sim”, “Não”)) discrete date seq(as.Date(“2000/1/1”), by = “month”, length.out = 12) date Lembre-se que o padrão do ggplot é scale_, depois o nome do elemento estético (color, fill, x etc.) e, por fim, o tipo/nome da escala que será aplicada. É importante que o usuário saiba o tipo de dado, pois assim saberá com mais facilidade qual é o tipo de escala que deve ser escolhido. Vamos, em sequência, entrar em mais detalhes para escalas dos eixos (x e y) e de cores. Espera-se que a intuição desenvolvida a partir dos exemplos das escalas para esses elementos estéticos seja útil para os demais elementos estéticos. 12.4.2 Eixos 12.4.2.1 Variáveis Contínuas scale_x_continuous(name = waiver(), breaks = waiver(), minor_breaks = waiver(), labels = waiver(), limits = NULL, expand = waiver(), oob = censor, na.value = NA_real_, trans = &quot;identity&quot;) scale_y_continuous(name = waiver(), breaks = waiver(), minor_breaks = waiver(), labels = waiver(), limits = NULL, expand = waiver(), oob = censor, na.value = NA_real_, trans = &quot;identity&quot;) Vamos começar editando os valores dos eixos x e y. df_2017 %&gt;% mutate(populacao_milhoes = populacao_2020 / 1000) %&gt;% ggplot(aes(x = populacao_milhoes, y = life_expec)) + geom_point() + # definindo manualmente a escala do eixo x scale_x_continuous(breaks = c(0, 100, 200, 300, 400, 500, 1500)) + # definindo os intervalos da escala do eixo y scale_y_continuous(breaks = scales::breaks_width(5), minor_breaks = NULL) 12.4.2.2 Variáveis discretas Apesar do help não apresentar todos os argumentos para as escalas discretas, podemos usar quase todos que foram listados para escala contínua. scale_x_discrete(..., expand = waiver(), position = &quot;bottom&quot;) scale_y_discrete(..., expand = waiver(), position = &quot;left&quot;) No exemplo abaixo, alteraremos os rótulos para uma escala discreta, que originalmente contém os valores Yes e No. df_2017 %&gt;% count(continent, name = &quot;qtd_paises&quot;) %&gt;% ggplot(aes(x = continent, y = qtd_paises)) + geom_col() + scale_x_discrete(labels = c(&quot;África&quot;, &quot;AMÉRICAS&quot;, &quot;Ásia&quot;, &quot;Europa&quot;, &quot;Oceania&quot;)) 12.4.2.3 Variáveis de Datas Quando estamos trabalhando com séries temporais, é comum que datas sejam associadas a algum eixo do gŕafico, geralmente ao eixo x. As funções padrão para controle de escalas dos eixos, para variáveis de datas, são as seguintes: scale_x_date(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver()) scale_y_date(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver()) scale_x_datetime(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver()) scale_y_datetime(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver()) O scale_*_date é utilizado para variáveis do tipo Date e scale_*_datetime para variáveis do tipo POSIXct. A classe POSIXct aceita informações relacionadas a tempo/horário e a classe Date aceita apenas dia, mês e ano. O mais importante é a possibilidade de alterar-se o modo como as datas são apresentadas a partir do argumento date_labels. Para isso, utilizaremos um exemplo a partir dos dados economics. Primeiro, observa-se o resultado padrão do ggplot2: head(economics) ## # A tibble: 6 x 6 ## date pce pop psavert uempmed unemploy ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1967-07-01 507. 198712 12.6 4.5 2944 ## 2 1967-08-01 510. 198911 12.6 4.7 2945 ## 3 1967-09-01 516. 199113 11.9 4.6 2958 ## 4 1967-10-01 512. 199311 12.9 4.9 3143 ## 5 1967-11-01 517. 199498 12.8 4.7 3066 ## 6 1967-12-01 525. 199657 11.8 4.8 3018 ggplot(economics, aes(x = date, y = unemploy)) + geom_line() Agora, suponha que queremos alterar o gráfico para o formato “Jan/1970”: ggplot(economics, aes(x = date, y = unemploy)) + geom_line() + scale_x_date(date_labels = &quot;%b/%Y&quot;) O %b/%Y é usado para definir-se o formato de data desejado. Para ver a lista de formatos, use help(strptime). Para os breaks, temos duas opções: utilizar-se o argumento breaks, informando um vetor de datas, ou usar-se o argumento date_breaks, em que se informa a frequência dos breaks (por exemplo, “1 month” e “5 years”). Veja os exemplos abaixos: ggplot(economics, aes(x = date, y = unemploy)) + geom_line() + scale_x_date(date_breaks = &quot;5 years&quot;, date_labels = &quot;%Y&quot;) seq_datas &lt;- seq.Date(as.Date(&#39;1970-01-01&#39;), as.Date(&#39;2015-04-01&#39;), by = &#39;5 years&#39;) ggplot(economics, aes(x = date, y = unemploy)) + geom_line() + scale_x_date(breaks = seq_datas, date_labels = &quot;%Y&quot;) 12.4.3 Escalas de Cores (color) e Preenchimento (fill) Como nos casos dos eixos x e y, o tipo da variável utilizada define qual o tipo de escala. Tipo da Variável Escala Descrição Discreta hue escolhe n cores igualmente espaçadas em um disco de cores. É possível editar a luminosidade e a saturação. grey escala de cinza brewer ver pacote RColorBrewer identity usa as cores inseridas na própria variável manual escolhe as cores manualmente Contínua gradient cria um gradiente de duas cores (low-high) gradient2 cria um gradiente de cores divergentes (low-mid-high) gradientn cria um gradiente com n cores A opção hue usa a seguinte roda de cores: Figura 12.1: Roda de Cores - hue A opção brewer pode usar as paletas de cores disponíveis no pacote RColorBrewer. library(RColorBrewer) display.brewer.all(n=NULL, type=&quot;all&quot;, select=NULL, exact.n=TRUE, colorblindFriendly=FALSE) No exemplo abaixo, vamos utilizar a função brewer.pal, que retorna um vetor de cores de alguma paleta do pacote RColorBrewer. O objeto paleta.gradientn recebe nove cores da paleta Reds. Essas cores são utilizadas na função scale_fill_gradientn(). matriz_correl_tidy %&gt;% ggplot(aes(x = var1, y = var2, fill = correlacao)) + geom_tile() + theme(axis.text.x = element_text(angle = 90)) + scale_fill_distiller(palette = &quot;RdYlGn&quot;) Alguns pacotes também fornecem escalas de cores próprias, como é o caso do pacote viridis. matriz_correl_tidy %&gt;% ggplot(aes(x = var1, y = var2, fill = correlacao)) + geom_tile() + theme(axis.text.x = element_text(angle = 90)) + viridis::scale_fill_viridis() 12.5 Subplots (facet) facets são um excelente recurso do ggplot2 que permitem segmentar um gráfico em subgráficos de acordo com uma variável categórica. Existem duas maneiras de definir facets no ggplot2: facet_wrap(), ideal para apenas uma variável, e facet_grid() ideal para uma combinação de duas variáveis. Já vimos como acrescentar a informação do continente em um gráfico de pontos mudando o atributo color. Uma alternativa é criar um subgráfico para cada continente por meio de facets. Painéis em formato de grid: facet_grid(facets, margins = FALSE, scales = &quot;fixed&quot;, space = &quot;fixed&quot;, shrink = TRUE, labeller = &quot;label_value&quot;, as.table = TRUE, switch = NULL, drop = TRUE) Converte painéis de uma dimensão para duas dimensões: facet_wrap(facets, nrow = NULL, ncol = NULL, scales = &quot;fixed&quot;, shrink = TRUE, labeller = &quot;label_value&quot;, as.table = TRUE, switch = NULL, drop = TRUE, dir = &quot;h&quot;) Antes de mais nada, vamos criar um exemplo para o facet_wrap(): df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() + facet_wrap(vars(continent)) ## Warning: Removed 6 rows containing missing values (geom_point). Usamos a sintaxe vars(coluna). Ou seja, indicamos que queremos quebrar os gráficos pela variável continent. O ggplot2 determinou automaticamente o número de colunas e linhas e fixou as escalas dos eixos. No entanto, podemos definir o número de linhas ou colunas a partir dos argumentos nrow e ncol. Também é possível definir-se que cada gráfico tenha sua escala. No exemplo abaixo, deixaremos a escala do eixo y livre. df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() + facet_wrap(vars(continent), scales = &quot;free_y&quot;) ## Warning: Removed 6 rows containing missing values (geom_point). Caso se deseja utilizar mais de uma variável para criar os facets, usa-se a função facet_grid(): df_feliz %&gt;% # filtrar os anos de 2015 a 2017 filter(between(year, 2015, 2017)) %&gt;% ggplot(aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() + facet_grid(cols = vars(continent), rows = vars(year)) ## Warning: Removed 11 rows containing missing values (geom_point). 12.6 Temas O ggplot2 fornece alguns temas prontos. Todavia, o usuário pode alterar manualmente cada detalhe de um gráfico ou criar um tema que será utilizado em outras visualizações. Para editar o tema, será usada a função theme(). Nesta função, poderão ser alterados os elementos do tema, como a cor de fundo do painel, o tamanho da fonte do eixo x, a posição da legenda etc. A lista de elementos está disponível neste link. Para cada elemento do tema, um tipo de objeto é esperado para realizar alterações. Por exemplo, para alterar-se o estilo do título do eixo x (axis.title.x) é preciso passar-se a função element_text(), que possui diversos parâmetros (família da fonte, tipo da fonte, cor, tamanho, alinhamento etc.). Além do element_text(), as principais funções para alterar-se elementos do tema são element_line(), element_rect() e element_blank(). O element_blank() é usado a fim de que nada seja desenhado para o elemento que recebe esta função. Em um primeiro momento, pode parecer complicado alterar o tema via código, porém, conforme o usuário for praticando, essas alterações ficarão mais intuitivas. De toda forma, existe um addin para o RStudio que ajuda a customizar-se um gráfico do ggplot2 a partir de uma interface de point and click. Para instalá-lo, faça o seguinte: install.packages(&#39;ggThemeAssist&#39;) Para exemplificar a alteração do tema manualmente: ggplot(df_2017, aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() + theme(text = element_text(face = &quot;bold&quot;), panel.grid.major = element_line(colour = &quot;gray80&quot;), axis.title = element_text(size = 14), panel.background = element_rect(fill = &quot;gray100&quot;)) ## Warning: Removed 6 rows containing missing values (geom_point). 12.6.1 Temas disponíveis no ggplot2 p &lt;- ggplot(df_2017, aes(x = log_gdp_per_capita, y = life_expec)) + geom_point() p + theme_gray() + labs(title = &quot;theme_gray()&quot;) p + theme_bw() + labs(title = &quot;theme_bw()&quot;) p + theme_linedraw() + labs(title = &quot;theme_linedraw()&quot;) p + theme_light() + labs(title = &quot;theme_light()&quot;) p + theme_minimal() + labs(title = &quot;theme_minimal()&quot;) p + theme_classic() + labs(title = &quot;theme_classic()&quot;) p + theme_dark() + labs(title = &quot;theme_dark()&quot;) p + theme_void() + labs(title = &quot;theme_void()&quot;) ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). 12.6.2 Temas no pacote ggthemes O pacote ggthemes disponibiliza um conjunto de temas e escalas de cores. Vamos apresentar alguns temas disponíveis: ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). ## Warning: Removed 6 rows containing missing values (geom_point). 12.6.3 hrbrthemes Alguns pacotes fornecem seus próprios temas. É o caso do hrbrthemes. Este pacote fornece um tema bastante interessante e será usado no resto deste capítulo. Como qualquer outro tema, se for necessário, você pode editá-lo com a função theme(): install.packages(&quot;hrbrthemes&quot;) library(hrbrthemes) p + theme_ipsum(plot_title_size = 12, axis_title_size = 10) ## Warning: Removed 6 rows containing missing values (geom_point). 12.6.4 Setando o tema globalmente Com o comando abaixo, todos os gráficos do seu script terão o mesmo tema: theme_set(theme_ipsum(plot_title_size = 12, axis_title_size = 10) + theme(text = element_text(angle = 0))) 12.7 Legendas A melhor maneira de alterar as legendas de um gráfico do ggplot2, dando nomes mais amigáveis, é por meio da função labs(). p + labs(x = &quot;Log da PIB per capita&quot;, y = &quot;Expectativida de vida em anos&quot;, title = &quot;Relação entre PIB per capita e expectativida de vida&quot;, subtitle = &quot;Existe uma correlação positiva entre as duas variáveis&quot;, # Aqui usamos &#39;\\n&#39;, um character especial do R, para # adicioanar uma quebra de linha color = &quot;Continente\\n do país&quot;, caption = &quot;Autor: Eu&quot;) ## Warning: Removed 6 rows containing missing values (geom_point). 12.8 Mapas: plotando polígonos Produzir mapas com o R nunca foi tão fácil como hoje, graças a avanços recentes dos pacotes sf e ggplot2. Foge muito do escopo deste curso explicar a estrutura de dados espaciais, como shapefiles. Mesmo sem esse entedimento, porém, é possível fazer gráficos com mapas de maneira muito simples. O pacote geobr, desenvolvido pelo brasileiro Ítalo Cegatta, facilita a importação de arquivos shapefiles brasileiros. # importar shapefiles de estados brasileiros geo_ufs &lt;- geobr::read_state(code_state = &#39;all&#39;, year = 2018) ## Using year 2018 ## Loading data for the whole country ## | | | 0% | |==== | 4% | |======= | 7% | |=========== | 11% | |=============== | 15% | |=================== | 19% | |====================== | 22% | |========================== | 26% | |============================== | 30% | |================================== | 33% | |===================================== | 37% | |========================================= | 41% | |============================================= | 44% | |================================================= | 48% | |==================================================== | 52% | |======================================================== | 56% | |============================================================ | 59% | |================================================================ | 63% | |=================================================================== | 67% | |======================================================================= | 70% | |=========================================================================== | 74% | |=============================================================================== | 78% | |================================================================================== | 81% | |====================================================================================== | 85% | |========================================================================================== | 89% | |============================================================================================== | 93% | |================================================================================================= | 96% | |=====================================================================================================| 100% head(geo_ufs) ## Simple feature collection with 6 features and 5 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -73.99045 ymin: -13.6937 xmax: -46.06151 ymax: 5.271841 ## CRS: 4674 ## code_state abbrev_state name_state code_region name_region geom ## 1 11 RO Rondônia 1 Norte MULTIPOLYGON (((-62.89216 -... ## 2 12 AC Acre 1 Norte MULTIPOLYGON (((-71.07772 -... ## 3 13 AM Amazonas 1 Norte MULTIPOLYGON (((-69.61341 -... ## 4 14 RR Roraima 1 Norte MULTIPOLYGON (((-63.97805 2... ## 5 15 PA Pará 1 Norte MULTIPOLYGON (((-46.38475 -... ## 6 16 AP Amapá 1 Norte MULTIPOLYGON (((-53.27918 2... Observe que o dataframe possui cinco colunas, sendo a última relacionada às informações espaciais sobre os polígonos dos estados que serão usadas para construir os mapas. A sintaxe do ggplot2 para construir mapas é relativamente diferente: não é preciso definir nenhuma aesthetic, pois a função geom_sf internamente busca a coluna de polígonos presente no objeto: ggplot(geo_ufs) + # a linha abaixo da no mesmo que geom_sf(aes(geometry = geom)) geom_sf() A partir do gráfico base criado acima, as customizações seguem o padrão do ggplot2. Por exemplo, é possível mapear a cor os polígonos de acordo com uma variável presente nos dados, além de alterar aspectos visuais com a função theme: ggplot(geo_ufs) + # a linha abaixo da no mesmo que geom_sf(aes(geometry = geometry)) geom_sf(aes(geometry = geom, # colorir os poligonos de acordo com sua regiao fill = as.character(code_region))) + # deixar o mapa mais limpo e sem eixos theme( panel.background = element_blank(), panel.grid.major = element_line(color = &quot;transparent&quot;), axis.text = element_blank(), axis.ticks = element_blank() ) + # mudar titulo da legenda labs(fill = &quot;Região&quot;) Referências: [geom_sf()](https://ggplot2.tidyverse.org/reference/ggsf.html) [Tutorial de geom_sf()](https://dcl-2017-01.github.io/curriculum/notes/spatial-vis.html) 12.8.1 Projeto: plotando indicadores socioeconômicos em um mapa. Neste exemplo, mostramos como o ggplot2 pode ser usado para produzir mapas muito informativos, mapeando a cor de cada polígono a uma variável numérica, como PIB ou população. Observe o passo-a-passo de coleta e transformação dos dados do PIB per capita dos municípios brasileiros: # origem do conjunto de dados: # ftp://ftp.ibge.gov.br/Pib_Municipios/2017/base/base_de_dados_2010_2017_xls.zip # baixe o arquivo, descompacte, abra no excel ou no libre office e salve como xlsx # o R não consegue ler arquivos xls df_pib &lt;- read_excel(&#39;dados/base_de_dados_2010_2017_xls/PIB dos Municípios - base de dados 2010-2017.xlsx&#39;) # limpar nomes das colunas df_pib &lt;- janitor::clean_names(df_pib) # observe os dados: glimpse(df_pib) ## Rows: 44,545 ## Columns: 43 ## $ ano &lt;dbl&gt; … ## $ codigo_da_grande_regiao &lt;dbl&gt; … ## $ nome_da_grande_regiao &lt;chr&gt; … ## $ codigo_da_unidade_da_federacao &lt;dbl&gt; … ## $ sigla_da_unidade_da_federacao &lt;chr&gt; … ## $ nome_da_unidade_da_federacao &lt;chr&gt; … ## $ codigo_do_municipio &lt;dbl&gt; … ## $ nome_do_municipio &lt;chr&gt; … ## $ regiao_metropolitana &lt;chr&gt; … ## $ codigo_da_mesorregiao &lt;dbl&gt; … ## $ nome_da_mesorregiao &lt;chr&gt; … ## $ codigo_da_microrregiao &lt;dbl&gt; … ## $ nome_da_microrregiao &lt;chr&gt; … ## $ codigo_da_regiao_geografica_imediata &lt;dbl&gt; … ## $ nome_da_regiao_geografica_imediata &lt;chr&gt; … ## $ municipio_da_regiao_geografica_imediata &lt;chr&gt; … ## $ codigo_da_regiao_geografica_intermediaria &lt;dbl&gt; … ## $ nome_da_regiao_geografica_intermediaria &lt;chr&gt; … ## $ municipio_da_regiao_geografica_intermediaria &lt;chr&gt; … ## $ codigo_concentracao_urbana &lt;dbl&gt; … ## $ nome_concentracao_urbana &lt;chr&gt; … ## $ tipo_concentracao_urbana &lt;chr&gt; … ## $ codigo_arranjo_populacional &lt;dbl&gt; … ## $ nome_arranjo_populacional &lt;chr&gt; … ## $ hierarquia_urbana &lt;chr&gt; … ## $ hierarquia_urbana_principais_categorias &lt;chr&gt; … ## $ codigo_da_regiao_rural &lt;dbl&gt; … ## $ nome_da_regiao_rural &lt;chr&gt; … ## $ regiao_rural_segundo_classificacao_do_nucleo &lt;chr&gt; … ## $ amazonia_legal &lt;chr&gt; … ## $ semiarido &lt;chr&gt; … ## $ cidade_regiao_de_sao_paulo &lt;chr&gt; … ## $ valor_adicionado_bruto_da_agropecuaria_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ valor_adicionado_bruto_da_industria_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ valor_adicionado_bruto_dos_servicos_a_precos_correntes_exceto_administracao_defesa_educacao_e_saude_publicas_e_seguridade_social_r_1_000 &lt;dbl&gt; … ## $ valor_adicionado_bruto_da_administracao_defesa_educacao_e_saude_publicas_e_seguridade_social_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ valor_adicionado_bruto_total_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ impostos_liquidos_de_subsidios_sobre_produtos_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ produto_interno_bruto_a_precos_correntes_r_1_000 &lt;dbl&gt; … ## $ produto_interno_bruto_per_capita_a_precos_correntes_r_1_00 &lt;dbl&gt; … ## $ atividade_com_maior_valor_adicionado_bruto &lt;chr&gt; … ## $ atividade_com_segundo_maior_valor_adicionado_bruto &lt;chr&gt; … ## $ atividade_com_terceiro_maior_valor_adicionado_bruto &lt;chr&gt; … # agregando dados por estado, calculando o pib por cidade df_pib_uf &lt;- df_pib %&gt;% # filtrar 2017 filter(ano == 2017) %&gt;% # filtrar fora DF filter(sigla_da_unidade_da_federacao != &#39;DF&#39;) %&gt;% group_by(codigo_da_unidade_da_federacao) %&gt;% summarise(qtd_cidades = n(), pib_uf = sum(produto_interno_bruto_a_precos_correntes_r_1_000), pib_por_cidade = pib_uf/qtd_cidades) ## `summarise()` ungrouping output (override with `.groups` argument) head(df_pib_uf) ## # A tibble: 6 x 4 ## codigo_da_unidade_da_federacao qtd_cidades pib_uf pib_por_cidade ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 52 43506499. 836663. ## 2 12 22 14271063. 648685. ## 3 13 62 93204175. 1503293. ## 4 14 15 12103236. 806882. ## 5 15 144 155195371. 1077746. ## 6 16 16 15479885. 967493. Com o dataframe de PIB por cidade criado, podemos o unir com o dataframe que contem os dados espaciais dos estados: geo_uf_pib &lt;- left_join(geo_ufs, df_pib_uf, by = c(&#39;code_state&#39; = &#39;codigo_da_unidade_da_federacao&#39;)) head(geo_uf_pib) ## Simple feature collection with 6 features and 8 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -73.99045 ymin: -13.6937 xmax: -46.06151 ymax: 5.271841 ## CRS: 4674 ## code_state abbrev_state name_state code_region name_region qtd_cidades pib_uf pib_por_cidade ## 1 11 RO Rondônia 1 Norte 52 43506499 836663.4 ## 2 12 AC Acre 1 Norte 22 14271063 648684.7 ## 3 13 AM Amazonas 1 Norte 62 93204175 1503293.1 ## 4 14 RR Roraima 1 Norte 15 12103236 806882.4 ## 5 15 PA Pará 1 Norte 144 155195371 1077745.6 ## 6 16 AP Amapá 1 Norte 16 15479885 967492.8 ## geom ## 1 MULTIPOLYGON (((-62.89216 -... ## 2 MULTIPOLYGON (((-71.07772 -... ## 3 MULTIPOLYGON (((-69.61341 -... ## 4 MULTIPOLYGON (((-63.97805 2... ## 5 MULTIPOLYGON (((-46.38475 -... ## 6 MULTIPOLYGON (((-53.27918 2... Enfim, podemos proceder com a criação do mapa: ggplot(geo_uf_pib) + geom_sf(aes(fill = log(pib_por_cidade))) + # mudar escala de cores para sequencial vermelha scale_fill_distiller(type = &quot;seq&quot;, palette = &quot;Greens&quot;, direction = 1) + # deixar o mapa mais limpo e sem eixos theme( legend.position = &quot;bottom&quot;, panel.background = element_blank(), panel.grid.major = element_line(color = &quot;transparent&quot;), axis.text = element_blank(), axis.ticks = element_blank() ) + labs(title = &quot;PIB por cidade&quot;, fill = NULL) 12.9 Salvando Gráficos Há duas formas de salvar o gráfico gerado pelo ggplot2. A primeira delas é clicando no botão Export na aba Plots. Lá existirão três opções: exportar para o clipboard, salvar como PDF ou salvar como imagem. knitr::include_graphics(&#39;images/salvar_plot.gif&#39;) A outra opção é usar a função ggsave(): ggsave(filename, plot = last_plot(), device = NULL, path = NULL, scale = 1, width = NA, height = NA, units = c(&quot;in&quot;, &quot;cm&quot;, &quot;mm&quot;), dpi = 300, limitsize = TRUE, ...) O argumento device é usado para escolher-se o tipo de arquivo (“eps”, “ps”, “tex” (pictex), “pdf”, “jpeg”, “tiff”, “png”, “bmp”, “svg” or “wmf”). 12.10 Extensões do ggplot2 Um conjunto de pacotes fornece extensões ao ggplot2. Ou seja, cria funcionalidades não existentes no pacote original. Veja neste link uma galeria com as extensões. Aqui, exemplificaremos algumas: 12.10.1 ggrepel O ggrepel é importante para evitar que textos (geom_text) e rótulos (geom_label) se sobreponham. Veja o mesmo gráfico sem e com o ggrepel: library(ggrepel) data(mtcars) ggplot(mtcars, aes(wt, mpg)) + geom_point(color = &#39;red&#39;) + geom_text(aes(label = rownames(mtcars))) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) library(ggrepel) data(mtcars) ggplot(mtcars, aes(wt, mpg)) + geom_point(color = &#39;red&#39;) + geom_text_repel(aes(label = rownames(mtcars))) + theme_ipsum(plot_title_size = 12, axis_title_size = 10) 12.10.2 gganimate Outra extensão muito interessante é o gganimate. Com esta extensão é possível criar gifs (animações) de gráficos do ggplot2. O ponto fundamental é definir-se uma variável que controlará os frames, ou seja, as imagens que serão sobrepostas para compor-se a animação. Veja o exemplo abaixo: # O pacote não está no cran #devtools::install_github(&quot;dgrtwo/gganimate&quot;) library(gganimate) p &lt;- ggplot(gapminder, aes(x = gdpPercap, y = lifeExp, size = pop, color = continent, frame = year)) + geom_point() + scale_x_log10() animation::ani.options(interval = 1) x &lt;- gganimate(p, filename = &#39;images/gapminder1.gif&#39;, ani.width = 750, ani.height = 450) É possível suavizar a animação com o pacote tweenr. É um pouco complicado, mas fica o exemplo abaixo retirado deste post: library(tweenr) years &lt;- unique(gapminder$year) gapminder_list &lt;- list() for(i in 1:length(years)){ j &lt;- years[i] gapminder_list[[i]] &lt;- gapminder %&gt;% filter(year == j) } tf &lt;- tween_states(gapminder_list, tweenlength = 2, statelength = 0, ease = rep(&quot;linear&quot;, length(gapminder_list)), nframes = 308) tf2 &lt;- expand.grid(y = 80, x = 10^(2.5), year = seq(1957, 2007, 5)) tf2 &lt;- split(tf2, tf2$year) tf2 &lt;- tween_states(tf2, tweenlength = 2, statelength = 0, ease = rep(&quot;linear&quot;, length(tf2)), nframes = 308) tf2 &lt;- tf2 %&gt;% mutate(year = rep(seq(1957, 2007, 5), each = 29)[1:310]) p2 &lt;- ggplot(tf, aes(x=gdpPercap, y=lifeExp, frame = .frame)) + geom_point(aes(size=pop, color=continent), alpha=0.8) + geom_text(data = tf2, aes(x = x, y = y, label = year)) + xlab(&quot;GDP per capita&quot;) + ylab(&quot;Life expectancy at birth&quot;) + scale_x_log10() animation::ani.options(interval = 1/20) x &lt;- gganimate(p2, filename = &#39;images/gapminder2.gif&#39;, ani.width = 750, ani.height = 450, title_frame = FALSE) 12.11 Exercícios 12.11.1 Parte 1 Crie um gráfico de dispersão utilizando a base gapminder para o ano de 2007. Mapeie uma variável para o tamanho do ponto e adicione os títulos do gráfico e dos eixos. No gráfico anterior, como você faria para que o ponto do Brasil fosse identificado com uma cor adicional? Dica: se uma nova camada usar um segundo conjunto de dados é preciso informar usando o argumento data. Exemplo: geom_point(data = novo_data_frame, ...). Crie um histograma da variável wage a partir da base de dados Wage do pacote ISLR. Crie uma visualização da distribuição da variável wage por nível da variável education. Mapeie a variável education para o elemento estético fill. Crie um data.frame chamado Wage2 em que a variável education é removida. Adicione a seguinte camada no início do código: geom_histogram(data = Wage2, fill = &quot;grey50&quot;, alpha = 0.5) Veja e interprete o resultado. A partir do código abaixo, crie um gráfico que apresenta os dez países que tiveram maior crescimento do PIB em 2016 e aqueles dez que tiveram o menor. Use o facet_wrap para quebrar a visualização em dois gráficos. Escolha o objeto geométrico geom_col ou geom_point(). library(WDI) library(dplyr) gdp_growth &lt;- WDI(indicator = &quot;NY.GDP.MKTP.KD.ZG&quot;, start = 2016, end = 2016, extra = TRUE) # Remove regiões - ISO&#39;s com números gdp_growth &lt;- gdp_growth %&gt;% filter(!is.na(region) &amp; region != &quot;Aggregates&quot; &amp; !is.na(NY.GDP.MKTP.KD.ZG)) Utilize o mapa mundi disponível no pacote chropletrMaps e os dados que criamos no exercício anterior para plotar as variações do PIB em um mapa. library(choroplethrMaps) data(&quot;country.map&quot;) # Dados - Crescimento do PIB em 2016 library(WDI) library(dplyr) gdp_growth &lt;- WDI(indicator = &quot;NY.GDP.MKTP.KD.ZG&quot;, start = 2016, end = 2016, extra = TRUE) # Remove regiões - ISO&#39;s com números gdp_growth &lt;- gdp_growth %&gt;% filter(!is.na(region) &amp; region != &quot;Aggregates&quot; &amp; !is.na(NY.GDP.MKTP.KD.ZG)) # Continue fazendo o join entre country.map e gdp_growth # chaves: wb_a3 e iso3c country.map &lt;- country.map %&gt;% left_join(gdp_growth, by = c(&quot;wb_a3&quot; = &quot;iso3c&quot;)) ggplot(country.map, aes(x = long, y = lat, group = group)) + geom_polygon(aes(fill = NY.GDP.MKTP.KD.ZG)) + scale_fill_continuous(&quot;Var. % GDP&quot;) + coord_quickmap() Utilizando o código “NY.GDP.PCAP.KD” e o pacote WDI, crie um gráfico do tipo connected dot plot comparando a renda per capita entre o Brasil e mais cinco países nos anos de 1990 e 2010. 12.11.2 Parte 2 Importe o arquivo salvo herois_completo.csv no capítulo 06. Salve no objeto herois. Filtre os herois que possuem peso e altura maior que 0. Crie um histograma da variável altura. Analise a distribuição da variável peso em função da editora dos heróis. Crie um gŕafico de barras mostrando a quantidade de heróis por editora. Ordene as barras em ordem descrescente. Acrescente uma camada de texto nas barras mostrando a quantidade exata. Crie um gráfico de barras mostrando a quantidade de herois bons, maus ou neutros (variável alignment) por editora. Use tanto geom_bar() como geom_col() para isso, usando o argumento position = position_dodge() para separar as barras nas editoras. Repita o item anterior, trocando apenas o parâmeto position = position_dodge() para position = position_fill() para observar a proporção de personagens bons, maus ou neutros em cada editora. Use o dplyr e o tidyr para criar um dataset chamado hero_agg, que contem a quantidade de poderes agregado por editora e heroi. Dica: transforme as colunas de super-poderes em numéricas, converta o dataframe para formato tidy, agrupe os dados por editora e heroi e calcule a soma da coluna transformada de poderes. Faça um gráfico de barras mostrando os 10 herois de cada editora que possuem mais poderes. Dica: use facets para separa os herois de cada editora, usando scales = &quot;free_y&quot; e drop = TRUE. Inverta os eixos. Faça um gráfico de densidade da distribuição da quantidade de poderes dos herois por editora. Use o parâmetro alpha para aumentar a transparência das curvas. Para praticar com gráficos de séries temporais, usaremos outro dataset. Importe o dataset economics usando a função data(). Observe os dados com a função head(). Qual a periodicidade temporal dos dados (ex.: diário, semanal, mensal, anual) ? Faça um gráfico da variável unemploy ao longo do tempo. Salve esse gráfico no objeto p, que será usado nos próximos itens. Acrescente uma camada de área sombreada destacando o período entre 2001 a 2005. Acrescente algum comentário seu no gráfico usando a função geom_text(). Transforme o dataframe economics para o formato tidy. Faça um gráfico de linha de todos os indicadores econômicos ao longo do tempo, mapeando a aesthetic color à variável do nome do indicador. Note os problemas de escala do gráfico. Repita o item anterior, acrescentando uma camada de facets que separe os gráficos por indicador. Defina o parâmetro scales para ter escala livre no eixo y. "],
["htmlwidgets.html", "13 Visualizações Interativas 13.1 Introdução 13.2 Plotly 13.3 dygraphs 13.4 Leaflet 13.5 Exercícios", " 13 Visualizações Interativas 13.1 Introdução No R, as visualizações interativas são, geralmente, criadas a partir de pacotes que utilizam um framework chamado htmlwidgets. O hmtlwidgets é um pacote/framework que facilita o uso de bibliotecas javascript de visualizações para o ambiente R, sendo possível usá-las no console, no RMarkdown e no Shiny. Basicamente, javascript é uma linguagem client-side, ou seja, aquelas onde o processamento ocorre no lado do cliente. É utilizada, principalmente, para alterar códigos HTML e CSS (estilos) interativamente. O htmlwidgets busca fazer a ponte entre o R e alguma biblioteca javascript de visualização, fazendo com que o usuário do R consiga utilizar essas bibliotecas sem necessariamente precisar escrever uma linha de código em javascript. Apesar de não ser necessário, pode ser que, em algum momento, a fim de customizar uma visualização, seja necessário algum código em javascript, mas isto não será tratado aqui. Abaixo estão listados alguns projetos de visualização de dados em javascript: D3 D3plus Highcharts C3 Leaflet Plotly Existe uma quantidade significativa de pacotes que utilizam o htmlwidgets. Para se ter uma noção, visite esta galeria. O objetivo deste capítulo é fazer uma pequena apresentação sobre alguns pacotes. Cada pacote possui um conjunto de detalhes que torna inviável apresentá-los neste curso. Dessa forma, faremos um breve tour por alguns pacotes, começando com o plotly. 13.2 Plotly É possível ainda dar ainda mais vida aos seus gráficos os transformando em interativos de maneira muito fácil. O pacote plotly, além de ser um ótimo pacote para produzir gráficos interativos em R ou Python, possui uma funcão chamada ggplotly() que transforma um gráfico estático do ggplot2 em interativo. # criando grafico estatico library(gapminder) p &lt;- gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point(aes(color = continent)) p # converter para interativo ggplotly(p) Com apenas uma simples função, temos um gráfico cheio de recursos interativos, como possibilidade de dar zoom em áreas específicos do gráfico e tooltips, que é a pequena tabela de dados que aparece na tela ao passar o mouse em um ponto. Como era de se esperar, as tooltips também podem ser customizadas. A função ggplotly possui um parâmetro chamado tooltip onde pode ser especificada a aesthetic que será mostrada na tooltip. Por padrão, como você viu, a tooltip mostra todas as aesthetics definidas no gráfico. Caso você queira mudar esse aspecto, pode mudar o valor desse parâmetro em ggplotly: # mostrar apenas a aesthetic x, # na qual foi mapeada a variavel de expectativa de vida ggplotly(p, tooltip = &quot;x&quot;) Incrivelmente, dá para ficar ainda melhor. É definindo uma nova aesthetic chamada text, que por padrão não pertence ao ggplot2 mas é usada pelo plotly para construir a tooltip. Essa nova aesthetic, usada em combinação com a função paste0, pode criar tooltips informativas e elegantes. Caso não conheça a função paste0(), ela serve para concatenar vetores de strings em um só, de maneira paralelizada. Segue alguns exemplos: nome &lt;- c(&quot;Lucas&quot;, &quot;Eduardo&quot;, &quot;Flávio&quot;) sobrenome &lt;- c(&quot;Silva&quot;, &quot;Oliveira&quot;, &quot;Dias&quot;) # concatenar os dois vetores acima, juntando nome e sobrenome com espaço no meio paste0(nome, &quot; &quot;, sobrenome) ## [1] &quot;Lucas Silva&quot; &quot;Eduardo Oliveira&quot; &quot;Flávio Dias&quot; Usando essa função, vamos definir a aesthetic de forma que mostre o nome dos países e os valores das variáveis dos eixos: # refazer o grafico, definindo uma nova aesthetic chamada text: p &lt;- gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point(aes( color = continent, text = paste0(&quot;País: &quot;, country, &#39;\\n&#39;, &quot;Expectativa de vida: &quot;, round(lifeExp), &quot;\\n&quot;, &quot;PIB per capita: &quot;, gdpPercap) )) ggplotly(p, tooltip = &quot;text&quot;) 13.3 dygraphs O dygraphs é uma biblioteca para visualizações de séries temporais. Os detalhes do pacote estão disponíveis neste link. Antes dos exemplos, será necessário falar sobre objetos de séries de tempo no R. Para criar um objeto de séries de tempo usaremos a função ts(): ts(data = NA, start = 1, end = numeric(), frequency = 1, deltat = 1, ts.eps = getOption(&quot;ts.eps&quot;), class = , names = ) Os parâmetros relevantes são: data: um vetor ou uma matriz de valores da(s) série(s) de tempo. Um data.frame é transformado automaticamente em uma matriz; start: o período da primeira observação. Pode ser um valor único ou um vetor de dois inteiros. Geralmente, utiliza-se a segunda opção. Por exemplo, Janeiro de 1997: start = c(1997, 1); end: o período da última observação. Similar ao start, porém não é obrigatório; frequency: frequência dos dados. Mensal(12), Trimestral (4), Anual(1) etc. Exemplo de criação de uma série de tempo: x &lt;- rnorm(24, mean = 100, sd = 10) # Trasnformando em série mensal a partir de janeiro de 2010 x &lt;- ts(x, freq = 12, start = c(2010, 1)) plot(x) Outra maneira de declarar um objeto de série de tempo é utilizando a função xts() do pacote de mesmo nome. No entanto, para essa função, precisamos de um vetor ordenado de datas do tipo Date, POSIXct, timeDate, yearmon e yearqtr. library(xts) xts_df &lt;- data.frame(y = rnorm(365, 100, 10)) xts_df$data &lt;- seq.Date(as.Date(&quot;2011-01-01&quot;), length.out = 365, by = &quot;1 day&quot;) xts_df &lt;- xts(x = xts_df[, &quot;y&quot;], order.by = xts_df[, &quot;data&quot;]) head(xts_df) ## [,1] ## 2011-01-01 90.87153 ## 2011-01-02 100.81501 ## 2011-01-03 112.04756 ## 2011-01-04 109.55455 ## 2011-01-05 101.10612 ## 2011-01-06 99.33796 library(dygraphs) lungDeaths &lt;- cbind(mdeaths, fdeaths) dygraph(lungDeaths, main = &quot;Mortes por Doenças Pulmonares - Reino Unido - 1874-1979&quot;, ylab = &quot;Número de Morets&quot;) %&gt;% dySeries(&quot;mdeaths&quot;, color = &quot;blue&quot;, label = &quot;Homens&quot;) %&gt;% dySeries(&quot;fdeaths&quot;, color = &quot;green&quot;, label = &quot;Mulheres&quot;) %&gt;% dyRangeSelector() Aqui fica o código para alterar os padrões dos números e datas: # Alterar rótulos do eixo x e a legenda axlabform &lt;- &quot;function(date, granularity, opts, dygraph) { var months = [&#39;Janeiro&#39;, &#39;Fevereiro&#39;, &#39;Março&#39;, &#39;Abril&#39;, &#39;Maio&#39;, &#39;Junho&#39;, &#39;Julho&#39;, &#39;Agosto&#39;, &#39;Setembro&#39;, &#39;Outubro&#39;, &#39;Novembro&#39;, &#39;Dezembro&#39;]; return months[date.getMonth()] + \\&quot; \\&quot; + date.getFullYear()}&quot; valueform &lt;- &quot;function(ms) { var months = [&#39;Janeiro&#39;, &#39;Fevereiro&#39;, &#39;Março&#39;, &#39;Abril&#39;, &#39;Maio&#39;, &#39;Junho&#39;, &#39;Julho&#39;, &#39;Agosto&#39;, &#39;Setembro&#39;, &#39;Outubro&#39;, &#39;Novembro&#39;, &#39;Dezembro&#39;]; var ms = new Date(ms); return months[ms.getMonth()] + &#39;/&#39; + ms.getFullYear()}&quot; valueformy &lt;- &quot;function(value) { return (Math.round(value * 100)/100).toString() .replace(&#39;.&#39;, &#39;,&#39;) .replace(/\\\\B(?=(\\\\d{3})+(?!\\\\d))/g, &#39;.&#39;)}&quot; dygraph(lungDeaths, main = &quot;Mortes por Doenças Pulmonares - Reino Unido - 1874-1979&quot;, ylab = &quot;Número de Morets&quot;) %&gt;% dySeries(&quot;mdeaths&quot;, color = &quot;blue&quot;, label = &quot;Homens&quot;) %&gt;% dySeries(&quot;fdeaths&quot;, color = &quot;green&quot;, label = &quot;Mulheres&quot;) %&gt;% dyAxis(&quot;y&quot;, valueFormatter = valueformy) %&gt;% dyAxis(&quot;x&quot;, axisLabelFormatter = axlabform, valueFormatter = valueform) %&gt;% dyRangeSelector() 13.4 Leaflet O leaflet é, provavelmente, a principal biblioteca javascript para visualizações interativas de mapas. Mais informações sobre o pacote estão disponíveis neste link. Para iniciarmos uma visualização com leaflet, basta executar o código abaixo. A função addTiles() adiciona uma camada de mapas ao leaflet que foi inicializado. library(dplyr) library(leaflet) leaflet() %&gt;% addTiles() 13.4.1 Primeiro exemplo No primeiro exemplo, incluiremos um marcador na localização do IBPAD. Para isso, obteremos a latitude e a longitude usando a função geocode() do pacote ggmap. Além disso, foi incluída uma coluna chamada popup, que receberá um texto que será mostrado no mapa. library(ggmap) # Pegar Localização do ibpad (Google desatualizado) #loc.ibpad &lt;- geocode(&quot;IBPAD&quot;) loc.ibpad &lt;- data.frame(lon = -47.8838813, lat = -15.8010146) loc.ibpad$popup &lt;- &quot;Estamos aqui! (teoricamente)&quot; leaflet(loc.ibpad) %&gt;% addTiles() %&gt;% addMarkers(lat = ~lat, lng = ~lon, popup = ~popup) 13.4.2 Marcadores No exemplo abaixo, criaremos uma visualização com a posição de algumas empresas exportadoras de Mato Grosso, a partir de dados disponibilizados pelo MDIC. Como a busca da localização foi feita usando o endereço, nem sempre a localização estará perfeitamente correta. No entanto, para exemplificar o uso do pacote, não há problemas. dados.empresas.mt &lt;- read_delim(&#39;dados/empresas_exp_mt.csv&#39;, delim = &quot;;&quot;, locale = locale(encoding = &#39;ISO-8859-1&#39;, decimal_mark = &quot;,&quot;)) leaflet(dados.empresas.mt) %&gt;% addTiles() %&gt;% addMarkers(lat = ~lat, lng = ~lon, popup = ~EMPRESA) Podemos também adicionar outros tipos de marcadores, como círculos: leaflet(dados.empresas.mt) %&gt;% addTiles() %&gt;% addCircleMarkers(lat = ~lat, lng = ~lon, popup = ~EMPRESA, fillOpacity = 0.3) Adicionalmente, é possível agrupar pontos próximos em clusters. leaflet(dados.empresas.mt) %&gt;% addTiles() %&gt;% addCircleMarkers(lat = ~lat, lng = ~lon, popup = ~EMPRESA, fillOpacity = 0.3, clusterOptions = markerClusterOptions()) 13.4.3 Polígonos Também é possível criar-se polígonos a partir de shapefiles. Para isso, o caminho mais fácil é importar um shapefile usando o pacote sf, criar um gráfico estático com geom_sf() e o converter para interativo com plotly::ggplotly(): # baixa library(brmap) # remotes::install_github(&quot;italocegatta/brmap&quot;) mapa_ufs &lt;- brmap::brmap_estado head(mapa_ufs) ## Simple feature collection with 6 features and 4 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -73.99045 ymin: -13.6937 xmax: -46.07095 ymax: 5.271841 ## CRS: EPSG:4674 ## # A tibble: 6 x 5 ## estado_cod regiao_cod estado_nome estado_sigla geometry ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;POLYGON [°]&gt; ## 1 11 1 Rondônia RO ((-62.86662 -7.975868, -62.86017 -7.982323, -62.85336 -7.9875… ## 2 12 1 Acre AC ((-73.18253 -7.335496, -73.05413 -7.381955, -72.90031 -7.4376… ## 3 13 1 Amazonas AM ((-67.32609 2.029714, -67.31682 2.00125, -67.3104 1.966763, -… ## 4 14 1 Roraima RR ((-60.20051 5.264343, -60.19828 5.260453, -60.1969 5.257114, … ## 5 15 1 Pará PA ((-54.95431 2.583692, -54.93542 2.518585, -54.91956 2.499682,… ## 6 16 1 Amapá AP ((-51.1797 4.000081, -51.17784 3.997409, -51.17739 3.994021, … mapa_estatico &lt;- ggplot(mapa_ufs) + geom_sf(aes(text = estado_nome)) ## Warning: Ignoring unknown aesthetics: text # converter para interativo ggplotly(mapa_estatico, tooltip = &#39;text&#39;) 13.5 Exercícios Usando os pacotes ggmap e leaflet, crie uma visualização marcando cinco localizações de Brasília. Utilizando a base gapminder (library(gapminder)), crie uma visualização usando o pacote plotly. A partir da base economics do pacote ggplot2, escolha uma variável e plote a série histórica utilizando o pacote dygraphs. Entre na galeria de htmlwidgets [neste link], escolha alguma htmlwidget que você tenha achado interessante e replique um exemplo. .ggiraph{ font-size: 8px !important; } .dygraph-axis-label{ font-size: 60% !important; } .leaflet-control{ font-size: small !important; } "],
["rmarkdown.html", "14 RMarkdown 14.1 Usos do RMarkdown 14.2 Estrutura de um RMarkdown 14.3 Renderizando um documento 14.4 Sintaxe 14.5 Opções de Chunk 14.6 Principais Formatos 14.7 Excercícios", " 14 RMarkdown Antes de falarmos sobre o que é RMarkdown, é interessante discutirmos sobre o Markdown. Markdown é uma linguagem de marcação, ou seja, não é uma linguagem de programação. Linguagens de marcação dizem como algo deve ser entendido, mas não têm capacidade de processamento e execução de funções. Por exemplo, HTML é uma linguagem de marcação. Ela apenas diz como uma página web está estruturada, mas não executa nenhum processamento. O Markdown, da mesma forma, apenas informa como um documento está estruturado. No entanto, a vantagem do Markdown é a sua simplicidade e a possibilidade de utilização de uma linguagem comum para a criação de vários tipos de documentos. Por exemplo, um mesmo código Markdown pode ser convertido para HTML, LaTeX (gera pdf’s), docx etc. Para isso, é necessário um conversor, que lê um código em Markdown e, considerando a escolha do output desejado, converte o arquivo para a linguagem desejada. Isto ficará mais claro com os exemplos. E o que é o RMarkdown? Nada mais é do que a possibilidade de executar-se scripts em R (além de outras linguagens) e incorporá-los a um arquivo Markdown (extensão .md). O pacote knitr executará “pedaços” (chunk) de códigos e gerará um arquivo .md com os códigos e seus resultados. Na sequência, o pandoc, que é um conversor, converte-o para a linguagem desejada, gerando os arquivos nos formatos escolhidos (.html, .docx, .pdf, .odt). A figura abaixo ilustra o processo: Processo - RMarkdow Acesse este link para ver os tipos de formatos disponíveis no RMarkdown. É possível gerar documentos no formato Word, pdf formatados para revistas científicas, apresentações, dashboards etc. 14.1 Usos do RMarkdown A seção anterior já deu algumas dicas sobre a utilidade do RMarkdown. Aqui elaboraremos um pouco mais sua funcionalidade. Reprodutibilidade. Isto é importante quando um estudo é realizado. Pode ser que em algum momento após a realização do seu estudo outro analista/pesquisador deseje replicá-lo. Um documento que une o código às explicações pode ser fundamental neste momento. Compartilhamento de informação. É possível que você tenha aprendido a usar um novo pacote e ache que ele pode ser interessante para outros colegas. Com o RMarkdown, você poderá criar um documento com exemplos de uso do pacote, facilmente compartilhável. Documentação de Rotinas. A criação de rotinas para a realização de tarefas repetitivas é cada vez mais comum. No entanto, é importante que haja uma boa documentação da rotina para que você ou outro colega possa entender e dar manutenção à rotina no futuro. Relatórios parametrizados. O RMarkdown facilita a criação de relatórios, inclusive dashboards, em que a estrutura é padrão, mas os dados dependem de um parâmetro. Por exemplo, relatórios de balança comercial por unidade da federação (UF). No caso, a UF seria um parâmetro que variaria de relatório para relatório. 14.2 Estrutura de um RMarkdown --- title: &quot;Primeiro Exemplo para o Curso de R&quot; author: &quot;Paulo&quot; date: &quot;`r format(Sys.time(), &#39;%d de %B de %Y&#39;)`&quot; output: html_document: default pdf_document: fig_caption: yes fig_height: 3.5 fig_width: 7 number_sections: yes lang: pt-br --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) options(OutDec = &quot;,&quot;) ``` # Cabeçalho de primeiro nível ## Cabeçalho de segundo nível ### Cabeçalho de terceiro nível # Hello World Este é um primeiro exemplo de *RMarkdown* para o **Curso de Introdução ao `R`**. ## Outra Seção Vamos executar um código: ```{r, fig.cap=&quot;Exemplo de Figura&quot;, collapse=TRUE} library(ggplot2) x &lt;- rnorm(100) y &lt;- rnorm(100) dados &lt;- data.frame(x, y) ggplot(dados, aes(x = x, y = y)) + geom_point() ``` A média de x é `r mean(x)`. Vamos agora entender qual é a função de cada parte desse código. YAML (Configurações): --- title: &quot;Primeiro Exemplo para o Curso de R&quot; author: &quot;Paulo&quot; date: &quot;07 de agosto de 2020&quot; output: html_document: default pdf_document: fig_caption: yes fig_height: 3.5 fig_width: 7 number_sections: yes lang: pt-br --- O YAML é o responsável pelas configurações dos documentos. Basicamente, estamos informando qual é o título do documento, a data de criação, o nome do autor e o tipo de output que desejamos. No exemplo, está definido como output pdf_document e foram adicionadas opções para que as seções fossem numeradas e de tamanho das figuras. Caso quiséssemos um arquivo no formato Word (.docx), o output poderia ser modificado para word_document. Cada formato possui um conjunto de opções disponíveis. Nesse caso, é importante olhar-se a página de cada formato disponível na documentação do RMarkdown. Code Chunks: Os Code Chunks são pedaços de código em R que podem ser executados para gerar resultados que serão incorporados ao documento. Você pode inserir um chunk manualmente ou com o atalho CTRL + ALT + I. Dentro de {} é possível incluir uma série de opções relacionadas à execução do código. Abaixo, falaremos sobre algumas dessas opções. Textos e Markdown: Na figura acima, é mostrado como o texto se mistura com o código de markdown. Esse código markdown, quando convertido, gerará a formatação desejada. Na próxima seção, detalharemos o que cada marcação faz. 14.3 Renderizando um documento Há duas formas de se renderizar um documento .Rmd. A primeira é via função render() do pacote rmarkdown. render(input, output_format = NULL, output_file = NULL, output_dir = NULL, output_options = NULL, intermediates_dir = NULL, runtime = c(&quot;auto&quot;, &quot;static&quot;, &quot;shiny&quot;), clean = TRUE, params = NULL, knit_meta = NULL, envir = parent.frame(), run_pandoc = TRUE, quiet = FALSE, encoding = getOption(&quot;encoding&quot;)) Veja no help a função de cada argumento. Essa função é especialmente importante quando a renderização de um RMarkdown está inserida dentro de uma rotina. Por exemplo, pode-se usar a função render() dentro de um loop para criar-se vários pdf’s a partir de um relatório parametrizado. A outra opção é usando o botão knit, disponível na interface do RStudio. Botão Knit 14.4 Sintaxe Abaixo estão os principais elementos de sintaxe do RMarkdown. Vários são autoexplicativos. Para alguns, faremos alguns comentários: Cabeçalhos: # Cabeçalho de primeiro nível ## Cabeçalho de segundo nível ### Cabeçalho de terceiro nível O resultado, em um documento com output definido como pdf_document, seria: Estilo de texto: *Itálico* e **Negrito** Itálico e Negrito Citações: &gt; Aqui vai um texto para citação Aqui vai um texto para citação Código no texto: `mean(x)` mean(x) Código processado no texto: A opção abaixo é importante para que resultados do R possam ser incorporados diretamente ao texto do documento. Para demonstração, foi necessário darmos um espaço entre a aspa e o código, mas o correto é não haver esse espaço. ` r mean(c(2, 3, 4)) ` 3 Imagens: ![](images/code_chunk.png) ![Título Opcional](images/code_chunk.png) Listas não ordenadas: * Item a * Item b + Subitem b1 + Subitem b2 Item a Item b Subitem b1 Subitem b2 Listas ordenadas: 1. Item 1 2. Item 2 3. Item 3 i. Item 3a ii. Item 3b Item 1 Item 2 Item 3 Item 3a Item 3b Tabelas: --------: indica que a Coluna 1 está alinhada à direita. :------------: indica que a coluna está centralizada. Alguns pacotes do R fornecem funções para a geração de tabelas a partir de data.frames e matrizes. Veja: Coluna 1 | Coluna 2 -------------: | :-------------: 10 | Brasil 20 | China Fonte: MDIC. Coluna 1 Coluna 2 10 Brasil 20 China Fonte: MDIC. -------------------------------------------------------------------- Column 1 Column 2 ------------------------------------------------------ ------------ I want the contents of this cell to fit into one line Word1 Word2 ------------------------------------------------------ ------------ Column 1 Column 2 I want the contents of this cell to fit into one line Word1 Word2 x &lt;- letters[1:3] y &lt;- LETTERS[1:3] knitr::kable(data.frame(x, y), align = &#39;cc&#39;) x y a A b B c C Links: Site do [MDIC](www.mdic.gov.br) Site do MDIC Linha horizontal ou Quebra de Página: *** --- Equação: Modelo linear simples: $y_i = \\alpha + \\beta x_i + e_i$ Modelo linear simples: \\(y_i = \\alpha + \\beta x_i + e_i\\) Equação em Bloco: Modelo linear simples: $$y_i = \\alpha + \\beta x_i + e_i$$ Modelo linear simples: \\[y_i = \\alpha + \\beta x_i + e_i\\] 14.5 Opções de Chunk Os chunks de códigos ({r, ...}) que possuem uma série de opções. Elencaremos aqui as principais. Para a lista completa, veja este link. Opção Valor Padrão Descrição eval TRUE Indica se o código deve ser executado include TRUE Indica se o código deve ser exibido no documento final. Os resultados não serão apresentados. collapse FALSE Indica se o código e os resultados do chunk devem ser colapsados em um bloco único. echo FALSE Indica se o código será exibido no documento final. Os resultados serão apresentados. results markup Se hide, os resultados não serão exibidos. Se hold, os resultados serão exibidos ao final do chunk. Se asis, os resultados não serão formatados, sendo mostrados os resultados “brutos” (código html, tex, …). error TRUE Indica se mensagens de erros serão exibidas. message TRUE Indica se mensagens geradas pelo código serão exibidas. warning TRUE Indica se avisos gerados pelo código serão exibidos. fig.cap NULL Título de gráfico referente ao chunk. fig.height 7 Altura para gráficos criados pelo código (em polegadas). fig.width 7 Largura para gráficos criados pelo código (em polegadas). 14.6 Principais Formatos 14.6.1 HTML A HTML é a linguagem de marcação para construção de páginas web. Assim, se criarmos um documento e escolhermos como opção de output html_document, o resultado será uma página a ser aberta em browsers. Outros formatos do markdown, como flexdashboard e ioslides, também geram páginas html. Cada tipo de formato tem um conjunto de aspectos específicos. Abaixo listamos os principais para html: A aparência e o estilo são definidos por um arquivo no formato css. Isso impõe uma dificuldade adicional para a formatação do documento. O Rmarkdown fornece alguns temas e pacotes que também podem fornecer documentos com alguma formatação de estilo (ver prettydoc); Único formato que aceita htmlwidgets (o próprio nome indica isso). O código markdown incluído no arquivo .Rmd é convertido pelo pandoc, gerando um documento estruturado com código html. Vejamos abaixo o código em RMarkdown: Código RMarkdown para gerar um arquivo html Após o processamento, será gerado o seguinte código html: Exemplo de código HTML Esse código é interpretado pelo navegador e gera o seguinte resultado: Exemplo de formato HTML 14.6.2 PDF Para a criação de PDFs pelo RMarkdown, utiliza-se o LaTeX (pronuncia-se: Lah-tech or Lay-tech), que é um sistema de preparação de documentos muito utilizado pela comunidade científica. Inicialmente, o RMarkdown abstrai para o usuário a necessidade de saber-se essa linguagem. No entanto, como no HTML, se você quiser avançar na estrutura do documento e nos estilos será necessário aprender esta linguagem, pelo menos o suficiente para resolver o seu problema. Entre as vantagens do LaTeX estão: Numeração automática de seções (e os demais níveis) e de equações; Criação automática de legendas com base em arquivos .bib; Facilidade de referências cruzadas no documento. Como no caso do HTML, é possível usar templates. Isso é bastante útil para a criação de artigos científicos, que devem ser padronizados. Além disso, relatórios de instituições podem ser padronizados. Assim, basta que alguém crie um template e os demais poderão criar documentos com a mesma estrutura usando apenas o RMarkdown. LaTeX é uma versão mais amigável de TeX. Ou seja, LaTeX é uma linguagem em um nível maior do que TeX. Como no R, existem diversos pacotes em LaTeX que fornecem comandos para facilitar a edição de alguma parte do documento. Por exemplo: o pacote fancyhdr fornece comandos que facilitam a construção de cabeçalhos e rodapés. Abaixo está um pequeno código para se ter uma noção sobre essa linguagem: \\documentclass{article} \\title{Exemplo 1} \\author{Nome do Autor} \\date{\\today} \\begin{document} \\maketitle \\newpage \\section{Introdução} Aqui vai o texto! \\end{document} Basicamente, o código acima define a classe do documento como artigo, o título, o nome do autor e a data para o dia em que o documento for compilado. Depois, inicia-se o documento, criando o título (inclui título, autor e data), definindo uma quebra de página e a seção introdução. 14.6.2.1 Instalações necessárias Para criar documentos PDF no RMarkdown é preciso ter uma instalação TeX disponível. Para isso, é preciso baixar uma distribuição compatível com o seu sistema operacional. Nesta página estão listadas as distribuições disponíveis por sistema operacional. No Windows é comum usar a distribuição MiKTeX. 14.6.2.2 Exemplo Como no HTML, mostraremos primeiramente o código em RMarkdown: Código RMarkdown para gerar um arquivo html Esse código gerará um arquivo intermediário com a extensão .tex. Este arquivo terá o seguinte código: Código tex gerado Após a compilação, o seguinte documento é gerado: Exemplo de output pdf 14.6.3 Word A geração de word segue a geração dos demais formatos. No entanto, templates apenas funcionam para definir estilos que serão usados no documento. Atualmente, devido a limitações do conversor (pandoc), é difícil ter-se total acesso à formatação do documento. Código RMarkdown para gerar um arquivo word 14.7 Excercícios Crie um RMarkdown com o formato HTML para output. Neste documento, faça um mini tutorial sobre algum pacote que você aprendeu no curso ou outro pacote que você tenha conhecido. Crie as seções adequadamente e, se for o caso, crie tabelas. Crie um novo RMarkdown e explique o processo de criação de um gráfico usando o ggplot2. O ideal é criar um novo gráfico, mas fique livre para utilizar algum exemplo deste material. Utilizando o pacote WDI, crie uma visualização com o pacote dygraphs para a série de renda per capita do Brasil (BRA). Coloque um título no seu documento e faça com que o código não seja apresentado ao leitor. A partir do exemplo anterior, crie um parâmetro chamado country_code no cabeçalho de configuração (yaml). Este parâmetro será usado para selecionar-se o país base para a visualização. Crie um vetor com cinco códigos de países. A partir deste vetor, utilize a função render para criar um arquivo para cada país. library(rpart) library(randomForest) library(ModelMetrics) library(rpart.plot) "],
["modelos.html", "15 Modelos 15.1 Modelo Linear 15.2 Exercícios", " 15 Modelos O objetivo deste capítulo é dar uma visão geral sobre a estrutura de modelos no R. Isto é, quais são as suas funções básicas, como especificar um modelo, recuperar resíduos, realizar predições etc. Esse processo é parte fundamental de análises mais aprofundadas. Os modelos podem ser usados, de maneira não exclusiva, para exploração de dados, geração de predições e análises de causalidade. Por exemplo: Descritivo: relação entre salários, idade, experiência e anos de estudo; Predição: modelo para identificar risco de fraude em uma transação bancária, classificação de imagens, previsão do PIB para o ano que vem; Causalidade: aumento de imposto sobre cigarro e redução no consumo. 15.1 Modelo Linear Vamos introduzir a estrutura de modelos no R a partir de modelos lineares. Trataremos do modelo linear para regressão e do modelo de regressão logística para classificação. O modelo de regressão é utilizado quando a variável de interesse (dependente ou target) é uma variável quantitativa contínua. Por exemplo, salários, preços, notas em um exame etc. Por outro lado, modelos de classificação são utilizados quando a variável de interesse é categórica. Por exemplo: uma pessoa tem ou não tem a doença X, o cliente pagou ou não o cartão de crédito, o usuário X é um robô ou uma pessoa etc. 15.1.1 Regressão Vamos começar com o modelo linear de regressão: \\[y_i = \\beta_0 + \\beta_1 x_{1i} + \\beta_2 x_{2i} + ... + \\beta_k x_{ki} + \\epsilon_i, ~~ i = 1, ..., N,\\] onde \\(y\\) é a variável dependente, \\(x_{k}\\) é a k-ésima variável explicativa, \\(\\beta_k\\) é o parâmetro estimado para k-ésima variável e \\(\\epsilon\\) é o termo de erro. A função lm() estima esse modelo pelo método denominado de mínimos quadrados ordinários (MQO). Antes de exemplificarmos o uso da função, vamos falar sobre a representação simbólica do modelo, ou seja, como especificar o modelo no R. Em geral, o modelo terá argumentos x e y, em que o usuário passa os dados nesses argumentos ou terá a estrutura de fórmula. Por ser o método menos usado no modelo linear, detalharemos a estrutura de fórmula. Na função lm(), é obrigatório passar-se um objeto da classe fórmula, ou algum objeto que possa ser convertido para uma fórmula. Por exemplo: para o modelo linear com duas variáveis (\\(y\\) e \\(x\\)) e uma constante, a fórmula correspondente é: f &lt;- &#39;y ~ x&#39; class(f) ## [1] &quot;character&quot; class(as.formula(f)) ## [1] &quot;formula&quot; Para mostrarmos as possibilidades de uso da fórmula de especificação do modelo, utilizaremos a base mtcars. Esta base traz o consumo de gasolina (mpg) e algumas outras características do veículo. Detalharemos cada variável explicativa conforme elas são usadas. No entanto, você pode olhar o help dessa base: ?mtcars. Para iniciarmos, utilizaremos a variável mpg (miles per galon) e a variável hp (Gross horsepower). data(mtcars) lm(mpg ~ hp, data = mtcars) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars) ## ## Coefficients: ## (Intercept) hp ## 30.09886 -0.06823 Note que não houve especificação de uma constante. Automaticamente, o R inclui a constante. Você pode inclui-la explicitamente ou retirá-la: lm(mpg ~ hp + 1, data = mtcars) lm(mpg ~ hp + 0, data = mtcars) Já temos uma pista de como incluir mais variáveis: basta “adicioná-las” com o símbolo +. Isto é, vamos incluir a variável am - Transmission (0 = automatic, 1 = manual) - no modelo: lm(mpg ~ hp + am, data = mtcars) Se quiséssemos incluir todas as variáveis explicativas: lm(mpg ~ ., data = mtcars) Interações: lm(mpg ~ hp + am + hp:am, data = mtcars) Transformações: lm(log(mpg) ~ log(hp) + am, data = mtcars) ## ## Call: ## lm(formula = log(mpg) ~ log(hp) + am, data = mtcars) ## ## Coefficients: ## (Intercept) log(hp) am ## 5.1196 -0.4591 0.1954 No entanto, algumas transformações podem se confundir com símbolos quem são usados na fórmula. No exemplo abaixo, abstraia os dados e foque no efeito resultante da fórmula: lm(mpg ~ (am + hp)^2 + hp^2, data = mtcars) ## ## Call: ## lm(formula = mpg ~ (am + hp)^2 + hp^2, data = mtcars) ## ## Coefficients: ## (Intercept) am hp am:hp ## 26.6248479 5.2176534 -0.0591370 0.0004029 (am + hp)^2, em termos simbólicos, retorna am + hp + am*hp e hp^2 retorna hp. No caso em que um símbolo não pode ser usado diretamente, este deve ser usado dentro da função I(): lm(mpg ~ hp + I(hp^2), data = mtcars) ## ## Call: ## lm(formula = mpg ~ hp + I(hp^2), data = mtcars) ## ## Coefficients: ## (Intercept) hp I(hp^2) ## 40.4091172 -0.2133083 0.0004208 Variáveis categóricas são convertidas automaticamente para dummies. Por exemplo, vamos adicionar uma variável fictícia chamada cat, que receberá valores a, b e c ao data.frame mtcars: library(tidyverse) mtcars &lt;- mutate(mtcars, cat = sample(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), size = nrow(mtcars), replace = TRUE)) lm(mpg ~ hp + cat, data = mtcars) ## ## Call: ## lm(formula = mpg ~ hp + cat, data = mtcars) ## ## Coefficients: ## (Intercept) hp catb catc ## 29.54197 -0.06645 -0.90406 1.85067 Falta agora discutir os principais argumentos da função lm(): lm(formula, data, subset, weights, na.action, method = &quot;qr&quot;, model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...) O argumento formula já foi discutido anteriormente. É neste argumento que o modelo é especificado. O argumento data recebe (opcionalmente) um data.frame com os dados. O parâmetro data é opcional, porque você pode passar diretamente os vetores de dados. Por exemplo: lm(log(mtcars$mpg) ~ log(mtcars$hp)) ## ## Call: ## lm(formula = log(mtcars$mpg) ~ log(mtcars$hp)) ## ## Coefficients: ## (Intercept) log(mtcars$hp) ## 5.5454 -0.5301 Continuando, há possibilidade de estimar-se o modelo para um subconjunto dos dados, sendo necessário informar um vetor que selecione as observações que entrarão na estimação, no argumento subset. No exemplo que estamos utilizando, suponha que você queira estimar o modelo apenas para os carros automáticos: lm(mpg ~ hp, data = mtcars, subset = (am == 0)) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars, subset = (am == 0)) ## ## Coefficients: ## (Intercept) hp ## 26.62485 -0.05914 lm(mpg ~ hp, data = mtcars, subset = (am == 1)) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars, subset = (am == 1)) ## ## Coefficients: ## (Intercept) hp ## 31.84250 -0.05873 Há também a possibilidade de utilizar-se um vetor de pesos no argumento weight para a estimação de mínimos quadrados ordinários. Para ver-se um sumário dos resultados da estimação, utiliza-se a função summary(): summary(lm(mpg ~ hp, data = mtcars)) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.7121 -2.1122 -0.8854 1.5819 8.2360 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 30.09886 1.63392 18.421 &lt; 2e-16 *** ## hp -0.06823 0.01012 -6.742 1.79e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.863 on 30 degrees of freedom ## Multiple R-squared: 0.6024, Adjusted R-squared: 0.5892 ## F-statistic: 45.46 on 1 and 30 DF, p-value: 1.788e-07 15.1.1.1 Acessando os resultados Além do resumo, é possível acessar uma série de objetos gerados pela função lm(), como coeficientes, resíduos, valores preditos (dentro do conjunto de estimação) etc. Primeiro, vamos listar esses elementos: fit &lt;- lm(mpg ~ hp, data = mtcars) is.list(fit) ## [1] TRUE ls(fit) ## [1] &quot;assign&quot; &quot;call&quot; &quot;coefficients&quot; &quot;df.residual&quot; &quot;effects&quot; &quot;fitted.values&quot; ## [7] &quot;model&quot; &quot;qr&quot; &quot;rank&quot; &quot;residuals&quot; &quot;terms&quot; &quot;xlevels&quot; Como se trata de uma lista, podemos acessar os objetos usando o $. fit$coefficients ## (Intercept) hp ## 30.09886054 -0.06822828 fit$residuals[1:10] ## 1 2 3 4 5 6 7 8 9 10 ## -1.5937500 -1.5937500 -0.9536307 -1.1937500 0.5410881 -4.8348913 0.9170676 -1.4687073 -0.8171741 -2.5067823 Também existem funções para se acessar esses resultados: coefficients(fit) ## (Intercept) hp ## 30.09886054 -0.06822828 residuals(fit)[1:5] ## 1 2 3 4 5 ## -1.5937500 -1.5937500 -0.9536307 -1.1937500 0.5410881 15.1.1.2 Predições No R, para realizar-se predições, utiliza-se a função predict(), que é uma função genérica. Isso significa que os seus argumentos e os valores retornados dependem da classe do objeto que estamos passando. No caso de um objeto da classe lm, é suficiente passar o próprio objeto. Abaixo está um exemplo do seu uso: set.seed(13034) # para replicação # 70% dos dados idx &lt;- sample(nrow(mtcars), size = 0.7*nrow(mtcars), replace = FALSE) train &lt;- mtcars[idx, ] test &lt;- mtcars[-idx, ] # 2 Modelos fit1 &lt;- lm(mpg ~ hp, data = train) fit2 &lt;- lm(mpg ~ hp + am + disp, data = train) # Predições pred1 &lt;- predict(fit1, newdata = test[,-1]) pred2 &lt;- predict(fit2, newdata = test[,-1]) # Comparando Root Mean Square Errors library(ModelMetrics) rmse(pred1, test[, &quot;mpg&quot;]) ## [1] 4.958482 rmse(pred2, test[, &quot;mpg&quot;]) ## [1] 3.568993 15.1.2 Classificação Como já mencionado, quando a variável de interesse é categórica, utilizamos modelos de classificação. O modelo linear mais conhecido é o chamado Regressão Logística. Suponha que queremos prever se uma pessoa irá ou não pagar a fatura do cartão de crédito. Definimos como \\(p\\) a probabilidade da pessoa não pagar e como razão de chance (_odds ratio) o valor \\(\\frac{p}{1-p}\\). A função logit, por sua vez, é definida como: \\[ logit(p) = log\\left(\\frac{p}{1-p}\\right)\\] Sendo \\(y\\) a nossa variável dependente, vamos definir que ela recebe valor 1 se o cliente não paga e 0 caso contrário. Logo, o modelo linear para o logit é definido como: \\[ logit(p(y = 1|X)) = \\beta_0 + \\beta_1 x_{1i} + \\beta_2 x_{2i} + ... + \\beta_k x_{ki}\\] Os parâmetros \\(\\beta&#39;s\\) são obtidos a partir de métodos de otimização em que o objetivo minimizar é uma função de perda determinada. Note que a probabilidade de ocorrência do evento pode ser calculada como: \\[ p(y = 1|X) = \\frac{e^{\\beta_0 + \\beta_1 x_{1i} + \\beta_2 x_{2i} + ... + \\beta_k x_{ki}}}{1 + e^{\\beta_0 + \\beta_1 x_{1i} + \\beta_2 x_{2i} + ... + \\beta_k x_{ki}}}\\] Um detalhe importante sobre a regressão logística é que este modelo se enquadra na classe de modelos lineares generalizados (generalized linear models - glm). Logo, este modelo pode ser estimado a partir da função glm(), escolhendo a família binomial no argumento family. O exemplo a seguir vem do livro An Introduction to Statistical Learning with Application in R. Utilizaremos o pacote ISLR e o conjunto de dados Smarket (?Smarket). Essa base traz informações sobre as variações do índice S&amp;P 500 entre 2001 e 2005. Este índice é composto por 500 ativos negociados na NYSE ou Nasdaq. library(ISLR) data(&quot;Smarket&quot;) head(Smarket) ## Year Lag1 Lag2 Lag3 Lag4 Lag5 Volume Today Direction ## 1 2001 0.381 -0.192 -2.624 -1.055 5.010 1.1913 0.959 Up ## 2 2001 0.959 0.381 -0.192 -2.624 -1.055 1.2965 1.032 Up ## 3 2001 1.032 0.959 0.381 -0.192 -2.624 1.4112 -0.623 Down ## 4 2001 -0.623 1.032 0.959 0.381 -0.192 1.2760 0.614 Up ## 5 2001 0.614 -0.623 1.032 0.959 0.381 1.2057 0.213 Up ## 6 2001 0.213 0.614 -0.623 1.032 0.959 1.3491 1.392 Up A base consiste em nove variáveis. A variável de interesse é Direction e outras cinco variáveis serão usadas como variáveis explicativas ou preditores. Inicialmente, separaremos nossos dados em treino e teste. Como trata-se de um problema de série temporal, utilizaremos a variável Year para separar os dados. train &lt;- Smarket %&gt;% filter(Year &lt;= 2004) %&gt;% select(-Year) test &lt;- Smarket %&gt;% filter(Year == 2005) %&gt;% select(-Year) Agora vamos estimar o modelo: fit &lt;- glm(Direction ~ . -Today, data = train, family = binomial()) summary(fit) ## ## Call: ## glm(formula = Direction ~ . - Today, family = binomial(), data = train) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.302 -1.190 1.079 1.160 1.350 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.191213 0.333690 0.573 0.567 ## Lag1 -0.054178 0.051785 -1.046 0.295 ## Lag2 -0.045805 0.051797 -0.884 0.377 ## Lag3 0.007200 0.051644 0.139 0.889 ## Lag4 0.006441 0.051706 0.125 0.901 ## Lag5 -0.004223 0.051138 -0.083 0.934 ## Volume -0.116257 0.239618 -0.485 0.628 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 1383.3 on 997 degrees of freedom ## Residual deviance: 1381.1 on 991 degrees of freedom ## AIC: 1395.1 ## ## Number of Fisher Scoring iterations: 3 As predições são realizadas com a função predict(), mas com o detalhe de que temos que escolher o tipo de predição. O default, link, passará o logit. Isto é, o valor da predição linear. Já response estimará a probabilidade da observação do evento de interesse. Por fim, terms retorna uma matriz com a predição linear para cada variável explicativa. O nosso interesse é na probabilidade do mercado ter subido, logo, usaremos o tipo response e transformaremos a probabilidade em Up e Down. pred &lt;- predict(fit, test, type = &#39;response&#39;) pred &lt;- ifelse(pred &gt; 0.5, &quot;Up&quot;, &quot;Down&quot;) pred &lt;- factor(pred, levels = c(&quot;Down&quot;, &quot;Up&quot;)) Abaixo avaliamos o erro de classificação, que é de, aproximadamente, 52%. Ou seja, pior do que um chute aleatório. # Taxa de erro ce(test$Direction, pred) ## [1] 0.5198413 Os autores, então, sugerem estimar-se o modelo com apenas duas variáveis. fit &lt;- glm(Direction ~ Lag1 + Lag2, data = train, family = binomial()) pred &lt;- predict(fit, test, type = &#39;response&#39;) pred &lt;- ifelse(pred &gt; 0.5, &quot;Up&quot;, &quot;Down&quot;) pred &lt;- factor(pred, levels = c(&quot;Down&quot;, &quot;Up&quot;)) # Taxa de erro ce(test$Direction, pred) ## [1] 0.4404762 Nesse caso, o modelo acertaria 56% das vezes. 15.1.3 Classificação com modelos baseados em árvores Uma das limitações da regressão logística é que esse método não vai funcionar bem quando não for possível separar as classes linearmente, como no exemplo abaixo: #### atencao: nao precisam se preocupar em reproduzir o codigo abaixo # criar matriz de dados aleatorios mat &lt;- matrix(rnorm(5000, mean = 0, sd = 3), ncol = 2) %&gt;% as.data.frame() # criar elipse que circunda 25% dos pontos el &lt;- car::dataEllipse(mat[, 1], mat[, 2], levels = 0.25, draw = FALSE) # determinar se um ponto da matriz está dentro da elipse mat$ta_dentro &lt;- sp::point.in.polygon(mat[,1], mat[,2], el[,1], el[,2]) mat$ta_dentro &lt;- as.factor(mat$ta_dentro) # construir grafico de pontos, colorindo a elipse ggplot(mat, aes(x = V1, y = V2, color = ta_dentro)) + geom_point() Algoritmos baseados em Decision Trees tentam achar maneiras de criar subsets ou subgrupos do universo dos dados, onde cada subgrupo pertence a um node. O objetivo do modelo é criar nodes onde haja uma distinção clara entre as classes previstas de forma que possa a cada node a probabilidade de um indivíduo pertencer a uma classe. O gráfico abaixo é um exemplo simples e didática de uma árvore de decisão: Figura 15.1: Fonte: Machine Learning Mastery Nesse modelo, que tenta prever o sexo de uma pessoa baseada na altura e no peso, o algoritmo de classificação funciona como uma série de regras SE-NÃO: Se a altura for maior que 180cm, o indivíduo é um homem; Se a altura é menor ou igual a 180cm e o peso é maior que 80kg, o indivíduo é homem; Caso contrário, o indivíduo é mulher. No R, os modelos de Decision Trees são aplicados principalmente pelo pacote rpart. Este tutorial é bem explicativo. 15.1.3.1 Estudo de caso: coleta dos dados e análise exploratória Como dataset de demonstração para a árvore de decisão, usaremos um bem interessante: Tentaremos entender o que leva um empregado a pedir ou não demissão de sua empresa. Entrem neste link, loguem no Kaggle e baixem o dataset para a mesma pasta de trabalho que estão usando no R. O código abaixo mostra como importar e consolidar todos os datasets em um só dataframe: Vejamos como ficou nosso conjunto de dados: glimpse(rh) ## Rows: 4,300 ## Columns: 30 ## $ Age &lt;dbl&gt; 51, 31, 32, 38, 32, 46, 28, 29, 31, 25, 45, 55, 47, 28, 37, 21, 37, 35, 38, … ## $ Attrition &lt;fct&gt; No, Yes, No, No, No, No, Yes, No, No, No, No, No, Yes, No, No, No, No, No, N… ## $ BusinessTravel &lt;fct&gt; Travel_Rarely, Travel_Frequently, Travel_Frequently, Non-Travel, Travel_Rare… ## $ Department &lt;fct&gt; Sales, Research &amp; Development, Research &amp; Development, Research &amp; Developmen… ## $ DistanceFromHome &lt;dbl&gt; 6, 10, 17, 2, 10, 8, 11, 18, 1, 7, 17, 14, 1, 1, 1, 3, 1, 7, 8, 1, 8, 11, 16… ## $ Education &lt;dbl&gt; 2, 1, 4, 5, 1, 3, 2, 3, 3, 4, 2, 4, 1, 3, 3, 2, 3, 4, 3, 4, 4, 4, 4, 4, 3, 1… ## $ EducationField &lt;fct&gt; Life Sciences, Life Sciences, Other, Life Sciences, Medical, Life Sciences, … ## $ EmployeeCount &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ EmployeeID &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 2… ## $ Gender &lt;fct&gt; Female, Female, Male, Male, Male, Female, Male, Male, Male, Female, Male, Fe… ## $ JobLevel &lt;dbl&gt; 1, 1, 4, 3, 1, 4, 2, 2, 3, 4, 2, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1… ## $ JobRole &lt;fct&gt; Healthcare Representative, Research Scientist, Sales Executive, Human Resour… ## $ MaritalStatus &lt;fct&gt; Married, Single, Married, Married, Single, Married, Single, Married, Married… ## $ MonthlyIncome &lt;dbl&gt; 131160, 41890, 193280, 83210, 23420, 40710, 58130, 31430, 20440, 134640, 799… ## $ NumCompaniesWorked &lt;dbl&gt; 1, 0, 1, 3, 4, 3, 2, 2, 0, 1, 0, 0, 1, 1, 4, 1, 2, 7, 1, 1, 3, 3, 1, 3, 1, 1… ## $ Over18 &lt;fct&gt; Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y… ## $ PercentSalaryHike &lt;dbl&gt; 11, 23, 15, 11, 12, 13, 20, 22, 21, 13, 13, 17, 11, 14, 11, 12, 13, 16, 11, … ## $ StandardHours &lt;dbl&gt; 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8… ## $ StockOptionLevel &lt;dbl&gt; 0, 1, 3, 3, 2, 0, 1, 3, 0, 1, 2, 0, 2, 0, 0, 3, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0… ## $ TotalWorkingYears &lt;dbl&gt; 1, 6, 5, 13, 9, 28, 5, 10, 10, 6, 21, 37, 10, 5, 7, 3, 15, 10, 8, 6, 28, 21,… ## $ TrainingTimesLastYear &lt;dbl&gt; 6, 3, 2, 5, 2, 5, 2, 2, 2, 2, 2, 2, 4, 2, 2, 3, 2, 5, 5, 3, 2, 2, 2, 2, 3, 2… ## $ YearsAtCompany &lt;dbl&gt; 1, 5, 5, 8, 6, 7, 0, 0, 9, 6, 20, 36, 10, 5, 5, 3, 5, 7, 8, 6, 10, 5, 10, 10… ## $ YearsSinceLastPromotion &lt;dbl&gt; 0, 1, 0, 7, 0, 7, 0, 0, 7, 1, 4, 4, 9, 0, 0, 1, 0, 6, 7, 1, 1, 1, 0, 0, 3, 5… ## $ YearsWithCurrManager &lt;dbl&gt; 0, 4, 3, 5, 4, 7, 0, 0, 8, 5, 10, 13, 9, 4, 1, 0, 2, 2, 7, 4, 6, 3, 9, 8, 3,… ## $ EnvironmentSatisfaction &lt;dbl&gt; 3, 3, 2, 4, 4, 3, 1, 1, 2, 2, 3, 4, 1, 4, 3, 4, 1, 2, 1, 3, 1, 3, 2, 2, 1, 4… ## $ JobSatisfaction &lt;dbl&gt; 4, 2, 2, 4, 1, 2, 3, 2, 4, 1, 4, 1, 2, 4, 4, 3, 4, 2, 1, 2, 2, 3, 4, 4, 1, 4… ## $ WorkLifeBalance &lt;dbl&gt; 2, 4, 1, 3, 3, 2, 1, 3, 3, 3, 3, 3, 2, 2, 4, 4, 3, 2, 3, 1, 2, 2, 2, 3, 3, 3… ## $ JobInvolvement &lt;dbl&gt; 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 2, 3, 3, 2, 3, 2, 3, 3, 2, 3, 3, 3, 3, 3… ## $ PerformanceRating &lt;dbl&gt; 3, 4, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 4, 3… ## $ tempo_medio_trabalho &lt;dbl&gt; 7.373651, 7.718969, 7.013240, 7.193678, 8.006175, 10.796096, 6.923570, 6.725… Exercícios: - Conheça melhor nossa variável Resposta. Qual o % da base que saiu da empresa (Attrition = Yes). Baseado nessa informação, qual o pior modelo aceitável? - Quais são as 2 variáveis numéricas que mais influenciam a variável resposta EmployeeID? Façam gráficos para investigar essa relação. - Façam o mesmo para duas variáveis categóricas. 15.1.3.2 Criação do modelo Conforme já comentamos, uma etapa essencial de um projeto de modelagem é criar uma separação de conjuntos de treino e teste. ### separacao de conjuntos de treino e teste # salvar em um objeto o tamanho vertical do dataframe n = nrow(rh) # sortear aleatoriamente 70% das linhas do dataframe para compor # o conjunto de treino ind_treino &lt;- sample(1:n, size = n * 0.7) # criar conjunto de treino rh_treino &lt;- rh[ind_treino, ] # criar conjunto de teste a partir da exclusao das linhas do conjunto de treino rh_teste &lt;- rh[-ind_treino, ] A sintaxe para criar um modelo de Decision Tree no R é bem simples, sendo a mesma da Regressão. A única diferença é que a função usada é rpart: # construcao do modelo mod_arvore &lt;- rpart(Attrition ~ . - EmployeeID, data = rh_treino) # visualizar o modelo rpart.plot::prp(mod_arvore, type = 4, extra = 6, fallen.leaves = FALSE, varlen = 0, faclen = 0, box.palette = &quot;auto&quot;) A árvore ficou meio grande, não? Uma boa alternativa nesse caso é salvar o gráfico da árvore em um pdf no computador: # inicializar pdf em branco pdf(&quot;minha_primeira_arvore.pdf&quot;) # preencher pdf com o grafico da arvore rpart.plot::prp(mod_arvore, type = 4, extra = 6, fallen.leaves = FALSE, varlen = 0, faclen = 0, box.palette = &quot;auto&quot;) # destravar a sessao para o pdf ser salvo dev.off() 15.1.3.3 Avaliação do desempenho preditivo de um modelo de classificação: Vamos avaliar a acurácia do modelo: # criar vetor com previsoes ycast &lt;- predict(mod_arvore, newdata = rh_teste, type = &quot;class&quot;) yreal &lt;- rh_teste$Attrition caret::confusionMatrix(data = ycast, reference = yreal, positive = &quot;Yes&quot;, mode = &quot;everything&quot;) ## Confusion Matrix and Statistics ## ## Reference ## Prediction No Yes ## No 1055 139 ## Yes 23 73 ## ## Accuracy : 0.8744 ## 95% CI : (0.8551, 0.892) ## No Information Rate : 0.8357 ## P-Value [Acc &gt; NIR] : 6.138e-05 ## ## Kappa : 0.414 ## ## Mcnemar&#39;s Test P-Value : &lt; 2.2e-16 ## ## Sensitivity : 0.34434 ## Specificity : 0.97866 ## Pos Pred Value : 0.76042 ## Neg Pred Value : 0.88358 ## Precision : 0.76042 ## Recall : 0.34434 ## F1 : 0.47403 ## Prevalence : 0.16434 ## Detection Rate : 0.05659 ## Detection Prevalence : 0.07442 ## Balanced Accuracy : 0.66150 ## ## &#39;Positive&#39; Class : Yes ## Alguns dos conceitos mostrados acima são: Sensitivity ou Recall: De todos os casos que saíram de fato, quantos foram previstas corretamente? Specificity: De todos os casos que não saíram, quantos foram previstos corretamente? Accuracy: De todos os casos, quantos foram previstos corretamente? Precision: De todos os casos previstos que não iriam sair, quantos de fato não saíram? No Information Rate: Também conhecido como Null Error Rate. Qual teria sido a acurácia de um modelo que previsse sempre o caso mais comum? 15.1.3.4 Random Forest O algoritmo de árvore de decisão, apesar de simples, serviu como base para modelos de árvores mais avançados, generalizáveis e flexíveis. Um deles é o Random Forest, que cria um número \\(N\\) de árvores a partir de uma amostragem de um número \\(p2 &lt; p1\\) de colunas, onde \\(p1\\) é a quantidade total de colunas no conjunto de dados. Os dois livros referenciados são ótimas referências sobre esse algoritmo. Criar um modelo de Random Forest no R também é muito fácil. # construir modelo mod_rf &lt;- randomForest::randomForest(Attrition ~ . - EmployeeID, data = rh_treino, importance = TRUE) # obter previsoes a partir do modelo yhat_rf &lt;- predict(mod_rf, newdata = rh_teste, type = &quot;class&quot;) # obter matriz de confusao caret::confusionMatrix(data = yhat_rf, reference = yreal) ## Confusion Matrix and Statistics ## ## Reference ## Prediction No Yes ## No 1078 9 ## Yes 0 203 ## ## Accuracy : 0.993 ## 95% CI : (0.9868, 0.9968) ## No Information Rate : 0.8357 ## P-Value [Acc &gt; NIR] : &lt; 2.2e-16 ## ## Kappa : 0.9742 ## ## Mcnemar&#39;s Test P-Value : 0.007661 ## ## Sensitivity : 1.0000 ## Specificity : 0.9575 ## Pos Pred Value : 0.9917 ## Neg Pred Value : 1.0000 ## Prevalence : 0.8357 ## Detection Rate : 0.8357 ## Detection Prevalence : 0.8426 ## Balanced Accuracy : 0.9788 ## ## &#39;Positive&#39; Class : No ## Um recurso muito interessante do modelo Random Forest é o cálculo da importância de cada variável, que é medido com base no impacto de realizar permutações de cada variável explanatória usada no modelo sobre alguma métrica de acurácia. O gráfico abaixo mostra que a maior perda de perfomance preditiva ocorre quando a variável de tempo no trabalho é permutada aleatoriamente: varImpPlot(mod_rf, # especificar que a medida de importancia é a perda media de acuracia type = 1, main = &quot;Importância de cada variável explan. no modelo de RF&quot;) O modelo Random Forest também pode ser usado de maneira probabilística, ou seja, mudando o output para a probabilidade de ele ser sim: yhat_rf_prob &lt;- predict(mod_rf, newdata = rh_teste, type = &quot;prob&quot;) head(yhat_rf_prob) ## No Yes ## 1 0.970 0.030 ## 2 0.990 0.010 ## 3 0.988 0.012 ## 4 0.984 0.016 ## 5 0.984 0.016 ## 6 0.206 0.794 15.2 Exercícios Utilizando a base de dados Wage, do pacote ISLR, crie dois data.frames: um com 70% dos dados (train) e outro com 30% (test). Crie um novo objeto chamado fit, a partir da função lm(). Use como variável dependente (\\(Y\\)) a coluna logwage e escolha outras três colunas como variáveis explicativas. Compute as predições desse modelo utilizando a função predict(). Compute a raiz do erro quadrático médio (rmse). (ModelMetrics::rmse()). Inclua outras variáveis e cheque o que acontece com o rmse. library(ISLR) library(ModelMetrics) idx &lt;- sample(nrow(Wage), 0.7 * nrow(Wage)) train &lt;- Wage[idx, ] test &lt;- Wage[idx, ] fit &lt;- lm(logwage ~ age + education + maritl + health_ins, data = train) pred &lt;- predict(fit, test) rmse(actual = test$logwage, predicted = pred) ## [1] 0.2777082 "],
["revisão-titanic.html", "16 Revisão - Titanic 16.1 Objetivo 16.2 Carregando os Dados 16.3 Manipulando os dados 16.4 Idade 16.5 Visualizações 16.6 Modelo Preditivo", " 16 Revisão - Titanic 16.1 Objetivo O objetivo deste capítulo é fazer uma breve revisão do que foi ensinado no curso. Para isso, será utilizada a base disponível no pacote titanic. É esperado que o aluno consiga realizar manipulações nos dados, visualizações e um modelo preditivo. A análise deve ser demonstrada em um documento criado com o RMarkdown. 16.2 Carregando os Dados library(tidyverse) library(titanic) data(&quot;titanic_train&quot;) # Base de treinamento head(titanic_train) ## PassengerId Survived Pclass Name Sex Age SibSp Parch ## 1 1 0 3 Braund, Mr. Owen Harris male 22 1 0 ## 2 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Thayer) female 38 1 0 ## 3 3 1 3 Heikkinen, Miss. Laina female 26 0 0 ## 4 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35 1 0 ## 5 5 0 3 Allen, Mr. William Henry male 35 0 0 ## 6 6 0 3 Moran, Mr. James male NA 0 0 ## Ticket Fare Cabin Embarked ## 1 A/5 21171 7.2500 S ## 2 PC 17599 71.2833 C85 C ## 3 STON/O2. 3101282 7.9250 S ## 4 113803 53.1000 C123 S ## 5 373450 8.0500 S ## 6 330877 8.4583 Q Variável Descrição PassengerId Identificador do Passageiro Survived Variável de indicadora de sobrevivência (0 = Não Sobreviveu, 1 = Sobreviveu) Pclass Classe do passageiro Name Nome do passageiro Sex Sexo do passageiro Age Idade do passageiro SibSp Número de irmãos/cônjuge no navio Parch Número de pais e filhos no navio Ticket Número da passagem Fare Preço da passagem Cabin Código da cabine Embarked Porto de embarque 16.3 Manipulando os dados Nesta seção, faremos alguma alteração nos dados. Veja o summary do dataset. summary(titanic_train) ## PassengerId Survived Pclass Name Sex Age ## Min. : 1.0 Min. :0.0000 Min. :1.000 Length:891 Length:891 Min. : 0.42 ## 1st Qu.:223.5 1st Qu.:0.0000 1st Qu.:2.000 Class :character Class :character 1st Qu.:20.12 ## Median :446.0 Median :0.0000 Median :3.000 Mode :character Mode :character Median :28.00 ## Mean :446.0 Mean :0.3838 Mean :2.309 Mean :29.70 ## 3rd Qu.:668.5 3rd Qu.:1.0000 3rd Qu.:3.000 3rd Qu.:38.00 ## Max. :891.0 Max. :1.0000 Max. :3.000 Max. :80.00 ## NA&#39;s :177 ## SibSp Parch Ticket Fare Cabin Embarked ## Min. :0.000 Min. :0.0000 Length:891 Min. : 0.00 Length:891 Length:891 ## 1st Qu.:0.000 1st Qu.:0.0000 Class :character 1st Qu.: 7.91 Class :character Class :character ## Median :0.000 Median :0.0000 Mode :character Median : 14.45 Mode :character Mode :character ## Mean :0.523 Mean :0.3816 Mean : 32.20 ## 3rd Qu.:1.000 3rd Qu.:0.0000 3rd Qu.: 31.00 ## Max. :8.000 Max. :6.0000 Max. :512.33 ## 16.3.1 Variável Survived A variável Survived está definida como indicadora (1 ou 0). Como será usada em um modelo de classificação, é interessante que esta variável seja transformada ou que seja criada uma nova variável, tornando-a uma variável do tipo factor ou character. titanic_train &lt;- titanic_train %&gt;% mutate(Survived = factor(Survived)) levels(titanic_train$Survived) &lt;- c(&quot;Não&quot;, &quot;Sim&quot;) 16.3.2 Variável Name Na variável Name, percebe-se que os passageiros possuíam títulos: Mr., Miss., Mrs. etc. Seria interessante criar-se uma nova variável que possua apenas o título do passageiro. Para isto, precisaremos usar a função str_extract() do pacote stringr e um pouco de regex. titanic_train &lt;- titanic_train %&gt;% mutate(title = str_extract(tolower(Name), &#39;[a-z]{1,}\\\\.&#39;)) Quais são os títulos mais comuns? titanic_train %&gt;% group_by(title) %&gt;% summarise(n = n()) %&gt;% arrange(-n) ## # A tibble: 17 x 2 ## title n ## &lt;chr&gt; &lt;int&gt; ## 1 mr. 517 ## 2 miss. 182 ## 3 mrs. 125 ## 4 master. 40 ## 5 dr. 7 ## 6 rev. 6 ## 7 col. 2 ## 8 major. 2 ## 9 mlle. 2 ## 10 capt. 1 ## 11 countess. 1 ## 12 don. 1 ## 13 jonkheer. 1 ## 14 lady. 1 ## 15 mme. 1 ## 16 ms. 1 ## 17 sir. 1 Faremos mais uma modificação. Pode ser interessante agregarmos os títulos menos frequentes em uma única categoria. classes_de_interesse &lt;- c(&quot;mr.&quot;, &quot;miss&quot;, &quot;mrs.&quot;, &quot;master.&quot;) titanic_train &lt;- titanic_train %&gt;% mutate(title = ifelse(title %in% classes_de_interesse, title, &quot;other&quot;)) 16.4 Idade Como vimos no summary, há alguns valores faltantes para a variável Age. Alguns modelos conseguem tratar internamente os missing values, outros não. Para o modelo que usaremos, não podemos ter missings. Assim, podemos eliminar essas observações ou atribuir-lhes um valor. Utilizaremos a segunda opção. Para imputação, existem inúmeros métodos, podendo até mesmo ser utilizado o modelo auxiliar. Aqui, vamos inserir a mediana da idade, separando por título e sexo. titanic_train &lt;- titanic_train %&gt;% group_by(Sex, title) %&gt;% mutate(Age = ifelse(is.na(Age), median(Age, na.rm = TRUE), Age)) summary(titanic_train$Age) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.42 22.00 30.00 29.43 35.00 80.00 16.4.1 Exercício Crie mais duas variáveis: 16.5 Visualizações Abaixo, criamos algumas visualizações iniciais. Explore as demais variáveis da base e mostre relações com a variável Survived. library(hrbrthemes) theme_set(theme_ipsum(base_size = 10)) ggplot(titanic_train, aes(x = Age)) + geom_histogram(boundary = 0, fill = &quot;#223e63&quot;, bins = 20) ggplot(titanic_train, aes(x = Age, fill = Survived)) + geom_histogram(boundary = 0, bins = 20) + facet_wrap(~ Survived) + scale_fill_ipsum() ggplot(titanic_train, aes(x = Sex, fill = Survived)) + geom_bar() + labs(title = &quot;Número de passageiros por Sexo&quot;, y = &quot;Contagem&quot;, x = &quot;Sexo&quot;) titanic_train %&gt;% group_by(Sex, Survived) %&gt;% summarise(n = n()) %&gt;% group_by(Sex) %&gt;% mutate(prop = n/sum(n) * 100) %&gt;% ggplot(aes(x = Sex, y = prop, fill = Survived)) + geom_col() + labs(title = &quot;Proporção de Sobreviventes por Sexo&quot;, y = &quot;%&quot;, x = &quot;Sexo&quot;) + scale_fill_ipsum(&quot;Sobreviveu&quot;) Crie mais duas visualizações: 16.6 Modelo Preditivo Crie um modelo preditivo a partir da base de treinamento. Para isso, selecione um subconjunto de variáveis que você utilizará como input (features). Divida a base de treinamentos em duas: 70% para treinamento e 30% para a validação. Utilize a função glm() para estimar um modelo de regressão logística. Calcule a acurácia do modelo. Treine o modelo na base titanic_train completa. Realize predições para base titanic_test. "],
["referências-1.html", "17 Referências", " 17 Referências Informações de sistema: sessioninfo::session_info() ## ─ Session info ────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 3.6.2 (2019-12-12) ## os Ubuntu 18.04.4 LTS ## system x86_64, linux-gnu ## ui RStudio ## language pt_BR:pt:en ## collate pt_BR.UTF-8 ## ctype pt_BR.UTF-8 ## tz America/Sao_Paulo ## date 2020-08-07 ## ## ─ Packages ────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] CRAN (R 3.6.2) ## albersusa * 0.4.1 2020-04-20 [1] Github (hrbrmstr/albersusa@07aa87f) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 3.6.2) ## backports 1.1.6 2020-04-05 [1] CRAN (R 3.6.2) ## bitops 1.0-6 2013-08-17 [1] CRAN (R 3.6.2) ## bookdown 0.18.1 2020-04-20 [1] Github (rstudio/bookdown@cd97d40) ## brmap * 0.1.0 2020-04-20 [1] Github (italocegatta/brmap@6295356) ## broom 0.5.3 2019-12-14 [1] CRAN (R 3.6.2) ## callr 3.4.3 2020-03-28 [1] CRAN (R 3.6.2) ## car 3.0-7 2020-03-11 [1] CRAN (R 3.6.2) ## carData 3.0-3 2019-11-16 [1] CRAN (R 3.6.2) ## caret 6.0-84 2019-04-27 [1] CRAN (R 3.6.2) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 3.6.2) ## choroplethrMaps * 1.0.1 2017-01-31 [1] CRAN (R 3.6.2) ## class 7.3-15 2019-01-01 [4] CRAN (R 3.5.2) ## classInt 0.4-3 2020-04-07 [1] CRAN (R 3.6.2) ## cli 2.0.2 2020-02-28 [1] CRAN (R 3.6.2) ## codetools 0.2-16 2018-12-24 [4] CRAN (R 3.5.2) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 3.6.2) ## countrycode * 1.2.0 2020-05-22 [1] CRAN (R 3.6.2) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 3.6.2) ## crosstalk 1.1.0.1 2020-03-13 [1] CRAN (R 3.6.2) ## curl 4.3 2019-12-02 [1] CRAN (R 3.6.2) ## data.table 1.12.8 2019-12-09 [1] CRAN (R 3.6.2) ## DBI 1.1.0 2019-12-15 [1] CRAN (R 3.6.2) ## dbplyr 1.4.2 2019-06-17 [1] CRAN (R 3.6.2) ## digest 0.6.25 2020-02-23 [1] CRAN (R 3.6.2) ## dplyr * 1.0.1 2020-07-31 [1] CRAN (R 3.6.2) ## dygraphs * 1.1.1.6 2018-07-11 [1] CRAN (R 3.6.2) ## e1071 1.7-3 2019-11-26 [1] CRAN (R 3.6.2) ## ellipsis 0.3.1 2020-05-15 [1] CRAN (R 3.6.2) ## evaluate 0.14 2019-05-28 [1] CRAN (R 3.6.2) ## extrafont 0.17 2014-12-08 [1] CRAN (R 3.6.2) ## extrafontdb 1.0 2012-06-11 [1] CRAN (R 3.6.2) ## fansi 0.4.1 2020-01-08 [1] CRAN (R 3.6.2) ## farver 2.0.3 2020-01-16 [1] CRAN (R 3.6.2) ## forcats * 0.4.0 2019-02-17 [1] CRAN (R 3.6.2) ## foreach 1.4.7 2019-07-27 [1] CRAN (R 3.6.2) ## foreign 0.8-73 2019-12-18 [4] CRAN (R 3.6.2) ## fs 1.5.0 2020-07-31 [1] CRAN (R 3.6.2) ## gapminder * 0.3.0 2017-10-31 [1] CRAN (R 3.6.2) ## gdtools 0.2.2 2020-04-03 [1] CRAN (R 3.6.2) ## generics 0.0.2 2018-11-29 [1] CRAN (R 3.6.2) ## geobr * 1.3 2020-03-29 [1] CRAN (R 3.6.2) ## ggfittext 0.8.1 2019-07-18 [1] CRAN (R 3.6.2) ## ggmap * 3.0.0 2019-02-05 [1] CRAN (R 3.6.2) ## ggplot2 * 3.3.2 2020-06-19 [1] CRAN (R 3.6.2) ## ggrepel * 0.8.2 2020-03-08 [1] CRAN (R 3.6.2) ## ggthemes * 4.2.0 2019-05-13 [1] CRAN (R 3.6.2) ## glue 1.4.1 2020-05-13 [1] CRAN (R 3.6.2) ## gower 0.2.1 2019-05-14 [1] CRAN (R 3.6.2) ## gridExtra 2.3 2017-09-09 [1] CRAN (R 3.6.2) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 3.6.2) ## haven 2.2.0 2019-11-08 [1] CRAN (R 3.6.2) ## highr 0.8 2019-03-20 [1] CRAN (R 3.6.2) ## hms 0.5.3 2020-01-08 [1] CRAN (R 3.6.2) ## hrbrthemes * 0.8.0 2020-03-06 [1] CRAN (R 3.6.2) ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 3.6.2) ## htmlwidgets 1.5.1 2019-10-08 [1] CRAN (R 3.6.2) ## httr 1.4.2 2020-07-20 [1] CRAN (R 3.6.2) ## ipred 0.9-9 2019-04-28 [1] CRAN (R 3.6.2) ## ISLR * 1.2 2017-10-20 [1] CRAN (R 3.6.2) ## iterators 1.0.12 2019-07-26 [1] CRAN (R 3.6.2) ## janitor * 2.0.1 2020-04-12 [1] CRAN (R 3.6.2) ## jpeg 0.1-8.1 2019-10-24 [1] CRAN (R 3.6.2) ## jsonlite * 1.7.0 2020-06-25 [1] CRAN (R 3.6.2) ## KernSmooth 2.23-16 2019-10-15 [4] CRAN (R 3.6.1) ## knitr 1.28 2020-02-06 [1] CRAN (R 3.6.2) ## labeling 0.3 2014-08-23 [1] CRAN (R 3.6.2) ## lattice 0.20-38 2018-11-04 [4] CRAN (R 3.5.1) ## lava 1.6.6 2019-08-01 [1] CRAN (R 3.6.2) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 3.6.2) ## leaflet * 2.0.3 2019-11-16 [1] CRAN (R 3.6.2) ## lifecycle 0.2.0 2020-03-06 [1] CRAN (R 3.6.2) ## literaturaBR * 0.0.3002 2020-04-20 [1] Github (sillasgonzaga/literaturaBR@2ac23fa) ## lubridate * 1.7.9 2020-06-08 [1] CRAN (R 3.6.2) ## magrittr 1.5 2014-11-22 [1] CRAN (R 3.6.2) ## maptools 0.9-9 2019-12-01 [1] CRAN (R 3.6.2) ## MASS 7.3-51.5 2019-12-20 [4] CRAN (R 3.6.2) ## Matrix 1.2-18 2019-11-27 [4] CRAN (R 3.6.1) ## mgcv 1.8-31 2019-11-09 [4] CRAN (R 3.6.1) ## ModelMetrics * 1.2.2.2 2020-03-17 [1] CRAN (R 3.6.2) ## modelr 0.1.5 2019-08-08 [1] CRAN (R 3.6.2) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 3.6.2) ## namer * 0.1.5.9000 2020-08-08 [1] Github (lockedata/namer@eb5768d) ## nlme 3.1-143 2019-12-10 [4] CRAN (R 3.6.2) ## nnet 7.3-12 2016-02-02 [4] CRAN (R 3.5.0) ## nycflights13 * 1.0.1 2019-09-16 [1] CRAN (R 3.6.2) ## openxlsx 4.1.4 2019-12-06 [1] CRAN (R 3.6.2) ## packrat 0.5.0 2018-11-14 [1] CRAN (R 3.6.2) ## patchwork * 1.0.1 2020-06-22 [1] CRAN (R 3.6.2) ## pillar 1.4.6 2020-07-10 [1] CRAN (R 3.6.2) ## pkgbuild 1.0.6 2019-10-09 [1] CRAN (R 3.6.2) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 3.6.2) ## plotly * 4.9.2.1 2020-04-04 [1] CRAN (R 3.6.2) ## plyr 1.8.5 2019-12-10 [1] CRAN (R 3.6.2) ## png 0.1-7 2013-12-03 [1] CRAN (R 3.6.2) ## prettyunits 1.1.1 2020-01-24 [1] CRAN (R 3.6.2) ## processx 3.4.2 2020-02-09 [1] CRAN (R 3.6.2) ## prodlim 2019.11.13 2019-11-17 [1] CRAN (R 3.6.2) ## ps 1.3.2 2020-02-13 [1] CRAN (R 3.6.2) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 3.6.2) ## R6 2.4.1 2019-11-12 [1] CRAN (R 3.6.2) ## randomForest * 4.6-14 2018-03-25 [1] CRAN (R 3.6.2) ## rbcb * 0.1.6 2020-08-08 [1] Github (wilsonfreitas/rbcb@11c6ae4) ## RColorBrewer * 1.1-2 2014-12-07 [1] CRAN (R 3.6.2) ## Rcpp 1.0.5 2020-07-06 [1] CRAN (R 3.6.2) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 3.6.2) ## readxl * 1.3.1 2019-03-13 [1] CRAN (R 3.6.2) ## recipes 0.1.8 2019-12-18 [1] CRAN (R 3.6.2) ## remotes 2.1.1 2020-02-15 [1] CRAN (R 3.6.2) ## reprex 0.3.0 2019-05-16 [1] CRAN (R 3.6.2) ## reshape2 1.4.3 2017-12-11 [1] CRAN (R 3.6.2) ## rgdal 1.4-8 2019-11-27 [1] CRAN (R 3.6.2) ## rgeos 0.5-2 2019-10-03 [1] CRAN (R 3.6.2) ## RgoogleMaps 1.4.5.3 2020-02-12 [1] CRAN (R 3.6.2) ## rio 0.5.16 2018-11-26 [1] CRAN (R 3.6.2) ## rjson 0.2.20 2018-06-08 [1] CRAN (R 3.6.2) ## RJSONIO 1.3-1.4 2020-01-15 [1] CRAN (R 3.6.2) ## rlang 0.4.7 2020-07-09 [1] CRAN (R 3.6.2) ## rmarkdown 2.1.2 2020-04-20 [1] Github (rstudio/rmarkdown@8aeaa6e) ## rpart * 4.1-15 2019-04-12 [1] CRAN (R 3.6.2) ## rpart.plot * 3.0.8 2019-08-22 [1] CRAN (R 3.6.2) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 3.6.2) ## rstudioapi 0.11 2020-02-07 [1] CRAN (R 3.6.2) ## Rttf2pt1 1.3.8 2020-01-10 [1] CRAN (R 3.6.2) ## rvest 0.3.5 2019-11-08 [1] CRAN (R 3.6.2) ## scales 1.1.0 2019-11-18 [1] CRAN (R 3.6.2) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 3.6.2) ## sf * 0.9-5 2020-07-14 [1] CRAN (R 3.6.2) ## snakecase 0.11.0 2019-05-25 [1] CRAN (R 3.6.2) ## sp 1.3-2 2019-11-07 [1] CRAN (R 3.6.2) ## stringi 1.4.6 2020-02-17 [1] CRAN (R 3.6.2) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 3.6.2) ## survival 3.1-8 2019-12-03 [4] CRAN (R 3.6.2) ## systemfonts 0.2.0 2020-04-16 [1] CRAN (R 3.6.2) ## tibble * 3.0.3 2020-07-10 [1] CRAN (R 3.6.2) ## tidyr * 1.1.0 2020-05-20 [1] CRAN (R 3.6.2) ## tidyselect 1.1.0 2020-05-11 [1] CRAN (R 3.6.2) ## tidyverse * 1.3.0 2019-11-21 [1] CRAN (R 3.6.2) ## timeDate 3043.102 2018-02-21 [1] CRAN (R 3.6.2) ## titanic * 0.1.0 2015-08-31 [1] CRAN (R 3.6.2) ## treemapify * 2.5.3 2019-01-30 [1] CRAN (R 3.6.2) ## units 0.6-6 2020-03-16 [1] CRAN (R 3.6.2) ## utf8 1.1.4 2018-05-24 [1] CRAN (R 3.6.2) ## vctrs 0.3.2 2020-07-15 [1] CRAN (R 3.6.2) ## viridis 0.5.1 2018-03-29 [1] CRAN (R 3.6.2) ## viridisLite 0.3.0 2018-02-01 [1] CRAN (R 3.6.2) ## WDI * 2.7.1 2020-07-05 [1] CRAN (R 3.6.2) ## withr 2.2.0 2020-04-20 [1] CRAN (R 3.6.2) ## wpp2019 * 1.1-1 2020-01-31 [1] CRAN (R 3.6.2) ## xfun 0.13 2020-04-13 [1] CRAN (R 3.6.2) ## xml2 1.3.2 2020-04-23 [1] CRAN (R 3.6.2) ## xts * 0.12-0 2020-01-19 [1] CRAN (R 3.6.2) ## yaml 2.2.1 2020-02-01 [1] CRAN (R 3.6.2) ## zip 2.0.4 2019-09-01 [1] CRAN (R 3.6.2) ## zoo * 1.8-8 2020-05-02 [1] CRAN (R 3.6.2) ## ## [1] /home/sillas/R/x86_64-pc-linux-gnu-library/3.6 ## [2] /usr/local/lib/R/site-library ## [3] /usr/lib/R/site-library ## [4] /usr/lib/R/library "]
]
